linux/virt/kvm/kvm_main.c:89:/* The start value to grow halt_poll_ns from */
linux/virt/kvm/kvm_main.c:1691: * With NULL @new this simply removes @old from @active and frees it
linux/include/linux/list.h:393: * including @entry, from @head to @list. You should
linux/include/linux/list.h:419: * excluding @entry, from @head to @list.  You should pass
linux/include/linux/mtd/ftl.h:2: * Derived from (and probably identical to):
linux/include/linux/mtd/nand.h:824: * Return: the row address extracted from @pos.
linux/include/linux/hugetlb.h:84: * For example, a file region structure with from == 0 and to == 4 represents
linux/include/linux/cpumask.h:177: * cpumask_first_and - return the first cpu from *srcp1 & *srcp2
linux/include/linux/cpumask.h:744: * cpumask_any - pick a "random" cpu from *srcp
linux/include/linux/cpumask.h:752: * cpumask_any_and - pick a "random" cpu from *mask1 & *mask2
linux/include/linux/usb.h:1435: *	is a different endpoint (and pipe) from "out" endpoint two.
linux/include/linux/blk-mq.h:326:	 * selection from @cpumask.
linux/include/linux/lru_cache.h:171:	/* the pre-created kmem cache to allocate the objects from */
linux/include/linux/fs.h:2273: * This one is to be used *ONLY* from ->open() instances.
linux/include/linux/sunrpc/svc.h:317:	struct sockaddr_storage	daddr;	/* where reply must come from */
linux/include/linux/random.h:150: * users, but for now we include it from <linux/random.h>
linux/include/linux/poll.h:124:	(from < to ? (v & from) * (to/from) : (v & from) / (from/to))
linux/include/linux/elfnote.h:15: * "FooCo"'s type 42 is distinct from "BarProj"'s type 42).  The
linux/include/linux/bitops.h:46: * passing a bitmap from .bss or .data (-> `!!addr` is always true).
linux/include/linux/lz4.h:230: *	from 'source' to fill 'dest'. New value is necessarily <= old value.
linux/include/linux/lz4.h:236: * from 'source' buffer into already allocated buffer 'dest'
linux/include/linux/lz4.h:240: * possible from 'source'.
linux/include/linux/lz4.h:253: * LZ4_decompress_fast() - Decompresses data from 'source' into 'dest'
linux/include/linux/lz4.h:259: * Decompresses data from 'source' into 'dest'.
linux/include/linux/lz4.h:281: * Decompresses data from 'source' into 'dest'.
linux/include/linux/lz4.h:328: * LZ4_compress_HC() - Compress data from `src` into `dst`, using HC algorithm
linux/include/linux/lz4.h:340: * Compress data from 'src' into 'dst', using the more powerful
linux/include/linux/bpf_verifier.h:173:	 * pointer returned from "sk = bpf_sk_lookup_tcp();":
linux/include/linux/comedi/comedidev.h:33: * @type: Type of subdevice from &enum comedi_subdevice_type.  (Initialized by
linux/include/linux/comedi/comedidev.h:894: *	-EINVAL if *@arg differed from @val.
linux/include/linux/fscache.h:443: * @cres->inval_counter is set from @cookie->inval_counter for comparison at
linux/include/linux/fscache.h:528: * @cres->inval_counter is set from @cookie->inval_counter for comparison at
linux/include/linux/prime_numbers.h:30: * Starting from @from iterate over each successive prime number up to the
linux/include/linux/pm.h:92: *	substantial amounts of memory from @prepare() in the GFP_KERNEL mode.
linux/include/linux/usb/composite.h:373: * Before returning from @bind, various fields in the template descriptor
linux/include/linux/avf/virtchnl.h:904:	u16 offset; /* queues in a channel start from 'offset' */
linux/include/linux/msi.h:355: * @first:	Index to start freeing from (inclusive)
linux/include/linux/gpio/driver.h:539: * @size:	amount of GPIOs to check starting from @base
linux/include/linux/overflow.h:72: * @b: subtrahend; value to subtract from @a
linux/include/linux/overflow.h:219: * @subtrahend: value to subtract from @minuend
linux/include/linux/zstd_lib.h:935: *  Create an internal CDict from `dict` buffer.
linux/include/linux/zstd_lib.h:1173:                               * Ranges from [0, 3].
linux/include/linux/atomic/atomic-arch-fallback.h:1187: * Atomically subtracts @i from @v and returns
linux/include/linux/atomic/atomic-arch-fallback.h:2403: * Atomically subtracts @i from @v and returns
linux/include/linux/tpm.h:199:/* Indicates from what layer of the software stack the error comes from */
linux/include/linux/fsverity.h:268: * Filesystems call this from ->readahead() to check whether the pages need to
linux/include/linux/buffer_head.h:290:/* Convert errno to return value from ->page_mkwrite() call */
linux/include/linux/mc6821.h:13: * zodiac@darkness.gun.de) and Motorola Data Sheet (from 
linux/include/linux/compiler-gcc.h:28: * the inline assembly constraint from =g to =r, in this particular
linux/include/linux/damon.h:379: * @apply_scheme is called from @kdamond when a region for user provided
linux/include/linux/damon.h:385: * @cleanup is called from @kdamond just before its termination.
linux/include/linux/xarray.h:630: * After this function returns, loading from @index will return %NULL.
linux/include/linux/xarray.h:654: * After this function returns, loading from @index will return %NULL.
linux/include/linux/mm.h:1076: * The atomic page->_mapcount, starts from -1: so that transitions
linux/include/linux/bootconfig.h:186: * Iterate array value nodes and values starts from @anode. This is expected to
linux/include/linux/pci.h:2562: * Walk upwards from @pdev and check for each encountered bridge if it's part
linux/include/linux/netfilter/ipset/pfxlen.h:41:	from &= ip_set_hostmask(cidr);		\
linux/include/linux/netfilter/ipset/pfxlen.h:42:	to = from | ~ip_set_hostmask(cidr);	\
linux/include/linux/rtc.h:7: * from <linux/mc146818rtc.h> to this file for 2.4 kernels.
linux/include/linux/greybus/greybus_protocols.h:886: *	0 the default (from @spi_device) is used.
linux/include/linux/greybus/greybus_protocols.h:893: *	transfer. If 0 the default (from @spi_device) is used.
linux/include/linux/if_vlan.h:479: * Clears the VLAN information from @skb
linux/include/linux/if_vlan.h:491: * Copies VLAN information from @src to @dst (for branchless code)
linux/include/linux/if_vlan.h:502: * Pushes the VLAN tag from @skb->vlan_tci inside to the payload.
linux/include/linux/find.h:646: * for_each_set_bit_wrap - iterate over all set bits starting from @start, and
linux/include/linux/clk/ti.h:160: * @clkdm: pointer to struct clockdomain, resolved from @clkdm_name at runtime
linux/include/linux/device.h:550: *		instance from ->dma_supported.
linux/include/linux/ceph/libceph.h:229: * @lookup_param_type is a parameter and not constructed from (@type,
linux/include/linux/ceph/osdmap.h:187:	struct rb_root pg_upmap_items;	/* from -> to within raw set */
linux/include/linux/highmem.h:414:	char *from = kmap_local_page(page);
linux/include/linux/highmem.h:417:	memcpy(to, from + offset, len);
linux/include/linux/highmem.h:458:	char *from = kmap_local_folio(folio, offset);
linux/include/linux/dccp.h:40:	 *    - PASSIVE_CLOSEREQ (from (PART)OPEN to CLOSING; case (b) above).
linux/include/linux/clocksource.h:153:	 *  mult = from * 2^shift / freq
linux/include/linux/stackdepot.h:79: * Saves a stack trace from @entries array of size @nr_entries. If @can_alloc is
linux/include/linux/drbd.h:191:	 * from >= C_CONNECTED to Unconnected.
linux/include/linux/fixp-arith.h:47: * The returned value ranges from -0x7fffffff to +0x7fffffff.
linux/include/linux/fixp-arith.h:71: * The returned value ranges from -0x7fffffff to +0x7fffffff.
linux/include/linux/fixp-arith.h:86: * The returned value ranges from -0x7fff to 0x7fff
linux/include/linux/pagemap.h:360: * use it is if, like NFS, you return 0 from ->activate_swapfile.
linux/include/linux/soc/pxa/mfp.h:431: * represents a range of MFP pins from "start" to "end", with the offset
linux/include/linux/ethtool.h:683: *	flags from &enum ethtool_reset_flags.  Returns a negative
linux/include/linux/skbuff.h:168: *   from &sk_buff.csum_start up to the end, and to record/write the checksum at
linux/include/linux/bcma/bcma_driver_chipcommon.h:609:	bool boot;		/* This is the flash the SoC boots from */
linux/include/linux/fortify-string.h:76: * @bytes: How many bytes to write to @dst from @src
linux/include/linux/fortify-string.h:379: * @count: Maximum bytes to read from @q
linux/include/linux/fortify-string.h:381: * Appends at most @count bytes from @q (stopping at the first
linux/include/linux/platform_data/media/mmp-camera.h:16:	int mclk_src;	/* which clock source the MCLK derives from */
linux/include/linux/platform_data/cros_ec_commands.h:348: * bit 0 (EC_FEATURE_LIMITED) changes meaning from "EC code has a limited set
linux/include/linux/platform_data/cros_ec_commands.h:2971:	uint8_t slot; /* Slot to read from */
linux/include/linux/cpufeature.h:16: * Macros imported from <asm/cpufeature.h>:
linux/include/linux/console.h:39: * @con_scroll: move lines from @top to @bottom in direction @dir by @lines.
linux/include/linux/cm4000_cs.h:25: * I've changed "ptsreq.protocol" from "unsigned long" to "u_int32_t".
linux/include/linux/spi/spi.h:166: *	deasserted. If @cs_change_delay is used from @spi_transfer, then the
linux/include/linux/spi/spi.h:926: *      transfer. If 0 the default (from @spi_device) is used.
linux/include/linux/spi/spi.h:928: *      for this transfer. If 0 the default (from @spi_device) is used.
linux/include/dt-bindings/clock/rk3188-cru-common.h:10:/* core clocks from */
linux/include/trace/events/afs.h:1037:		    __entry->from  = afs_folio_dirty_from(folio, priv);
linux/include/trace/events/afs.h:1068:		    __entry->from = from;
linux/include/trace/events/afs.h:1309:		    __entry->from = fl->fl_start;
linux/include/trace/events/ext4.h:2007:		  "from %u to %u partial [pclu %lld lblk %u state %d]",
linux/include/trace/events/qrtr.h:110:	TP_printk("%s from %d:%d",
linux/include/trace/events/target.h:14:/* cribbed verbatim from <trace/event/scsi.h> */
linux/include/trace/events/rdma_core.h:112:	TP_printk("cq.id=%u wake-up took %lld [us] from %s",
linux/include/trace/events/ufs.h:127:	TP_printk("%s: %s %s from %u to %u Hz",
linux/include/trace/events/power.h:126:		__entry->from = from;
linux/include/trace/events/jbd2.h:350:	TP_printk("dev %d,%d from %u to %u offset %lu freed %lu",
linux/include/trace/events/bcache.h:34:	TP_printk("%d,%d %s %llu + %u (from %d,%d @ %llu)",
linux/include/trace/events/bcache.h:421:	TP_printk("found %u keys from %u:%llu to %u:%llu", __entry->nr_found,
linux/include/asm-generic/bitops/generic-non-atomic.h:163: * directly from "regular" code.
linux/include/asm-generic/iomap.h:15: * Don't include this directly, include it from <asm/io.h>.
linux/include/asm-powerpc/page_64.h:75:		from += 4096;
linux/include/crypto/internal/kpp.h:139: * end of a &struct kpp_instance instantiated from &crypto_template.create().
linux/include/crypto/aead.h:502: * @cryptlen: number of bytes to process from @src
linux/include/crypto/skcipher.h:589: * @cryptlen: number of bytes to process from @src
linux/include/acpi/platform/aclinuxex.h:79: * By executing spin_lock_init() in a macro the key changes from "lock" for
linux/include/media/videobuf2-v4l2.h:105: * Should be called from &v4l2_ioctl_ops->vidioc_prepare_buf ioctl handler
linux/include/media/videobuf2-v4l2.h:117: * from &v4l2_ioctl_ops->vidioc_prepare_buf handler in driver.
linux/include/media/videobuf2-v4l2.h:129: * Should be called from &v4l2_ioctl_ops->vidioc_qbuf handler of a driver.
linux/include/media/videobuf2-v4l2.h:143: * from &v4l2_ioctl_ops->vidioc_qbuf handler in driver.
linux/include/media/videobuf2-v4l2.h:155: * from &v4l2_ioctl_ops->vidioc_expbuf handler in driver.
linux/include/media/videobuf2-v4l2.h:168: * Should be called from &v4l2_ioctl_ops->vidioc_dqbuf ioctl handler
linux/include/media/videobuf2-v4l2.h:181: * from &v4l2_ioctl_ops->vidioc_dqbuf handler in driver.
linux/include/media/videobuf2-v4l2.h:191: * Should be called from &v4l2_ioctl_ops->vidioc_streamon handler of a driver.
linux/include/media/videobuf2-v4l2.h:199: * from &v4l2_ioctl_ops->vidioc_streamon handler in the driver.
linux/include/media/videobuf2-core.h:410: *			finish and give back all buffers it got from &buf_queue
linux/include/media/v4l2-mem2mem.h:829: * and TSTAMP_SRC_MASK flags from @out_vb to @cap_vb.
linux/include/media/v4l2-dev.h:260: *	Only set @dev_parent if that can't be deduced from @v4l2_dev.
linux/include/media/v4l2-dev.h:476: * video_get_drvdata - gets private data from &struct video_device.
linux/include/media/v4l2-dev.h:488: * video_set_drvdata - sets private data from &struct video_device.
linux/include/media/v4l2-dev.h:506: * video_drvdata - gets private data from &struct video_device using the
linux/include/media/dvb_vb2.h:165: * @len:	number of bytes to be copied from @src
linux/include/media/cec.h:37: * To add or remove filehandles from @fhs the @lock must be taken first,
linux/include/media/v4l2-mediabus.h:199: * @code:	data format code (from &enum v4l2_mbus_pixelcode)
linux/include/media/cec-notifier.h:100: * cec_notifier_parse_hdmi_phandle - find the hdmi device from "hdmi-phandle"
linux/include/media/media-device.h:132: * link between them from @enable_source and deactivate
linux/include/media/media-device.h:133: * from @disable_source.
linux/include/scsi/sg.h:114:#define SG_FLAG_NO_DXFER 0x10000 /* no transfer of kernel buffers to/from */
linux/include/scsi/scsi_device.h:231:	unsigned int max_device_blocked; /* what device_blocked counts down from  */
linux/include/video/hecubafb.h:29:/* struct used by hecuba. board specific stuff comes from *board */
linux/include/video/metronomefb.h:22:/* struct used by metronome. board specific stuff comes from *board */
linux/include/video/broadsheetfb.h:45:/* struct used by broadsheet. board specific stuff comes from *board */
linux/include/drm/drm_atomic.h:702: * @state, or if the plane isn't part of the atomic state update, from @plane.
linux/include/drm/drm_atomic.h:1114:	 * @base: inherit from &drm_private_state
linux/include/drm/drm_atomic_helper.h:185: * in code called from &drm_mode_config_funcs.atomic_check operations, to
linux/include/drm/drm_atomic_helper.h:199: * in code called from &drm_mode_config_funcs.atomic_check operations, to
linux/include/drm/drm_modeset_helper_vtables.h:1074:	 * called from &drm_atomic_helper_check_modeset, and is called when
linux/include/drm/drm_auth.h:89:	 * lessee holding a lease of objects from @lessor. Full owners of the
linux/include/drm/drm_crtc.h:144:	 * check code, e.g. from &drm_encoder_helper_funcs.atomic_check
linux/include/drm/drm_crtc.h:945:	 * List of all CRTCs on @dev, linked from &drm_mode_config.crtc_list.
linux/include/drm/drm_kunit_helpers.h:28: * This function creates a struct &drm_device from @_dev and @_drv.
linux/include/drm/drm_kunit_helpers.h:73: * &drm_device from @_dev and that driver.
linux/include/drm/ttm/ttm_resource.h:265: * @start: Offset that needs to be subtracted from @st to make
linux/include/drm/drm_plane.h:600:	 * List of all planes on @dev, linked from &drm_mode_config.plane_list.
linux/include/drm/drm_bridge.h:710:	/** @base: inherit from &drm_private_object */
linux/include/net/ip6_fib.h:303:	from = rcu_dereference(rt->from);
linux/include/net/ip6_fib.h:471:	from = rcu_dereference(rt->from);
linux/include/net/mac80211.h:1530: * @enc_flags: uses bits from &enum mac80211_rx_encoding_flags
linux/include/net/mac80211.h:1531: * @he_ru: HE RU, from &enum nl80211_he_ru_alloc
linux/include/net/mac80211.h:1532: * @he_gi: HE GI, from &enum nl80211_he_gi
linux/include/net/mac80211.h:1535: * @eht.ru: EHT RU, from &enum nl80211_eht_ru_alloc
linux/include/net/mac80211.h:1536: * @eht.gi: EHT GI, from &enum nl80211_eht_gi
linux/include/net/mac80211.h:3506: * @action: the ampdu action, value from %ieee80211_ampdu_mlme_action.
linux/include/net/mac80211.h:3705: *	(MLD) parameters from &struct ieee80211_vif_cfg that vary during the
linux/include/net/mac80211.h:3711: *	parameters from &struct ieee80211_bss_conf that are related to an
linux/include/net/mac80211.h:3878: *	from &enum ieee80211_rate_control_changed and the values are reflected
linux/include/net/mac80211.h:4217: * @net_fill_forward_path: Called from .ndo_fill_forward_path in order to
linux/include/net/mac80211.h:4234: * @net_setup_tc: Called from .ndo_setup_tc in order to prepare hardware
linux/include/net/mac80211.h:6579: * checks if any frames in the window starting from @ssn can now be released
linux/include/net/inet_hashtables.h:334:   and compare with 32bit value read from &...->dport.  Let's at least
linux/include/net/page_pool.h:78:	int		nid;  /* Numa node id to allocate from pages from */
linux/include/net/udp_tunnel.h:310:	/* This helper is used from .sync_table, we indicate empty entries
linux/include/net/dsa.h:666: * that the routing port from @downstream_ds to @upstream_ds is also the port
linux/include/net/inet_ecn.h:141:	from = *(__be32 *)iph;
linux/include/net/inet_ecn.h:142:	to = from | htonl(INET_ECN_CE << 20);
linux/include/net/inet_ecn.h:157:	from = *(__be32 *)iph;
linux/include/net/inet_ecn.h:158:	to = from ^ htonl(INET_ECN_MASK << 20);
linux/include/net/cfg80211.h:156: * @freq_offset: offset from @center_freq, in KHz
linux/include/net/cfg80211.h:158: * @flags: channel flags from &enum ieee80211_channel_flags.
linux/include/net/cfg80211.h:746: * @freq1_offset: offset from @center_freq1, in KHz
linux/include/net/cfg80211.h:1070: * @filled: bitflag of flags from &enum survey_info_flags
linux/include/net/cfg80211.h:1749: * @flags: bitflag of flags from &enum rate_info_flags
linux/include/net/cfg80211.h:1753: * @bw: bandwidth (from &enum rate_info_bw)
linux/include/net/cfg80211.h:1754: * @he_gi: HE guard interval (from &enum nl80211_he_gi)
linux/include/net/cfg80211.h:1756: * @he_ru_alloc: HE RU allocation (from &enum nl80211_he_ru_alloc,
linux/include/net/cfg80211.h:1759: * @eht_gi: EHT guard interval (from &enum nl80211_eht_gi)
linux/include/net/cfg80211.h:1760: * @eht_ru_alloc: EHT RU allocation (from &enum nl80211_eht_ru_alloc,
linux/include/net/cfg80211.h:1798: * @flags: bitflag of flags from &enum bss_param_flags
linux/include/net/cfg80211.h:1895: * @assoc_req_ies: IEs from (Re)Association Request.
linux/include/net/cfg80211.h:1937: * @assoc_resp_ies: IEs from (Re)Association Response.
linux/include/net/cfg80211.h:2139: * @filled: bitfield of flags from &enum mpath_info_flags
linux/include/net/cfg80211.h:5055: * @changed: contains value from &enum wiphy_opmode_flag
linux/include/net/cfg80211.h:5056: * @smps_mode: New SMPS mode value from &enum nl80211_smps_mode of a station
linux/include/net/cfg80211.h:5057: * @bw: new max bandwidth value from &enum nl80211_chan_width of a station
linux/include/net/cfg80211.h:5306: * @ap_sme_capa: AP SME capabilities, flags from &enum nl80211_ap_sme_features.
linux/include/net/cfg80211.h:6034: * ieee80211_s1g_channel_width - get allowed channel width from @chan
linux/include/net/cfg80211.h:6086: * Return: The channel struct from @wiphy at @freq.
linux/include/net/cfg80211.h:6096: * Return: The channel struct from @wiphy at @freq.
linux/include/net/bond_alb.h:138:	struct slave		*rx_slave;/* last slave to xmit from */
linux/include/uapi/linux/iso_fs.h:13:#define ISODCL(from, to) (to - from + 1)
linux/include/uapi/linux/firewire-cdev.h:175: * @card may differ from &fw_cdev_get_info.card because requests are received
linux/include/uapi/linux/aio_abi.h:59:/* read() from /dev/aio returns these structures. */
linux/include/uapi/linux/aio_abi.h:62:	__u64		obj;		/* what iocb this event came from */
linux/include/uapi/linux/acrn.h:556: * creates a &struct hsm_ioeventfd with properties originated from &struct
linux/include/uapi/linux/bpf.h:1661: * 		Delete entry with *key* from *map*.
linux/include/uapi/linux/bpf.h:2188: * 		packet. It can be used to load *len* bytes from *offset* from
linux/include/uapi/linux/bpf.h:2445: * 		from *skb* readable and writable. If a zero value is passed for
linux/include/uapi/linux/bpf.h:2576: * 		*skb*, but gets socket from **struct bpf_sock_addr** context.
linux/include/uapi/linux/bpf.h:2583: * 		*skb*, but gets socket from **struct bpf_sock_ops** context.
linux/include/uapi/linux/bpf.h:3133: * 		it provides an easy way to load *len* bytes from *offset*
linux/include/uapi/linux/bpf.h:3483: *		result is from *reuse*\ **->socks**\ [] using the hash of the
linux/include/uapi/linux/bpf.h:3520: *		result is from *reuse*\ **->socks**\ [] using the hash of the
linux/include/uapi/linux/bpf.h:3543: * 		Pop an element from *map*.
linux/include/uapi/linux/bpf.h:3549: * 		Get an element from *map* without removing it.
linux/include/uapi/linux/bpf.h:3700: *		result is from *reuse*\ **->socks**\ [] using the hash of the
linux/include/uapi/linux/bpf.h:4253: *		returned from **bpf_sk_lookup_xxx**\ (),
linux/include/uapi/linux/bpf.h:4282: * 		Copy *size* bytes from *data* into a ring buffer *ringbuf*.
linux/include/uapi/linux/bpf.h:4664: * 		This helper differs from **bpf_get_cgroup_classid**\ () in that
linux/include/uapi/linux/bpf.h:4715: *		the kernel. Different from **bpf_per_cpu_ptr**\ (), it would
linux/include/uapi/linux/bpf.h:5226: *		xdp buffer. It can be used to load *len* bytes from *offset* from
linux/include/uapi/linux/bpf.h:5359: *		Read *len* bytes from *src* into *dst*, starting from *offset*
linux/include/uapi/linux/bpf.h:5369: *		Write *len* bytes from *src* into *dst*, starting from *offset*
linux/include/uapi/linux/comedi.h:552: * %CMDF_RAWDATA - prevents the command from "munging" the data between the
linux/include/uapi/linux/comedi.h:672: * values in COMEDI are unsigned from %0 up to some 'maxdata' value.  The
linux/include/uapi/linux/comedi.h:693: * @type:		Type of subdevice from &enum comedi_subdevice_type.
linux/include/uapi/linux/joystick.h:37: * Types and constants for reading from /dev/js
linux/include/uapi/linux/um_timetravel.h:36:	 * @op: operation value from &enum um_timetravel_ops
linux/include/uapi/linux/iommu.h:61: * @reason: reason of the fault, from &enum iommu_fault_reason
linux/include/uapi/linux/iommu.h:109: * @type: fault type from &enum iommu_fault_type
linux/include/uapi/linux/iommu.h:148: * @code: response code from &enum iommu_page_response_code
linux/include/uapi/linux/nl80211.h:1844: *	(a u32 with flags from &enum nl80211_wpa_versions).
linux/include/uapi/linux/nl80211.h:1995: *	containing attributes from &enum nl80211_meshconf_params.
linux/include/uapi/linux/nl80211.h:2635: *	using attributes from &enum nl80211_iftype_akm_attributes. This
linux/include/uapi/linux/nl80211.h:4057: *	attributes from &enum nl80211_band_iftype_attr
linux/include/uapi/linux/nl80211.h:5430: *	Its type is u8, using the values from &nl80211_tid_config.
linux/include/uapi/linux/nl80211.h:5433: *	the values from &nl80211_tid_config.
linux/include/uapi/linux/nl80211.h:5436: *	Its type is u8, using the values from &nl80211_tid_config.
linux/include/uapi/linux/nl80211.h:5541: *	defining a with attributes from &struct nl80211_wowlan_trig_pkt_pattern.
linux/include/uapi/linux/nl80211.h:7161: *	(using values from &enum nl80211_peer_measurement_status.)
linux/include/uapi/linux/nl80211.h:7274: *	from &enum nl80211_preamble.
linux/include/uapi/linux/btrfs.h:600:/* With a @src_length of zero, the range from @src_offset->EOF is cloned! */
linux/include/uapi/linux/netfilter/nf_tables.h:689: * @NFTA_RANGE_FROM_DATA: data range from (NLA_NESTED: nft_data_attributes)
linux/include/uapi/linux/netfilter/nf_tables.h:832: * @NFTA_PAYLOAD_SREG: source register to load data from (NLA_U32: nft_registers)
linux/include/uapi/linux/netfilter/xt_HMARK.h:49:	__u32			hoffset;	/* Mark offset to start from */
linux/include/uapi/linux/rtc.h:7: * from <linux/mc146818rtc.h> to this file for 2.4 kernels.
linux/include/uapi/linux/virtio_net.h:149:			/* Position to start checksumming from */
linux/include/uapi/linux/virtio_net.h:194:	__virtio16 csum_start;	/* Position to start checksumming from */
linux/include/uapi/linux/rkisp1-config.h:413: * @effect: values from 'enum v4l2_colorfx'. Possible values are: V4L2_COLORFX_SEPIA,
linux/include/uapi/linux/rkisp1-config.h:563: *		and 7 bit fractional part, ranging from -8 (0x400) to +7.992 (0x3FF). 0 is
linux/include/uapi/linux/ethtool.h:889: * @flags: A bitmask of flags from &enum ethtool_test_flags.  Some
linux/include/uapi/linux/ethtool.h:1237: *	On return from %ETHTOOL_GRXFHINDIR, the array size of the hardware
linux/include/uapi/linux/ethtool.h:1262: *	%ETH_RXFH_INDIR_NO_CHANGE.  On return from %ETHTOOL_GRSSH,
linux/include/uapi/linux/ethtool.h:1265: *	which may be zero.  On return from %ETHTOOL_GRSSH, the size of the
linux/include/uapi/linux/ethtool.h:1537: * of returning %EOPNOTSUPP from %ETHTOOL_GFECPARAM.
linux/include/uapi/linux/shm.h:49:#define SHM_R		0400	/* or S_IRUGO from <linux/stat.h> */
linux/include/uapi/linux/shm.h:50:#define SHM_W		0200	/* or S_IWUGO from <linux/stat.h> */
linux/include/uapi/linux/gpio.h:116: * @id: attribute identifier with value from &enum gpio_v2_line_attr_id
linux/include/uapi/linux/gpio.h:119: * line, with values from &enum gpio_v2_line_flag, such as
linux/include/uapi/linux/gpio.h:155: * @flags: flags for the GPIO lines, with values from &enum
linux/include/uapi/linux/gpio.h:218: * @flags: flags for this GPIO line, with values from &enum
linux/include/uapi/linux/gpio.h:253: * @event_type: the type of change with a value from &enum
linux/include/uapi/linux/gpio.h:278: * @id: event identifier with value from &enum gpio_v2_line_event_id
linux/include/uapi/linux/gpio.h:286: * By default the @timestamp_ns is read from %CLOCK_MONOTONIC and is
linux/include/uapi/linux/gpio.h:291: * @timestamp_ns is read from %CLOCK_REALTIME.
linux/include/uapi/sound/asequencer.h:39:#define SNDRV_SEQ_EVENT_PITCHBEND	13	/**< from -8192 to 8191 */
linux/include/uapi/asm-generic/siginfo.h:318: * It seems likely that SIGEV_THREAD will have to be handled from 
linux/include/uapi/scsi/cxlflash_ioctl.h:129:	__u64 context_id_src;		/* Context to clone from */
linux/include/uapi/drm/i915_drm.h:894:	/** Offset into the object to read from */
linux/include/uapi/drm/ivpu_accel.h:161:	 * Allocate VPU address from >4GB range.
linux/include/uapi/drm/qxl_drm.h:76:	__u32 src_handle; /* dest handle to compute address from */
linux/include/uapi/drm/radeon_drm.h:896:	/** Offset into the object to read from */
linux/include/uapi/drm/drm_fourcc.h:960: * This is the primary layout that the V3D GPU can texture from (it
linux/include/soc/tegra/bpmp-abi.h:2945:	/** @brief Strap ID from @ref Strap_Identifiers */
linux/include/soc/fsl/qman.h:577:/* Convert CGR thresholds to/from "cs_thres" format */
linux/include/soc/fsl/qman.h:711: * state, and the resulting park notifications move FQs from "sched" to
linux/include/soc/fsl/qman.h:745: *     // in a dequeue callback, access extra fields from 'fq' via a cast;
linux/include/soc/fsl/qman.h:1086: * @fd. The descriptor details are copied from @fd to the EQCR entry, the 'pid'
linux/Documentation/virt/kvm/api.rst:4138:bitmap range covers MSRs from [base .. base+nmsrs).
linux/Documentation/virt/kvm/x86/timekeeping.rst:564:fluctuates - from (T-1.. T+10).  Thus, any time calculated from a TSC, but
linux/Documentation/virt/uml/user_mode_linux_howto_v2.rst:713:In addition to managing the image from "the inside" using normal sysadmin tools,
linux/Documentation/ABI/stable/sysfs-block:633:		safe to toggle the setting from "write back" to "write through",
linux/Documentation/ABI/testing/sysfs-firmware-dmi-tables:15:		from /dev/mem. The raw SMBIOS entry point and DMI table are
linux/Documentation/ABI/testing/sysfs-bus-iio-cros-ec:7:                corresponding calibration offsets can be read from `*_calibbias`
linux/Documentation/ABI/testing/debugfs-ec:9:the EC here (XY -> GPE number from `/sys/kernel/debug/ec/*/gpe`):
linux/Documentation/ABI/testing/sysfs-power:204:		returned by reads from /sys/power/state.  If that happens, a
linux/Documentation/ABI/testing/sysfs-bus-iio:1782:		value resulted from <type>[_name]_oversampling_ratio measurements
linux/Documentation/ABI/testing/sysfs-driver-ge-achc:7:		from /lib/firmware). The write will block until the FW
linux/Documentation/ABI/testing/sysfs-bus-iio-light-isl29018:13:		range of Scheme 1 proximity count is from -2^(n-1) to 2^(n-1).
linux/Documentation/ABI/testing/sysfs-class-watchdog:114:				from (CS0->CS1, CS1->CS0) to (CS0->CS0,
linux/Documentation/ABI/testing/sysfs-class-net-qmi:9:		framing from '802.3' to 'raw-ip'.
linux/Documentation/networking/can_ucan_protocol.rst:237:The echo-id identifies the frame from (echos the id from a previous
linux/Documentation/networking/j1939.rst:239:address. The PGN from ``connect(2)`` is used as the default PGN when sending
linux/Documentation/networking/j1939.rst:244:Both ``write(2)`` and ``send(2)`` will send a packet with local address from ``bind(2)`` and the
linux/Documentation/networking/j1939.rst:245:remote address from ``connect(2)``. Use ``sendto(2)`` to overwrite the destination
linux/Documentation/networking/scaling.rst:80:of queues to IRQs can be determined from /proc/interrupts. By default,
linux/Documentation/networking/tls-offload.rst:102:sequence number from ``crypto_info``. The driver can add its state
linux/Documentation/networking/filter.rst:628:originates from [e]xtended BPF is not the same as BPF extensions! While
linux/Documentation/networking/device_drivers/hamradio/z8530drv.rst:354:configure "rxecho" to echo the incoming frames from "9k6" to "axlink"
linux/Documentation/networking/device_drivers/hamradio/z8530drv.rst:355:and outgoing frames from "axlink" to "9k6" and start::
linux/Documentation/networking/device_drivers/ethernet/3com/vortex.rst:397:   - If it is a PCI device, the relevant output from 'lspci -vx', eg::
linux/Documentation/networking/device_drivers/ethernet/freescale/dpaa2/mac-phy-support.rst:105:(1) phylink_start() called from .dev_open().
linux/Documentation/networking/device_drivers/wifi/intel/ipw2100.rst:217:You can obtain these images from <http://ipw2100.sf.net/firmware.php>.
linux/Documentation/networking/xfrm_device.rst:153:		xs = find xs from (spi, protocol, dest_IP)
linux/Documentation/networking/ethtool-netlink.rst:1524: | ``ETHTOOL_A_MODULE_EEPROM_DATA``            | binary | array of bytes from |
linux/Documentation/networking/ethtool-netlink.rst:1615:from ``enum ethtool_mac_stats_src``. If absent from the request, stats will be
linux/Documentation/networking/ethtool-netlink.rst:1967:the default values from ``ETHTOOL_MSG_MM_GET`` requests.
linux/Documentation/networking/ip-sysctl.rst:141:	Whether to update SKB priority from "TOS" field in IPv4 header after it
linux/Documentation/networking/statistics.rst:23:Most commonly used is the `ip` command from `iproute2`::
linux/Documentation/networking/statistics.rst:203:a recent copy from `.ndo_get_stats64`. Ethtool interrupt coalescing interface
linux/Documentation/networking/arcnet.rst:235:By the way, be sure to change all references from "eth0" to "arc0" in the
linux/Documentation/networking/dccp.rst:72:initialised from /proc/sys/net/dccp/default/tx_qlen.
linux/Documentation/networking/vrf.rst:362:	2002:1::32 from :: dev eth1  table red  proto kernel  src 2002:1::2  metric 256  pref medium
linux/Documentation/networking/vrf.rst:419:     Interface addresses from /etc/network/interfaces:
linux/Documentation/process/email-clients.rst:111:  from :menuselection:`Format-->Paragraph Style-->Preformatted` (:kbd:`CTRL-7`)
linux/Documentation/process/email-clients.rst:240:  set from = "username@gmail.com"
linux/Documentation/process/email-clients.rst:327:  - Set ``mailnews.wraplength`` from ``72`` to ``0``
linux/Documentation/process/maintainer-pgp-guide.rst:713:    # gpg: Good signature from [...]
linux/Documentation/process/coding-style.rst:1147:functions unconditionally from .c files.  The compiler will avoid generating
linux/Documentation/process/adding-syscalls.rst:563: - Numbering oddities arising from (re-)use of O_* numbering space flags:
linux/Documentation/process/changes.rst:339:would take information about active clients from ``/var/lib/nfs/rmtab``.
linux/Documentation/security/siphash.rst:119:possibility. HalfSipHash cuts SipHash's rounds down from "2-4" to "1-3" and,
linux/Documentation/security/SCTP.rst:219:     Set the sctp ``@asoc sid`` to socket's sid (from ``asoc->base.sk``) with
linux/Documentation/security/SCTP.rst:220:     MLS portion taken from ``@skb peer sid``. This will be used by SCTP
linux/Documentation/sound/designs/oss-emulation.rst:228:from "PCM Playback Volume" and "PCM Playback Switch" controls for the
linux/Documentation/sound/designs/oss-emulation.rst:229:playback direction and from "PCM Capture Volume" and "PCM Capture
linux/Documentation/sound/designs/seq-oss.rst:154:events from ``/dev/sequencer`` are processed and put onto the queue
linux/Documentation/sound/designs/seq-oss.rst:157:All the events from ``/dev/sequencer`` are parsed at beginning.
linux/Documentation/sound/alsa-configuration.rst:376:If ``dma2`` is specified and different from ``dma1``, the card will operate in
linux/Documentation/sound/alsa-configuration.rst:418:If ``dma2`` is specified and different from ``dma1``, the card will operate in
linux/Documentation/sound/alsa-configuration.rst:2671:The first number from ``/dev/snd/pcmC{X}D{Y}[c|p]`` expression means
linux/Documentation/sound/cards/audiophile-usb.rst:242:   - 3 ports from {Ai,Ao,Di,Do} can be used at the same time
linux/Documentation/sound/cards/audiophile-usb.rst:252:   - Only 1 port from {Ai,Ao,Di,Do} can be used at the same time
linux/Documentation/sound/cards/mixart.rst:61:	Loopback from 'pcm0c' to 'pcm0p' with digital volume
linux/Documentation/sound/kernel-api/writing-an-alsa-driver.rst:963:pointer returned from :c:func:`request_region()` in
linux/Documentation/sound/kernel-api/writing-an-alsa-driver.rst:1909:format type, sample rate, etc. here. The difference from ``hw_params``
linux/Documentation/sound/kernel-api/writing-an-alsa-driver.rst:2687:the ``DECLARE_TLV_xxx`` macros from ``<sound/tlv.h>`` to define a
linux/Documentation/sound/kernel-api/writing-an-alsa-driver.rst:2828:Here, the chip can be cast from ``ac97->private_data``.
linux/Documentation/sound/kernel-api/writing-an-alsa-driver.rst:3009:object from :c:func:`snd_mpu401_uart_new()` as the second
linux/Documentation/sphinx/cdomain.py:25:      from 'ioctl' to 'VIDIOC_LOG_STATUS'. The function is referenced by::
linux/Documentation/sphinx/kfigure.py:399:            kernellog.warn(app, "Warning msg from %s: %s"
linux/Documentation/sphinx/kfigure.py:402:        kernellog.verbose(app, "Warning msg from %s (likely harmless):\n%s"
linux/Documentation/sphinx/kfigure.py:451:    Earns everything from ``.. image::`` directive, except *remote URI* and
linux/Documentation/sphinx/kfigure.py:487:    Earns everything from ``.. figure::`` directive, except *remote URI* and
linux/Documentation/sphinx/kfigure.py:577:    # earn options from 'figure'
linux/Documentation/sphinx/kernel_include.py:20:      Including files from arbitrary locations (e.g. from ``/etc``) is a
linux/Documentation/sphinx/rstFlatTable.py:25:      can be changed from *auto span* to *auto fill*, which automatically inserts
linux/Documentation/trace/coresight/coresight.rst:384:The content of the ETB buffer can be harvested directly from /dev::
linux/Documentation/trace/rv/deterministic_automata.rst:15:  transition in the occurrence of an event from *E* in the state *X*. In the
linux/Documentation/trace/rv/deterministic_automata.rst:17:  in a state in *X* has a deterministic next state from *X*.
linux/Documentation/trace/fprobe.rst:104:        container_of() macro from @fp. The @fp must not be NULL.
linux/Documentation/trace/postprocess/trace-pagealloc-postprocess.pl:10:#   --read-procstat	If the trace lacks process info, get it from /proc
linux/Documentation/trace/postprocess/trace-vmscan-postprocess.pl:8:#   --read-procstat	If the trace lacks process info, get it from /proc
linux/Documentation/trace/tracepoint-analysis.rst:29:All possible events are visible from /sys/kernel/tracing/events. Simply
linux/Documentation/trace/tracepoint-analysis.rst:196:  - Reading information from /proc for the PID that triggered the event
linux/Documentation/dev-tools/kunit/faq.rst:100:   can be collected from ``/sys/kernel/debug/kunit/<test suite>/results``, and
linux/Documentation/dev-tools/testing-overview.rst:147:Beware, though, that static analysis tools suffer from **false positives**.
linux/Documentation/dev-tools/kgdb.rst:849:Example from ``drivers/8250.c``::
linux/Documentation/core-api/watch_queue.rst:139:    This discards the reference obtained from ``get_watch_queue()``.
linux/Documentation/core-api/dma-attributes.rst:55:the buffer sharing. The first call transfers a buffer from 'CPU' domain
linux/Documentation/core-api/cpu_hotplug.rst:123:Once the CPU is shutdown, it will be removed from */proc/interrupts*,
linux/Documentation/core-api/printk-formats.rst:601:functions from <trace/events/mmflags.h>.
linux/Documentation/bpf/graph_ds_impl.rst:98:From the verifier's perspective, the pointer ``n`` returned from ``bpf_obj_new``
linux/Documentation/bpf/prog_cgroup_sysctl.rst:55:If program returns ``0`` user space will get ``-1`` from ``read(2)`` or
linux/Documentation/bpf/prog_cgroup_sysctl.rst:112:to read from / write to it and two such processes may run in different
linux/Documentation/bpf/libbpf/libbpf_naming_convention.rst:94:starting from ``0.0.1``.
linux/Documentation/bpf/bpf_iterators.rst:166:can process the data from ``bpf_seq_write()`` as needed. For the formatted data,
linux/Documentation/bpf/bpf_iterators.rst:320:``linfo.task.tid`` is different from ``linfo.task.pid`` only if the thread has a
linux/Documentation/bpf/verifier.rst:530:from (3) to checkpoint #0.
linux/Documentation/bpf/verifier.rst:541:called from ``states_equal()`` when a state cache entry is considered for
linux/Documentation/bpf/drgn.rst:9:Instead it's reading directly from ``/proc/kcore`` or vmcore and pretty prints
linux/Documentation/hwmon/dell-smm-hwmon.rst:147:The fields read from ``/proc/i8k`` are::
linux/Documentation/hwmon/k8temp.rst:44:temperature is updated once a second. Valid temperatures are from -49 to
linux/Documentation/hwmon/lm73.rst:86:where 'x' is the output from 'update_interval' and 'g(x)' is the
linux/Documentation/hwmon/lan966x.rst:24:of the sensor is specified from -40 to +125 degrees Celsius and
linux/Documentation/hwmon/lan966x.rst:27:frequency ranging from ~20Hz to ~650kHz.
linux/Documentation/hwmon/ds1621.rst:128:- DS1721: +/- 1.0 degree Celsius (from -10 to +85 degrees)
linux/Documentation/hwmon/ds1621.rst:129:- DS1731: +/- 1.0 degree Celsius (from -10 to +85 degrees)
linux/Documentation/hwmon/ds1621.rst:215: - 'x' = the output from 'update_interval'
linux/Documentation/hwmon/tmp108.rst:27:degree from -40 to +125 C. Resolution of the sensor is 0.0625 degree. The
linux/Documentation/hwmon/w83793.rst:53:    Temp1-4 have 2 possible types. It can be read from (and written to)
linux/Documentation/hwmon/max31760.rst:37:Temperature measurement range: from -55°C to 125°C
linux/Documentation/hwmon/w83792d.rst:72:Alarms are provided as output from "realtime status register". Following bits
linux/Documentation/hwmon/pmbus-core.rst:227:Read word data from <page>, <phase>, <reg>. Similar to
linux/Documentation/hwmon/pmbus-core.rst:244:Read byte data from <page>, <reg>. Similar to i2c_smbus_read_byte_data(), but
linux/Documentation/hwmon/tmp102.rst:24:degree from -40 to +125 C. Resolution of the sensor is 0.0625 degree.  The
linux/Documentation/translations/it_IT/process/email-clients.rst:252:  set from = "username@gmail.com"
linux/Documentation/translations/it_IT/process/maintainer-pgp-guide.rst:733:    # gpg: Good signature from [...]
linux/Documentation/translations/sp_SP/process/email-clients.rst:260:  set from = "username@gmail.com"
linux/Documentation/translations/zh_CN/process/email-clients.rst:221:  set from = "username@gmail.com"
linux/Documentation/translations/ja_JP/SubmittingPatches:476:  - パッチの作成者を明記する「 from 」行
linux/Documentation/translations/ja_JP/SubmittingPatches:537:「 from 」行は電子メールのボディの一番最初の行でなければなりません。
linux/Documentation/translations/ja_JP/SubmittingPatches:542:「 from 」行はチェンジログの中で、そのパッチの作成者としてクレジットされ
linux/Documentation/translations/ja_JP/SubmittingPatches:543:ている人を特定するものです。「 from 」行がかけていると、電子メールのヘッ
linux/Documentation/translations/ko_KR/memory-barriers.txt:870:	WRITE_ONCE(c, 1);  /* BUG: No ordering against the read from 'a'. */
linux/Documentation/translations/zh_TW/process/email-clients.rst:181:  set from = "username@gmail.com"
linux/Documentation/isdn/interface_capi.rst:285:(from <linux/isdn/capiutil.h>):
linux/Documentation/isdn/interface_capi.rst:305:(from <linux/isdn/capiutil.h>):
linux/Documentation/crypto/userspace-if.rst:18:be obtained from [1]. That library can be used by user space
linux/Documentation/fb/matroxfb.rst:261:xres:X       horizontal resolution, in pixels. Default is derived from `vesa`
linux/Documentation/fb/matroxfb.rst:263:yres:X       vertical resolution, in pixel lines. Default is derived from `vesa`
linux/Documentation/fb/matroxfb.rst:266:	     pixel line of picture. Default is derived from `vesa` option.
linux/Documentation/fb/matroxfb.rst:268:	     pulse. Default is derived from `vesa` option.
linux/Documentation/fb/matroxfb.rst:269:vslen:X      length of VSYNC pulse, in lines. Default is derived from `vesa`
linux/Documentation/fb/matroxfb.rst:272:	     Default is derived from `vesa` option.
linux/Documentation/fb/matroxfb.rst:274:	     pulse. Default is derived from `vesa` option.
linux/Documentation/fb/matroxfb.rst:275:hslen:X      length of HSYNC pulse, in pixels. Default is derived from `vesa`
linux/Documentation/fb/matroxfb.rst:277:pixclock:X   dotclocks, in ps (picoseconds). Default is derived from `vesa`
linux/Documentation/fb/matroxfb.rst:278:	     option and from `fh` and `fv` options.
linux/Documentation/fb/matroxfb.rst:299:	     70 for modes derived from `vesa` with yres <= 400, 60Hz for
linux/Documentation/RCU/Design/Expedited-Grace-Periods/Expedited-Grace-Periods.rst:78:which is called from ``rcu_preempt_note_context_switch()``, which
linux/Documentation/RCU/Design/Expedited-Grace-Periods/Expedited-Grace-Periods.rst:79:in turn is called from ``rcu_note_context_switch()``, which in
linux/Documentation/RCU/Design/Expedited-Grace-Periods/Expedited-Grace-Periods.rst:413:``schedule_work()`` (from ``_synchronize_rcu_expedited()`` so that a
linux/Documentation/RCU/Design/Memory-Ordering/Tree-RCU-Memory-Ordering.rst:180:| What? Where??? I don't see any ``smp_mb()`` after the return from     |
linux/Documentation/RCU/Design/Memory-Ordering/Tree-RCU-Memory-Ordering.rst:289:via ``note_gp_changes()``, either directly from ``call_rcu()`` (if the
linux/Documentation/RCU/Design/Memory-Ordering/Tree-RCU-Memory-Ordering.rst:436:| beginning of the grace period (the advancing of ``->gp_seq`` from     |
linux/Documentation/RCU/Design/Requirements/Requirements.rst:108:instance must also load a value of zero from ``y``. Similarly, any
linux/Documentation/RCU/Design/Requirements/Requirements.rst:109:instance of thread0() that loads a value of one from ``y`` must have
linux/Documentation/RCU/Design/Requirements/Requirements.rst:111:load a value of one from ``x``. Therefore, the outcome:
linux/Documentation/RCU/Design/Requirements/Requirements.rst:347:do_something_gp() uses rcu_dereference() to fetch from ``gp``:
linux/Documentation/RCU/Design/Requirements/Requirements.rst:441:| from this same pointer. It could also fetch the pointer from ``gp``   |
linux/Documentation/RCU/Design/Requirements/Requirements.rst:898:``(r4 == 1)``, then thread3()'s read from ``b`` must happen after
linux/Documentation/RCU/Design/Requirements/Requirements.rst:1484:because workloads benefiting from ``rcu_nocbs`` CPUs tend to invoke
linux/Documentation/RCU/Design/Data-Structures/Data-Structures.rst:286:distributed fashion. The values flow from ``rcu_state`` to ``rcu_node``
linux/Documentation/RCU/Design/Data-Structures/Data-Structures.rst:858:| need to carefully manage the numbers on a per-node basis. Recall from |
linux/Documentation/RCU/Design/Data-Structures/Data-Structures.rst:905:forcing of quiescent states from ``call_rcu()`` and friends when
linux/Documentation/RCU/rcu_dereference.rst:112:	On ARM and Power hardware, the load from "default_struct.a"
linux/Documentation/RCU/rcu_dereference.rst:375:compiler to make the return values independent of the load from "gp",
linux/Documentation/usb/gadget_printer.rst:234:				printf("Error %d reading from %s\n",
linux/Documentation/usb/ehci.rst:27:of EHCI from (in alphabetical order):  Intel, NEC, Philips, and VIA.
linux/Documentation/usb/mass-storage.rst:194:  read from /sys/module/g_mass_storage/parameters/* files.
linux/Documentation/arm/kernel_user_helpers.rst:17:This is different from (but doesn't preclude) a full blown VDSO
linux/Documentation/powerpc/papr_hcalls.rst:245:|  02  | PMEM device contents are persisted from previous IPL. The data from   |
linux/Documentation/powerpc/firmware-assisted-dump.rst:206:Currently the dump will be copied from /proc/vmcore to a new file upon
linux/Documentation/memory-barriers.txt:714:load from 'a' with other loads from 'a'.  Without the WRITE_ONCE(),
linux/Documentation/memory-barriers.txt:756:Now there is no conditional between the load from 'a' and the store to
linux/Documentation/memory-barriers.txt:858:	WRITE_ONCE(c, 1);  /* BUG: No ordering against the read from 'a'. */
linux/Documentation/memory-barriers.txt:875:from 'a' and the store to 'c'.  The control dependencies would extend
linux/Documentation/tools/rtla/rtla-timerlat.rst:31:        Prints the summary from *timerlat* tracer.
linux/Documentation/scsi/ChangeLog.megaraid:171:	character node name change from 'megadev' to 'megadev_legacy' to avoid
linux/Documentation/scsi/ChangeLog.ncr53c8xx:52:	- Move from `sym' to this driver a tiny change for __sparc__ that 
linux/Documentation/scsi/ChangeLog.ncr53c8xx:177:	- Declare static all symbols that do not need to be visible from 
linux/Documentation/scsi/ChangeLog.arcmsr:87:**						from "void" to "int"
linux/Documentation/scsi/ChangeLog.lpfc:1496:	* Remove duplicate rc definitions from 
linux/Documentation/scsi/st.rst:176:   directory (where <match> is a directory entry from /sys/class/scsi_tape
linux/Documentation/scsi/ChangeLog.sym53c8xx:97:	  * Simpler handling of illegal phases and data overrun from 
linux/Documentation/scsi/ChangeLog.sym53c8xx:293:	  from a device that has received a BUS DEVICE RESET message from 
linux/Documentation/block/inline-encryption.rst:30:Inline encryption hardware is also very different from "self-encrypting drives",
linux/Documentation/input/joydev/joystick.rst:103:the stick. They should have the full range from -32767 to 32767. If all this
linux/Documentation/input/userio.rst:69:set. Can be any of the macros from <linux/serio.h>. For example: SERIO_8042
linux/Documentation/input/devices/walkera0701.rst:47:be changed by TX "joystick", check output from /proc/interrupts. Value for
linux/Documentation/input/devices/appletouch.rst:29:the mouse data from /dev/input/mice (using gpm, or X11).
linux/Documentation/input/devices/appletouch.rst:35:the synaptics driver (tested with 0.14.2, available from [#f2]_), and configure
linux/Documentation/kbuild/kconfig-language.rst:319:MODULES is different from 'n'. The comment on the other hand is only
linux/Documentation/kbuild/llvm.rst:94:from ``ARCH``.
linux/Documentation/kbuild/modules.rst:166:The kbuild system will build <module_name>.o from <module_name>.c,
linux/Documentation/kbuild/makefiles.rst:1408:  A central rule exists to create ``$(obj)/%.dtb`` from ``$(src)/%.dts``;
linux/Documentation/scheduler/sched-design-CFS.rst:99:which can be used to tune the scheduler from "desktop" (i.e., low latencies) to
linux/Documentation/scheduler/sched-rt-group.rst:101:  * sched_rt_runtime_us takes values from -1 to (INT_MAX - 1).
linux/Documentation/scheduler/sched-rt-group.rst:115:period from /proc/sys/kernel/sched_rt_period_us and a run time of 0. If you
linux/Documentation/scheduler/sched-nice-design.rst:91:enough), the scheduler was decoupled from 'time slice' and HZ concepts
linux/Documentation/gpu/todo.rst:141:  internal use. Some of these hooks should be move from ``_funcs`` to
linux/Documentation/gpu/drm-uapi.rst:310:        Some drivers use this to differentiate "out of kernel memory" from "out
linux/Documentation/hid/hid-bpf.rst:440:close the returned fd from :c:func:`attach_filter`, which will tell the kernel to
linux/Documentation/i2c/slave-testunit-backend.rst:51:   DATAL - address to read data from (lower 7 bits, highest bit currently unused)
linux/Documentation/s390/3270.rst:206:down.  When it fills, the status area changes from "Linux Running" to
linux/Documentation/s390/zfcpdump.rst:42:reads from /proc/vmcore or zcore/mem and writes the system dump to a SCSI disk.
linux/Documentation/filesystems/spufs/spu_create.rst:103:       abstract interface to SPUs, not to be used from  regular  applications.
linux/Documentation/filesystems/spufs/spufs.rst:46:       supported  operations  and  the  deviations  from  the behaviour in the
linux/Documentation/filesystems/spufs/spufs.rst:129:       reads  from  its PPE mailbox channel.  When data has been read success-
linux/Documentation/filesystems/spufs/spufs.rst:140:       many  words  can  be  read  from  mbox or ibox or how many words can be
linux/Documentation/filesystems/spufs/spufs.rst:149:              read  from  (for  mbox_stat  and  ibox_stat)  or written to (for
linux/Documentation/filesystems/spufs/spufs.rst:254:              the value given in the string. The string  is  parsed  from  the
linux/Documentation/filesystems/spufs/spu_run.rst:115:       spu_run  is  meant  to  be  used  from  libraries that implement a more
linux/Documentation/filesystems/spufs/spu_run.rst:116:       abstract interface to SPUs, not to be used from  regular  applications.
linux/Documentation/filesystems/path-lookup.txt:166:lookup operations. If a file is renamed from 'A' to 'B', a lookup must only
linux/Documentation/filesystems/proc.rst:491:calculated by subtracting "Pss_Dirty" from "Pss".)
linux/Documentation/filesystems/proc.rst:1495:  So, the iowait is not reliable by reading from /proc/stat.
linux/Documentation/filesystems/proc.rst:1659:is used to determine which task to kill.  Acceptable values range from -1000
linux/Documentation/filesystems/proc.rst:1675:be used to tune the badness score.  Its acceptable values range from -16
linux/Documentation/filesystems/porting.rst:251:	* we are called from ->rename().
linux/Documentation/filesystems/porting.rst:316:block truncatation on error exit from ->write_begin, and ->direct_IO
linux/Documentation/filesystems/porting.rst:545:from ->follow_link for normal symlinks, or nd_jump_link for magic
linux/Documentation/filesystems/ext4/directory.rst:233:for the htree will appear to have no entries (aside from '.' and '..')
linux/Documentation/filesystems/ext4/ifork.rst:117:     - This index node covers file blocks from 'block' onward.
linux/Documentation/filesystems/sharedsubtree.rst:531:	propagation from 'B'.  And since the mount 'A' is unbindable, cloning
linux/Documentation/filesystems/nfs/rpc-server-gss.rst:92:from /proc/net/rpc/use-gss-proxy and checking that it contains a
linux/Documentation/filesystems/nfs/rpc-cache.rst:77:      Set the 'key' fields in 'new' from 'orig'.  This may
linux/Documentation/filesystems/nfs/rpc-cache.rst:81:      Set the 'content' fileds in 'new' from 'orig'.
linux/Documentation/filesystems/f2fs.rst:454:  -s [SIT dump segno from #1~#2 (decimal), for all 0~-1]
linux/Documentation/filesystems/f2fs.rst:455:  -a [SSA dump segno from #1~#2 (decimal), for all 0~-1]
linux/Documentation/filesystems/idmappings.rst:37:idmapping is an order isomorphism from ``U`` into ``K``. So ``U`` and ``K`` are
linux/Documentation/filesystems/idmappings.rst:682:All helpers that map to or from ``vfsuid_t`` and ``vfsgid_t`` types require
linux/Documentation/filesystems/idmappings.rst:783:preserving algorithm. A file created from ``u1000`` on an idmapped mount will
linux/Documentation/filesystems/ramfs-rootfs-initramfs.rst:203:    echo "creating $2 from $1"
linux/Documentation/filesystems/xfs-online-fsck-design.rst:2807:3. Use the bitmap disunion operator to subtract (1) from (2).
linux/Documentation/filesystems/xfs-online-fsck-design.rst:3193:<https://archive.org/details/bstj57-6-1905/page/n8/mode/1up>`_, from *The UNIX
linux/Documentation/filesystems/fscrypt.rst:493:  be set to constants from ``<linux/fscrypt.h>`` which identify the
linux/Documentation/filesystems/fscrypt.rst:498:- ``flags`` contains optional flags from ``<linux/fscrypt.h>``:
linux/Documentation/filesystems/ceph.rst:120:	FSID of the cluster (from `ceph fsid` command).
linux/Documentation/filesystems/fuse.rst:331: |      [get request from             |
linux/Documentation/filesystems/path-lookup.rst:840:It is also called from ``complete_walk()`` when the lookup has reached
linux/Documentation/filesystems/path-lookup.rst:1323:This is distinctly different from ``LOOKUP_FOLLOW``, because the latter only
linux/Documentation/filesystems/path-lookup.rst:1327:ensure that they return errors from ``nd_jump_link()``, because that is how
linux/Documentation/filesystems/caching/netfs-api.rst:233:be called from ``->setattr()`` inode operation under the inode lock.
linux/Documentation/filesystems/locking.rst:663:Filesystem should find and map pages associated with offsets from "start_pgoff"
linux/Documentation/userspace-api/vduse.rst:30:3. Begin processing VDUSE messages from /dev/vduse/$NAME. The first
linux/Documentation/userspace-api/media/rc/lirc-dev-intro.rst:82:    With nec, there is no way to distinguish "button hold" from "repeatedly
linux/Documentation/userspace-api/media/v4l/pixfmt-tch-td08.rst:18:Delta values may range from -128 to 127. Typically the values will vary through
linux/Documentation/userspace-api/media/v4l/colorspaces-defs.rst:169:	0x00 and 0xff values). Cb and Cr are mapped from [-0.5…0.5] to
linux/Documentation/userspace-api/media/v4l/colorspaces-defs.rst:174:	is mapped to [16…235]. Cb and Cr are mapped from [-0.5…0.5] to
linux/Documentation/userspace-api/media/v4l/dev-decoder.rst:121:   from ``OUTPUT`` buffers.
linux/Documentation/userspace-api/media/v4l/vidioc-queryctrl.rst:48:with successive ``id`` values starting from ``V4L2_CID_BASE`` up to and
linux/Documentation/userspace-api/media/v4l/vidioc-enum-fmt.rst:66:   (for video output devices) or be produced from (for video capture
linux/Documentation/userspace-api/media/v4l/pixfmt-tch-td16.rst:19:Delta values may range from -32768 to 32767. Typically the values will vary
linux/Documentation/userspace-api/media/v4l/dev-sliced-vbi.rst:319:      - A flag from :ref:`vbi-services` identifying the type of data in
linux/Documentation/userspace-api/media/v4l/dev-sliced-vbi.rst:476:      - A "magic" constant from :ref:`v4l2-mpeg-vbi-fmt-ivtv-magic` that
linux/Documentation/userspace-api/media/cec/cec-ioc-receive.rst:79:However, the CEC specification allows sending messages from 'Unregistered' to
linux/Documentation/userspace-api/ioctl/cdrom.rst:894:	  from <linux/cdrom.h>:
linux/Documentation/userspace-api/ioctl/cdrom.rst:929:	  from <linux/cdrom.h>:
linux/Documentation/userspace-api/ioctl/hdio.rst:137:		This information is also available from /proc/ide/hdX/identify
linux/Documentation/userspace-api/netlink/intro-specs.rst:24: - ``--subscribe $group`` - receive notifications from ``$group``
linux/Documentation/userspace-api/netlink/intro-specs.rst:51:code from ``cli.py``.
linux/Documentation/userspace-api/netlink/c-code-gen.rst:106:uAPI header is assumed to come from ``<linux/$family.h>`` in the default header
linux/Documentation/userspace-api/netlink/specs.rst:207:entry (unlike enums in definitions which start from ``0``) because
linux/Documentation/iio/iio_configfs.rst:100:"hrtimer" trigger type doesn't have any configurable attribute from /config dir.
linux/Documentation/power/basic-pm-debugging.rst:105:should try the test modes starting from "freezer", through "devices", "platform"
linux/Documentation/power/runtime_pm.rst:106:  * If the suspend callback returns an error code different from -EBUSY and
linux/Documentation/power/runtime_pm.rst:491:      PM attributes from /sys/devices/.../power (or prevent them from being
linux/Documentation/power/runtime_pm.rst:605:update the last busy mark before returning from ->probe().
linux/Documentation/power/userland-swsusp.rst:22:be read from /sys/class/misc/snapshot/dev.
linux/Documentation/doc-guide/sphinx.rst:337:  changed from *auto span* to *auto fill*, which automatically inserts (empty)
linux/Documentation/mm/transhuge.rst:121:    goes from -1 to 0 or 0 to -1.
linux/Documentation/mm/transhuge.rst:125:    when page->_mapcount goes from -1 to 0 or 0 to -1 as this counts
linux/Documentation/mm/memory-model.rst:116:offset of the `struct page` from `vmemmap` is the PFN of that
linux/Documentation/staging/lzo.rst:139:           0 0 0 0 D D S S  (0..15)  : copy 2 bytes from <= 1kB distance
linux/Documentation/devicetree/of_unittest.rst:45:from 'scripts/dtc/of_unittest_expect --help'.
linux/Documentation/devicetree/bindings/dma/xilinx/xilinx_dma.txt:115:	from '16' and is in [16-31] range. These channels ID are
linux/Documentation/devicetree/bindings/mfd/ti,tps65086.yaml:29:      encoded as trigger masks from ../interrupt-controller/interrupts.txt.
linux/Documentation/devicetree/bindings/mfd/altera-a10sr.txt:13:			    masks from ../interrupt-controller/interrupts.txt.
linux/Documentation/devicetree/bindings/mfd/tps65912.txt:11:			    masks from ../interrupt-controller/interrupts.txt.
linux/Documentation/devicetree/bindings/pinctrl/cnxt,cx92755-pinctrl.txt:60:  is an uppercase character from 'A' to 'R', and y is a digit from 0 to 7.
linux/Documentation/devicetree/bindings/regulator/richtek,rt5190a-regulator.yaml:47:      'muteout'. But if the power source removal is detected from 'vdet',
linux/Documentation/devicetree/bindings/serio/ps2-gpio.yaml:20:      from <dt-bindings/gpio/gpio.h> since the signal is open drain by
linux/Documentation/devicetree/bindings/serio/ps2-gpio.yaml:28:      from <dt-bindings/gpio/gpio.h> since the signal is open drain by
linux/Documentation/devicetree/bindings/interrupt-controller/open-pic.txt:10:  NOTE: Many of these descriptions were paraphrased here from [1] to aid
linux/Documentation/devicetree/bindings/input/matrix-keymap.yaml:20:  word for the modifier other from "Fn".
linux/Documentation/devicetree/bindings/i2c/i2c-gpio.yaml:24:      from <dt-bindings/gpio/gpio.h> since the signal is by definition
linux/Documentation/devicetree/bindings/i2c/i2c-gpio.yaml:32:      from <dt-bindings/gpio/gpio.h> since the signal is by definition
linux/Documentation/devicetree/bindings/pci/layerscape-pci.txt:44:  The second entry is the physical PCIe controller index starting from '0'.
linux/Documentation/devicetree/bindings/iio/addac/adi,ad74115.yaml:175:      When present, the threshold range is fixed from -19V to 30V.
linux/Documentation/devicetree/bindings/memory-controllers/ddr/jedec,lpddr-channel.yaml:29:      from (a multiple of) the io-width of the LPDDR chip, that means that
linux/Documentation/devicetree/bindings/net/micrel-ksz90x1.txt:17:  skew values actually increase in 120ps steps, starting from -840ps. The
linux/Documentation/devicetree/bindings/net/sti-dwmac.txt:24:   posssible values from "txclk", "clk_125" or "clkgen".
linux/Documentation/devicetree/bindings/display/bridge/ti,tfp410.yaml:28:      (DK[3:1] - 4), so it ranges from -4 to 3.
linux/Documentation/pcmcia/driver-changes.rst:52:   - calling request_irq/free_irq directly. Use the IRQ from `*p_dev->irq`.
linux/Documentation/driver-api/soundwire/stream.rst:436:stream can transition from ``SDW_STREAM_DISABLED`` to
linux/Documentation/driver-api/libata.rst:43:Called from :c:func:`ata_bus_probe` error path, as well as when unregistering
linux/Documentation/driver-api/libata.rst:48:Called from :c:func:`ata_bus_probe` on a failed probe. Called from
linux/Documentation/driver-api/nvdimm/firmware-activate.rst:64:from 'armed' to 'idle' when the system is prepared to activate firmware,
linux/Documentation/driver-api/tty/tty_driver.rst:75:calling operations from :c:member:`tty_driver.ops`, see `TTY Operations
linux/Documentation/driver-api/eisa.rst:158:You can get the 'struct eisa_device' from 'struct device' using the
linux/Documentation/driver-api/uio-howto.rst:84:Interrupts are handled by reading from ``/dev/uioX``. A blocking
linux/Documentation/driver-api/uio-howto.rst:85::c:func:`read()` from ``/dev/uioX`` will return as soon as an
linux/Documentation/driver-api/pin-control.rst:779:pin, you can also drive it high/low from "GPIO" registers.
linux/Documentation/driver-api/pm/devices.rst:184:It ought to be noted that system wakeup is conceptually different from "remote
linux/Documentation/driver-api/pm/devices.rst:635:The main difference from ``resume[_early|_noirq]`` is that
linux/Documentation/driver-api/pm/devices.rst:854:devices to be changed from "suspended" to "active" by the PM core during
linux/Documentation/driver-api/pm/notifiers.rst:31:	is different from ``PM_SUSPEND_PREPARE`` below,	because in this case
linux/Documentation/driver-api/usb/writing_musb_glue_layer.rst:677:operation between the value read from ``MUSB_INTRUSB`` and the bits that
linux/Documentation/driver-api/usb/dwc3.rst:119:	1. You're running latest tag from `Linus' tree`_
linux/Documentation/driver-api/usb/usb.rst:366:The standard USB device model requests, from "Chapter 9" of the USB 2.0
linux/Documentation/driver-api/usb/usb.rst:565:    value (from ``linux/usb.h``). If wLength is nonzero, it describes
linux/Documentation/driver-api/usb/power-management.rst:661:Distinct from 'companion ports', or 'ehci/xhci shared switchover ports'
linux/Documentation/driver-api/media/v4l2-dev.rst:305:from ``/dev``).
linux/Documentation/driver-api/media/v4l2-fh.rst:95:- Unassociate the file handle from :c:type:`video_device`. The file handle
linux/Documentation/driver-api/media/drivers/sh_mobile_ceu_camera.rst:81:3. Calculate new combined scales from "effective" input window to requested user
linux/Documentation/driver-api/spi.rst:31:manufactured from :c:type:`struct spi_board_info
linux/Documentation/driver-api/thermal/sysfs-api.rst:105:    It deletes the corresponding entry from /sys/class/thermal folder and
linux/Documentation/driver-api/thermal/sysfs-api.rst:251:    It deletes the corresponding entry from /sys/class/thermal folder and
linux/Documentation/driver-api/parport-lowlevel.rst:650:A positive return value from ``parport_yield_blocking`` indicates that
linux/Documentation/driver-api/device_link.rst:233:from :c:func:`device_link_add()`.)
linux/Documentation/driver-api/device_link.rst:238:(Call to :c:func:`device_is_dependent()` from :c:func:`device_link_add()`.)
linux/Documentation/driver-api/device_link.rst:290:  (Call to :c:func:`device_links_no_driver()` from :c:func:`really_probe()`.)
linux/Documentation/driver-api/device_link.rst:293:  (Call to :c:func:`device_links_driver_bound()` from :c:func:`driver_bound()`.)
linux/Documentation/driver-api/mtdnand.rst:395:   This function is called after read / write from / to the chip.
linux/Documentation/driver-api/surface_aggregator/ssh.rst:291:originates from (``SID``) and what the intended target of the message is
linux/Documentation/admin-guide/bcache.rst:296:   This causes the backing bcache to be removed from /sys/fs/bcache and
linux/Documentation/admin-guide/parport.rst:37:PCI parallel I/O card support comes from ``parport_pc``.  Base I/O
linux/Documentation/admin-guide/dynamic-debug-howto.rst:278:This allows boot args to override or modify those from ``/etc/modprobe.d``
linux/Documentation/admin-guide/spkguide.txt:358:to directly access speakup parameters from /speakup.
linux/Documentation/admin-guide/LSM/Smack.rst:604:The Smack label of a process can be read from /proc/<pid>/attr/current. A
linux/Documentation/admin-guide/LSM/Smack.rst:605:process can read its own Smack label from /proc/self/attr/current. A
linux/Documentation/admin-guide/LSM/Smack.rst:680:value can be read from /sys/fs/smackfs/direct and changed by writing to
linux/Documentation/admin-guide/kernel-parameters.txt:799:			from /proc/kmsg.
linux/Documentation/admin-guide/kernel-parameters.txt:3144:			from <oldtype> to <newtype>. If "-<oldtype>" is left
linux/Documentation/admin-guide/kernel-parameters.txt:5951:			result in reduced throughput from /dev/urandom.
linux/Documentation/admin-guide/initrd.rst:66:    from /dev/initrd. Note that the data in initrd can have any structure
linux/Documentation/admin-guide/initrd.rst:174:only add a symbolic link from ``/sbin/init`` to ``/bin/sh``. Alternatively, you
linux/Documentation/admin-guide/iostats.rst:205:In 2.6+, all disk statistics were removed from ``/proc/stat``.  In 2.4, they
linux/Documentation/admin-guide/pm/intel-speed-select.rst:307:changed from "disabled" to "unsupported" compared to performance level 0.
linux/Documentation/admin-guide/sysctl/fs.rst:197:from "pinning" vulnerable setuid/setgid files against being upgraded by
linux/Documentation/admin-guide/sysctl/net.rst:247:log from  the  networking  code.  They  enforce  a  rate  limit  to  make  a
linux/Documentation/admin-guide/media/rcar-fdp1.rst:19:        deinterlacing is performed. Apart from (optional) format and encoding
linux/Documentation/admin-guide/media/fimc.rst:142:or retrieve the information from /dev/media? with help of the media-ctl tool:
linux/Documentation/admin-guide/media/ivtv.rst:209:  read the embedded VBI data from /dev/vbi8.
linux/Documentation/admin-guide/media/avermedia.rst:48:from  the  card  (i.e.  viewing the additional analogue inputs
linux/Documentation/admin-guide/device-mapper/cache-policies.rst:54:Users may switch from "mq" to "smq" simply by appropriately reloading a
linux/Documentation/admin-guide/device-mapper/dm-dust.rst:265:operations.  Log messages from "countbadblocks" or "queryblock"
linux/Documentation/admin-guide/device-mapper/snapshot.rst:40:from <origin> for unchanged data.  <COW device> will often be
linux/Documentation/admin-guide/device-mapper/statistics.rst:108:	  region_id returned from @stats_create
linux/Documentation/admin-guide/device-mapper/statistics.rst:114:	  region_id returned from @stats_create
linux/Documentation/admin-guide/device-mapper/statistics.rst:136:	  region_id returned from @stats_create
linux/Documentation/admin-guide/device-mapper/statistics.rst:180:	  region_id returned from @stats_create
linux/Documentation/admin-guide/device-mapper/statistics.rst:194:	  region_id returned from @stats_create
linux/Documentation/admin-guide/svga.rst:75:from "0" to "9" and from "a" to "z") is a 80x25 mode with ID=0x0f00 (see the
linux/Documentation/admin-guide/hw-vuln/core-scheduling.rst:58:    - ``PR_SCHED_CORE_SHARE_FROM`` -- pull core_sched cookie from ``pid``.
linux/Documentation/admin-guide/laptops/disk-shock-protection.rst:58:reading from `/sys/block/*/device/unload_heads` will report the number
linux/Documentation/admin-guide/mm/damon/usage.rst:431:starting from ``0`` under this directory.  Each directory contains files
linux/Documentation/admin-guide/mm/damon/usage.rst:578:starting from ``0``, and the regions should be passed in address order.  For
linux/Documentation/admin-guide/mm/swap_numa.rst:71:or the system will pick one starting from -1 then downwards. The priority
linux/Documentation/admin-guide/mm/swap_numa.rst:74:the semantics for priority >=0 cases, the previous starting from -1 then
linux/Documentation/admin-guide/mm/swap_numa.rst:75:downwards now becomes starting from -2 then downwards and -1 is reserved
linux/Documentation/admin-guide/mm/concepts.rst:37:writes) from (or to) the system memory, it translates the `virtual`
linux/Documentation/admin-guide/mm/pagemap.rst:53:   The flags are (from ``fs/proc/page.c``, above kpageflags_read):
linux/Documentation/admin-guide/reporting-issues.rst:148:   (.config) and the output from ``dmesg`` available somewhere on the net and
linux/Documentation/admin-guide/reporting-issues.rst:150:   like the output/screenshot of an Oops or the output from ``lspci``. Once
linux/Documentation/admin-guide/reporting-issues.rst:887:downloading the sources as tarball from `kernel.org <https://kernel.org/>`_.
linux/Documentation/admin-guide/reporting-issues.rst:1075:    (.config) and the output from ``dmesg`` available somewhere on the net and
linux/Documentation/admin-guide/reporting-issues.rst:1077:    like the output/screenshot of an Oops or the output from ``lspci``. Once
linux/Documentation/admin-guide/reporting-issues.rst:1113: * the output from ``cat /proc/version``, which contains the Linux kernel
linux/Documentation/admin-guide/reporting-issues.rst:1129: * the kernel's messages that you get from ``dmesg`` written to a file. Make
linux/Documentation/admin-guide/reporting-issues.rst:1184:   output from ``lspci -nn`` will for example help others to identify what
linux/Documentation/admin-guide/reporting-issues.rst:1186:   make the output from ``sudo lspci -vvv`` available, as that provides
linux/Documentation/admin-guide/cgroup-v2.rst:1258:	type of memory to reclaim from (anon, file, ..).
linux/Documentation/admin-guide/cgroup-v2.rst:2809:extract the path on the target hierarchy from /proc/self/cgroup,
linux/Documentation/cdrom/cdrom-standard.rst:299:the information from *media_changed()* to two separate queues. Other
linux/Documentation/cdrom/cdrom-standard.rst:988:- Change the 3rd argument of *register_blkdev* from `&<your-drive>_fops`
linux/Documentation/cdrom/cdrom-standard.rst:997:  source, e. g., from `cm206.c` *cm206_dops*, and change all
linux/Documentation/arch/x86/x86_64/machinecheck.rst:19:from /dev/mcelog. Normally mcelog should be run regularly from a cronjob.
linux/Documentation/arch/x86/cpuinfo.rst:106:The feature shall be omitted from /proc/cpuinfo if it does not make sense for
linux/Documentation/arch/x86/cpuinfo.rst:139:from #define X86_FEATURE_UMIP (16*32 + 2).
linux/Documentation/arch/m68k/buddha-driver.rst:34:the  whole card disappears from $e8 and is mapped to the new
linux/Documentation/arch/m68k/kernel-options.rst:106:consequences: If, for example, you have a symbolic link from /dev/fd
linux/Documentation/arch/m68k/kernel-options.rst:330:    Please notice that this option was renamed from `atavideo` to
linux/Documentation/arch/m68k/kernel-options.rst:475:video memory. If it's missing, the size is calculated from <xres>,
linux/Documentation/arch/ia64/aliasing.rst:175:mmap of various MMIO regions from /dev/mem by "X" on Intel platforms
linux/Documentation/spi/spi-summary.rst:230:	 * run on multiple boards, pdata wouldn't benefit from "__init".
linux/security/apparmor/policy_ns.c:33: * aa_ns_visible - test if @view is visible from @curr
linux/security/apparmor/policy_ns.c:35: * @view: namespace to test if visible from @curr (NOT NULL)
linux/security/apparmor/policy_ns.c:38: * Returns: true if @view is visible from @curr else false
linux/security/apparmor/policy_ns.c:57: * aa_ns_name - Find the ns name to display for @view from @curr
linux/security/apparmor/policy_ns.c:62: * Returns: name of @view visible from @curr
linux/security/apparmor/include/cred.h:41: * @cred: cred to obtain label from  (NOT NULL)
linux/security/apparmor/include/cred.h:57: * @cred: cred to obtain label from (NOT NULL)
linux/security/apparmor/audit.c:90: * Record common AppArmor audit data from @sa
linux/security/apparmor/lib.c:86: * skipn_spaces - Removes leading whitespace from @str.
linux/security/apparmor/label.c:1435: * @ns: ns being viewed from (NOT NULL)
linux/security/apparmor/policy.c:56: *       from /bin/bash
linux/security/apparmor/policy.c:480: * @base: base list to start looking up profile name from  (NOT NULL)
linux/security/apparmor/policy.c:521: * @ns: the namespace to start from (NOT NULL)
linux/security/apparmor/policy.c:888: * Will duplicate and refcount elements that @new inherits from @old
linux/security/apparmor/capability.c:42: * @va - audit struct to audit data from  (NOT NULL)
linux/security/apparmor/apparmorfs.c:379: * @userbuf: user buffer to copy data from  (NOT NULL)
linux/security/apparmor/apparmorfs.c:2075: * Find the next namespace from @ns under @root and handle all locking needed
linux/security/tomoyo/realpath.c:161:	/* Convert from $PID to self if $PID is current thread. */
linux/security/tomoyo/file.c:12: * Mapping table from "enum tomoyo_path_acl_index" to "enum tomoyo_mac_index".
linux/security/tomoyo/file.c:29: * Mapping table from "enum tomoyo_mkdev_acl_index" to "enum tomoyo_mac_index".
linux/security/tomoyo/file.c:37: * Mapping table from "enum tomoyo_path2_acl_index" to "enum tomoyo_mac_index".
linux/security/tomoyo/file.c:46: * Mapping table from "enum tomoyo_path_number_acl_index" to
linux/security/tomoyo/common.c:629:				 * 'config' from 'TOMOYO_CONFIG_USE_DEFAULT'.
linux/security/tomoyo/common.c:1871:				tomoyo_set_string(head, " from ");
linux/security/tomoyo/common.c:2775:			pr_info_once("Converting profile version from %u to %u.\n",
linux/security/tomoyo/network.c:135: * Mapping table from "enum tomoyo_network_acl_index" to
linux/security/tomoyo/network.c:158: * Mapping table from "enum tomoyo_network_acl_index" to
linux/security/tomoyo/common.h:779:/* Structure for holding a line from /sys/kernel/security/tomoyo/ interface. */
linux/security/tomoyo/condition.c:526:		 * where "$left is free from '=' and ' '" and "$operator is
linux/security/tomoyo/condition.c:527:		 * either '=' or '!='" and "$right is free from ' '".
linux/security/tomoyo/util.c:20: * Mapping table from "enum tomoyo_mac_index" to
linux/security/tomoyo/util.c:108: * @keyword: Keyword to find from @string/
linux/security/tomoyo/domain.c:248:	char *domainname = strstr(program, " from ");
linux/security/keys/keyring.c:1574: * whilst simultaneously removing a link to the key from @from_keyring.
linux/security/keys/keyctl.c:1174:	size_t plen = from ? iov_iter_count(from) : 0;
linux/security/keys/keyctl.c:1181:		from = NULL;
linux/security/keys/trusted-keys/trusted_tpm1.c:816:			if (*args[0].from == '0')
linux/security/keys/trusted-keys/trusted_tpm1.c:818:			else if (*args[0].from != '1')
linux/security/keys/encrypted-keys/encrypted.c:236:				"when called from .update method\n", keyword);
linux/security/keys/encrypted-keys/encrypted.c:245:				"when called from .update method\n", keyword);
linux/security/keys/encrypted-keys/encrypted.c:258:				"when called from .instantiate method\n",
linux/security/selinux/netlabel.c:422: * Fetch the NetLabel security attributes from @skb and perform an access check
linux/security/selinux/hooks.c:2527:	char *from = options;
linux/security/selinux/hooks.c:2544:				for (p = q = arg; p < from + len; p++) {
linux/security/selinux/hooks.c:2573:		from += len + 1;
linux/security/selinux/hooks.c:4441: * If @skb_sid is valid then the user:role:type information from @sk_sid is
linux/security/selinux/hooks.c:4442: * combined with the MLS information from @skb_sid in order to create
linux/security/landlock/object.h:52:	 * from @underobj to this object have been cleaned up.
linux/security/landlock/fs.c:706: * file.  While walking from @dir to @mnt_root, we record all the domain's
linux/security/landlock/fs.c:810: * - -EXDEV if @old_dentry would inherit new access rights from @new_dir;
linux/security/integrity/ima/ima_policy.c:1543:			from = args[0].from;
linux/security/integrity/ima/ima_policy.c:1544:			if (*from == '^')
linux/security/integrity/ima/ima_policy.c:1558:				entry->flags |= (*args[0].from == '^')
linux/security/safesetid/lsm.c:31:/* Compute a decision for a transition from @src to @dst under @policy. */
linux/security/safesetid/lsm.c:63: * Compute a decision for a transition from @src to @dst under the active
linux/security/security.c:4049: * Check permissions before connecting or sending datagrams from @sock to
linux/security/security.c:4425: * LSM state from @parent.
linux/security/security.c:4455: * Set that LSM state of @sock using the LSM state from @req.
linux/security/security.c:4468: * Update @sock's LSM state to represent a new connection from @skb.
linux/security/smack/smackfs.c:778:	 * anything read from /smack/cipso ought to be writeable
linux/security/smack/smack_lsm.c:682:	char *from = options, *to = options;
linux/security/smack/smack_lsm.c:697:			arg = kmemdup_nul(arg, from + len - arg, GFP_KERNEL);
linux/security/smack/smack_lsm.c:718:		from += len + 1;
linux/security/lockdown/lockdown.c:32:	pr_notice("Kernel is locked down from %s; see man kernel_lockdown.7\n",
linux/sound/oss/dmasound/dmasound.h:69:#define MIN_BUFSIZE	(1<<12)	/* in bytes (- where does this come from ?) */
linux/sound/usb/mixer_scarlett_gen2.c:153:/* mixer range from -80dB to +6dB in 0.5dB steps */
linux/sound/usb/mixer_scarlett_gen2.c:161:/* map from (dB + 80) * 2 to mixer value
linux/sound/usb/mixer_scarlett_gen2.c:3218:			int from = i * info->inputs_per_phantom + 1;
linux/sound/usb/mixer_quirks.c:2519: * Volume control is linear, from -inf (dec. 0) to +6dB (dec. 65536) with
linux/sound/ppc/beep.c:43: * Stuff for outputting a beep.  The values range from -327 to +327
linux/sound/hda/intel-sdw-acpi.c:170:	 * the ACPI from 'HDAS' at max depth of 2 to find the 'SNDW'
linux/sound/core/device.c:116:		dev_dbg(card->dev, "device disconnect %p (from %pS), not found\n",
linux/sound/core/device.c:140:		dev_dbg(card->dev, "device free %p (from %pS), not found\n",
linux/sound/core/oss/mulaw.c:58: * is biased by adding 33 which shifts the encoding range from (0 - 8158) to
linux/sound/core/oss/pcm_oss.c:1244:				"pcm_oss: write: recovering from %s\n",
linux/sound/core/oss/pcm_oss.c:1276:				"pcm_oss: read: recovering from %s\n",
linux/sound/core/oss/pcm_oss.c:1319:				"pcm_oss: writev: recovering from %s\n",
linux/sound/core/oss/pcm_oss.c:1348:				"pcm_oss: readv: recovering from %s\n",
linux/sound/core/pcm_lib.c:1642: * Inside configuration space defined by @params remove from @var all
linux/sound/core/pcm_lib.c:1688: * Inside configuration space defined by @params remove from @var all
linux/sound/i2c/other/ak4xxx-adda.c:123: * from -63.5dB (mute) to 0dB step 0.5dB
linux/sound/isa/opti9xx/miro.c:588:   from -12dB up to +12dB on each band */
linux/sound/isa/wavefront/wavefront_synth.c:1508:	/* Now copy it back to where it came from */
linux/sound/isa/sb/sb8_midi.c:9: *   Fixed typo in snd_sb8dsp_midi_new_device which prevented midi from 
linux/sound/pci/asihpi/hpioctl.c:219:						"buffer from %zd to %d\n",
linux/sound/pci/hda/hda_generic.c:5649:/* copy PCM stream info from @default_str, and override non-NULL entries
linux/sound/pci/hda/hda_generic.c:5650: * from @spec_str and @nid
linux/sound/pci/vx222/vx222_ops.c:810:/* Micro level is specified to be adjustable from -96dB to 63 dB (board coded 0x00 ... 318),
linux/sound/pci/rme9652/hdsp.c:3422:				snd_iprintf(buffer, "Firmware loading from "
linux/sound/pci/rme9652/hdspm.c:1735:			"cannot change from %s speed to %s speed mode (capture PID = %d, playback PID = %d)\n",
linux/sound/pci/au88x0/au88x0_core.c:536:			pr_err( "Vortex: could not set src-%d from %d to %d\n",
linux/sound/pci/au88x0/au88x0_a3d.c:238: * Interaural Time Difference (ITD). The differences in distance from 
linux/sound/drivers/virmidi.c:21: *   mapped from /dev/snd/midiC1D0 to /dev/snd/midiC1D3, respectively.
linux/sound/soc/ti/omap3pandora.c:273:		pr_err(PREFIX "Failed to get DAC regulator from %s: %ld\n",
linux/sound/soc/ti/omap-dmic.c:196:		dev_err(dmic->dev, "no valid divider for %dHz from %dHz\n",
linux/sound/soc/ti/Kconfig:141:	  ldattach  utility.  This  can be  started  automatically  from  udev,
linux/sound/soc/soc-core.c:11://         with code, comments and ideas from :-
linux/sound/soc/intel/boards/cht_bsw_rt5645.c:671:		dev_err(&pdev->dev, "Failed to get MCLK from %s: %ld\n",
linux/sound/soc/intel/boards/cht_bsw_max98090_ti.c:581:			"Failed to get MCLK from %s: %ld\n",
linux/sound/soc/codecs/tlv320aic31xx.c:459:			"Unhandled dapm widget event %d from %s\n",
linux/sound/soc/codecs/twl6040.c:340: * from -6 to 0 dB in 6 dB steps
linux/sound/soc/codecs/twl6040.c:352: * from -18 to 24 dB in 6 dB steps
linux/sound/soc/codecs/twl6040.c:358: * from -30 to 0 dB in 2 dB steps
linux/sound/soc/codecs/twl6040.c:364: * from -52 to 6 dB in 2 dB steps
linux/sound/soc/codecs/twl6040.c:370: * from -24 to 6 dB in 2 dB steps
linux/sound/soc/codecs/ak4458.c:86: * from -127 to 0 dB in 0.5 dB steps (mute instead of -127.5 dB)
linux/sound/soc/codecs/wm2200.c:1737:			"No valid BCLK for %dHz found from %dHz SYSCLK\n",
linux/sound/soc/codecs/twl4030.c:540: * from -51 to -10 dB in 1 dB steps (mute instead of -51 dB)
linux/sound/soc/codecs/twl4030.c:979: * from -62 to 0 dB in 1 dB steps (mute instead of -63 dB)
linux/sound/soc/codecs/twl4030.c:992: * from -37 to 12 dB in 1 dB steps (mute instead of -37 dB)
linux/sound/soc/codecs/tas5720.c:183:		/* Configure the TDM slot to process audio from */
linux/sound/soc/codecs/isabelle.c:346:/* from -63 to 0 dB in 1 dB steps */
linux/sound/soc/codecs/isabelle.c:349:/* from -63 to 9 dB in 1 dB steps */
linux/sound/soc/codecs/ak4375.c:118: * from -12.5 to 3 dB in 0.5 dB steps (mute instead of -12.5 dB)
linux/sound/soc/codecs/ak4375.c:124: * from -4.2 to 6 dB in 2 dB steps (mute instead of -4.2 dB)
linux/sound/soc/codecs/madera.c:2673:		"Unable to generate %dHz OUTCLK from %dHz MCLK\n",
linux/sound/soc/codecs/wm5100.c:623:/* FIXME: Only valid from -12dB to 0dB (52-64) */
linux/sound/soc/codecs/wm5100.c:1467:			"No valid BCLK for %dHz found from %dHz %s\n",
linux/sound/soc/codecs/cros_ec_codec.c:425:		dev_dbg(priv->dev, "round up from %u to %u\n", r.len, req);
linux/sound/soc/codecs/rt5677-spi.c:221:			"Invalid copy from (%u, %u), dma_area size %zu\n",
linux/sound/soc/codecs/mt6359.c:323:		dev_warn(priv->dev, "%s(), volume index is not valid, from %d, to %d\n",
linux/sound/soc/codecs/mt6359.c:328:	dev_dbg(priv->dev, "%s(), from %d, to %d\n", __func__, from, to);
linux/sound/soc/codecs/mt6359.c:333:		offset = from - to;
linux/sound/soc/codecs/mt6359.c:337:			reg_idx = from + count;
linux/sound/soc/codecs/mt6359.c:339:			reg_idx = from - count;
linux/sound/soc/codecs/ak4671.c:119: * from -24 to 6 dB in 6 dB steps (mute instead of -30 dB)
linux/sound/soc/codecs/ak4671.c:125: * from -33 to 6 dB in 3 dB steps (mute instead of -33 dB)
linux/sound/soc/codecs/ak4671.c:131: * from -6 to 3 dB in 3 dB steps
linux/sound/soc/codecs/ak4671.c:137: * from -15 to 30 dB in 3 dB steps
linux/sound/soc/codecs/src4xxx.c:209:	dev_info(component->dev, "changing mclk rate from %d to %d Hz\n",
linux/sound/soc/codecs/uda1380.c:267: * from -48 dB in 1.5 dB steps (mute instead of -49.5 dB)
linux/sound/soc/codecs/uda1380.c:272: * from -78 dB in 1 dB steps (3 dB steps, really. LSB are ignored),
linux/sound/soc/codecs/uda1380.c:273: * from -66 dB in 0.5 dB steps (2 dB steps, really) and
linux/sound/soc/codecs/uda1380.c:274: * from -52 dB in 0.25 dB steps
linux/sound/soc/codecs/uda1380.c:283: * from -72 dB in 1.5 dB steps (6 dB steps really),
linux/sound/soc/codecs/uda1380.c:284: * from -66 dB in 0.75 dB steps (3 dB steps really),
linux/sound/soc/codecs/uda1380.c:285: * from -60 dB in 0.5 dB steps (2 dB steps really) and
linux/sound/soc/codecs/uda1380.c:286: * from -46 dB in 0.25 dB steps
linux/sound/soc/codecs/uda1380.c:302:/* from -63 to 24 dB in 0.5 dB steps (-128...48) */
linux/sound/soc/codecs/mt6358.c:395:		dev_warn(priv->dev, "%s(), volume index is not valid, from %d, to %d\n",
linux/sound/soc/codecs/mt6358.c:398:	dev_info(priv->dev, "%s(), from %d, to %d\n",
linux/sound/soc/codecs/mt6358.c:404:		offset = from - to;
linux/sound/soc/codecs/mt6358.c:408:			reg_idx = from + count;
linux/sound/soc/codecs/mt6358.c:410:			reg_idx = from - count;
linux/sound/soc/codecs/nau8825.c:320:		from = vol_from;
linux/sound/soc/codecs/nau8825.c:324:		from = vol_to;
linux/sound/soc/codecs/wm0010.c:209:	dev_err(wm0010->dev, "Failed to transition from `%s' state to `%s' state\n",
linux/sound/soc/codecs/wm8955.c:286:				"Unable to generate %dHz from %dHz MCLK\n",
linux/sound/soc/codecs/wm8994.c:2986:		dev_dbg(dai->dev, "Constraining channels to %d from %d\n",
linux/sound/soc/codecs/wm8994.c:3057:		dev_err(dai->dev, "Unable to generate LRCLK from %dHz BCLK\n",
linux/sound/soc/atmel/atmel-pdmic.c:227:/* range from -90 dB to 90 dB */
linux/sound/soc/generic/simple-card-utils.c:235:	 * Parse dai->sysclk come from "clocks = <&xxx>"
linux/sound/soc/sof/intel/hda-dsp.c:477:		dev_err(sdev->dev, "error: transition from %d to %d not allowed\n",
linux/sound/soc/sof/intel/hda-dsp.c:593:			"error: transition from %d to %d not allowed\n",
linux/sound/soc/sof/ipc3-loader.c:120:	 * it prevents from reading unallocated memory from `head` in following
linux/sound/soc/sof/topology.c:525:		dev_err(sdev->dev, "No space in tuples array for new tokens from %s",
linux/sound/soc/sof/core.c:82: * helper to be called from .dbg_dump callbacks. No error code is
linux/sound/soc/tegra/tegra210_sfc.c:3077:			"Conversion from %d to %d Hz is not supported\n",
linux/sound/soc/kirkwood/kirkwood.h:124:/* need to find where they come from               */
linux/sound/soc/soc-ops.c:11://         with code, comments and ideas from :-
linux/sound/soc/soc-ac97.c:11://         with code, comments and ideas from :-
linux/sound/soc/soc-topology.c:2550:/* load audio component topology from "firmware" file */
linux/sound/soc/fsl/imx-audmux.c:82:				"TxFS output from %s, ",
linux/sound/soc/fsl/imx-audmux.c:90:				"TxClk output from %s",
linux/sound/soc/fsl/imx-audmux.c:104:					"RxFS output from %s, ",
linux/sound/soc/fsl/imx-audmux.c:112:					"RxClk output from %s",
linux/sound/soc/fsl/imx-audmux.c:120:			"\nData received from %s\n",
linux/sound/firewire/lib.c:29: * response.  The node ID and the current generation are derived from @unit.
linux/kernel/rcu/tree.h:61:				/*  Initialized from ->qsmaskinitnext at the */
linux/kernel/rcu/tree.h:69:				/*  Initialized from ->expmaskinitnext at the */
linux/kernel/rcu/tasks.h:1269:/* Load from ->trc_reader_special.b.need_qs with proper ordering. */
linux/kernel/rcu/tasks.h:1873:	pr_info("Callback from %s invoked.\n", rttd->name);
linux/kernel/rcu/srcutree.c:506:	 * an smp_mb() and a later fetch from ->srcu_idx, that task will be
linux/kernel/rcu/srcutree.c:509:	 * smp_mb(), and the fetch from ->srcu_idx in __srcu_read_lock()
linux/kernel/rcu/srcutree.c:1458:	// before the load from ->srcu_gp_seq.
linux/kernel/rcu/tree_nocb.h:451:	// moving back from ->nocb_bypass to ->cblist.
linux/kernel/rcu/rcu_segcblist.c:126:	if (from == to)
linux/kernel/rcu/tree.c:3553:	 * before the load from ->gp_seq.
linux/kernel/rcu/tree.c:3582:	 * before the loads from ->gp_seq and ->expedited_sequence.
linux/kernel/rcu/tree.c:4759:		pr_alert("%s: Limited prio to %d from %d\n",
linux/kernel/rcu/refscale.c:632:		WARN_ONCE(a != b, "Re-read of ->a changed from %u to %u.\n", a, b);
linux/kernel/dma/contiguous.c:225: * reserve in range from @base to @limit.
linux/kernel/livepatch/transition.c:653:	pr_debug("'%s': reversing transition from %s\n",
linux/kernel/locking/osq_lock.c:185:	 * Similar to unlock(), wait for @node->next or move @lock from @node
linux/kernel/locking/lockdep.c:2408: * printk the shortest lock dependencies from @root to @leaf in reverse order.
linux/kernel/locking/lockdep.c:2419: * , so it's natural that we start from @leaf and print every ->class and
linux/kernel/locking/lockdep.c:2449: * printk the shortest lock dependencies from @leaf to @root.
linux/kernel/locking/lockdep.c:2460: * , so when we iterate from @leaf to @root, we actually print the lock
linux/kernel/locking/lockdep.c:4742: * can be taken from (pretty much) any context but also has constraints.
linux/kernel/locking/test-ww_mutex.c:126:	const char *from = trylock ? "trylock" : "lock";
linux/kernel/locking/test-ww_mutex.c:146:		pr_err("%s: trylocked itself without context from %s!\n", __func__, from);
linux/kernel/locking/test-ww_mutex.c:153:		pr_err("%s: trylocked itself with context from %s!\n", __func__, from);
linux/kernel/locking/test-ww_mutex.c:161:		pr_err("%s: missed deadlock for recursing, ret=%d from %s\n",
linux/kernel/printk/printk.c:592:	 * If this is from /proc/kmsg and we've already opened it, then we've
linux/kernel/printk/printk_ringbuffer.c:557: * data block from @lpos_begin until @lpos_end into the reusable state.
linux/kernel/trace/pid_list.c:215: * Removes @pid from @pid_list. This is usually done explicitly by a user
linux/kernel/trace/pid_list.c:265: * @next: The pointer to place the pid that is set starting from @pid.
linux/kernel/trace/trace.c:588: * Checks if @task should be traced or not from @filtered_pids.
linux/kernel/trace/trace.c:3875: * @ap: The va_list holding the data to print from @fmt.
linux/kernel/trace/rethook.c:145: * Get an unused rethook node from @rh. If the node pool is empty, this
linux/kernel/bpf/dispatcher.c:143:	if (from == to)
linux/kernel/bpf/bpf_iter.c:122:		seq->from += n;
linux/kernel/bpf/bpf_iter.c:127:	seq->from = 0;
linux/kernel/bpf/bpf_iter.c:232:	seq->from = n;
linux/kernel/bpf/helpers.c:1387:	 * from 't'. The bpf subprog callback_fn won't be able to access 't',
linux/kernel/bpf/reuseport_array.c:107:	 * both removing sk from "array".  Who removes it
linux/kernel/bpf/stackmap.c:196:		unsigned long *from = (unsigned long *) entry->ip;
linux/kernel/bpf/verifier.c:5656:		verbose(env, "only read from %s is supported\n", tname);
linux/kernel/bpf/verifier.c:16550:		/* convert i from "first prog to remove" to "first to adjust" */
linux/kernel/irq/irqdomain.c:1301:	pr_info("IRQ%d: trimming hierarchy from %s\n",
linux/kernel/irq/devres.c:195:	dr->from = base;
linux/kernel/irq/msi.c:54: * and the affinity masks and flags from @affinity are copied.
linux/kernel/irq/msi.c:206: * @first:	Index to start freeing from (inclusive)
linux/kernel/irq/proc.c:31: * The read from /proc/interrupts is a different problem because there
linux/kernel/irq/irqdesc.c:764:	if (from >= nr_irqs || (from + cnt) > nr_irqs)
linux/kernel/irq/irqdesc.c:769:		free_desc(from + i);
linux/kernel/irq/irqdesc.c:799:		if (from > irq)
linux/kernel/irq/irqdesc.c:801:		from = irq;
linux/kernel/irq/irqdesc.c:808:		from = arch_dynirq_lower_bound(from);
linux/kernel/time/tick-common.c:195:	int from = tick_do_timer_boot_cpu;
linux/kernel/time/tick-common.c:197:	if (from >= 0 && from != cpu)
linux/kernel/time/clocksource.c:68:		tmp += from / 2;
linux/kernel/time/namespace.c:123: * copy_time_ns - Create timens_for_children from @old_ns
linux/kernel/time/timeconv.c:102:	 * is slightly different from [1].
linux/kernel/kprobes.c:778:	/* Optimize it again. (remove from 'op->list') */
linux/kernel/cgroup/cgroup.c:898: * Move @task from @from_cset to @to_cset.  If @task didn't belong to any
linux/kernel/cgroup/cgroup.c:1106:			 * effective css from @cgrp.
linux/kernel/cgroup/cgroup.c:6668: * Description: Detach cgroup from @tsk.
linux/kernel/cgroup/cpuset.c:1909:		mwork->from = *from;
linux/kernel/cgroup/rdma.c:373:	argstr.from = value;
linux/kernel/cgroup/rstat.c:82: * Walks the updated rstat_cpu tree on @cpu from @root.  %NULL @pos starts
linux/kernel/watchdog.c:286:	 * from (soft)interrupt context, so the access to
linux/kernel/relay.c:1059:		from = buf->start + read_start;
linux/kernel/smp.c:1049: * @ret: return value from @func
linux/kernel/workqueue.c:1075: * Schedule linked works starting from @work to @head.  Work series to
linux/kernel/workqueue.c:1293:	 * steal it from ->worklist without clearing WORK_STRUCT_PENDING.
linux/kernel/workqueue.c:2782: * underneath us, so we can't reliably determine pwq from @target.
linux/kernel/workqueue.c:4004: * Return: %true if the resulting @cpumask is different from @attrs->cpumask,
linux/kernel/workqueue.c:4254: * This function is to be called from %CPU_DOWN_PREPARE, %CPU_ONLINE and
linux/kernel/resource.c:1942: * @size: size in bytes of memory to allocate from @base
linux/kernel/kcsan/core.c:294: * congruential generator, using constants from "Numerical Recipes".
linux/kernel/events/ring_buffer.c:581:	from &= (rb->aux_nr_pages << PAGE_SHIFT) - 1;
linux/kernel/events/ring_buffer.c:591:		addr = rb->aux_pages[from >> PAGE_SHIFT];
linux/kernel/events/ring_buffer.c:599:		from += tocopy;
linux/kernel/events/ring_buffer.c:600:		from &= (rb->aux_nr_pages << PAGE_SHIFT) - 1;
linux/kernel/events/uprobes.c:2084:				"bad rc=0x%x from %ps()\n", rc, uc->handler);
linux/kernel/power/snapshot.c:2388: * the data will have to be copied from @buffer.
linux/kernel/power/snapshot.c:2437: * Copy the contents of a highmem image from @buffer, where the caller of
linux/kernel/power/suspend_test.c:71:		KERN_INFO "PM: test RTC wakeup from '%s' suspend\n";
linux/kernel/power/Kconfig:55:	  from <http://suspend.sf.net>.
linux/kernel/power/Kconfig:251:	  functions from <linux/resume-trace.h> as well as the
linux/kernel/power/hibernate.c:1076: * string representation (as returned by reading from /sys/power/disk) back
linux/kernel/power/main.c:708: * writing to 'state'.  It first should read from 'wakeup_count' and store
linux/kernel/signal.c:272: * Clear @mask from @task->jobctl.  @mask must be subset of
linux/kernel/signal.c:326: * Clear @mask from @task->jobctl.  @mask must be subset of
linux/kernel/signal.c:3346:	if (copy_to_user(to, from , sizeof(struct kernel_siginfo)))
linux/kernel/signal.c:4805:		kdb_printf("Process is not RUNNING, sending a signal from "
linux/kernel/sched/topology.c:2042: *                             closest to @cpu from @cpumask.
linux/kernel/sched/topology.c:2103: *                             closest to @cpu from @cpumask.
linux/kernel/sched/fair.c:6479: * cpu_load_without - compute CPU load without any contributions from *p
linux/kernel/sched/fair.c:7206: * Predicts what cpu_util(@cpu) would return if @p was removed from @cpu
linux/kernel/sched/fair.c:7215:	 * If @dst_cpu is -1 or @p migrates from @cpu to @dst_cpu remove its
linux/kernel/sched/fair.c:7268: * cpu_util_without: compute cpu utilization without any contributions from *p
linux/kernel/sched/fair.c:8230: * directly from (1):
linux/kernel/sched/fair.c:10374:	/* There is no busy sibling group to pull tasks from */
linux/kernel/sched/membarrier.c:93: * Using the scenario from (A), we can show that (a) needs to be paired
linux/kernel/sched/membarrier.c:94: * with (e). Using the scenario from (B), we can show that (c) needs to
linux/kernel/sched/membarrier.c:131: * Using the scenario from (A), we can show that (a) needs to be paired
linux/kernel/sched/membarrier.c:132: * with (g). Using the scenario from (B), we can show that (c) needs to
linux/kernel/sched/deadline.c:1777:	 * (the task moves from "active contending" to "active non contending"
linux/kernel/sched/core.c:11545: * (TSA) Store to rq->curr with transition from (N) to (Y)
linux/kernel/sched/core.c:11547: * (TSB) Store to rq->curr with transition from (Y) to (N)
linux/kernel/debug/kdb/kdb_support.c:73: * namebuf[KSYM_NAME_LEN-1] will never change from '\0' although we do
linux/kernel/module/main.c:1019:/* Parse tag=value strings from .modinfo section */
linux/crypto/ecc.c:191:	const u64 *from = src;
linux/crypto/ecc.c:201:	const u64 *from = src;
linux/crypto/ecc.c:797: * from "Mathematical routines for the NIST prime elliptic curves"
linux/crypto/ghash-generic.c:25: * The reason "ghash" is separate from "gcm" is to allow "gcm" to use an
linux/init/Kconfig:378:	  DOSEMU-HOWTO, available from <http://www.tldp.org/docs.html#howto>),
linux/tools/include/linux/list.h:254: * including @entry, from @head to @list. You should
linux/tools/include/uapi/linux/bpf.h:1661: * 		Delete entry with *key* from *map*.
linux/tools/include/uapi/linux/bpf.h:2188: * 		packet. It can be used to load *len* bytes from *offset* from
linux/tools/include/uapi/linux/bpf.h:2445: * 		from *skb* readable and writable. If a zero value is passed for
linux/tools/include/uapi/linux/bpf.h:2576: * 		*skb*, but gets socket from **struct bpf_sock_addr** context.
linux/tools/include/uapi/linux/bpf.h:2583: * 		*skb*, but gets socket from **struct bpf_sock_ops** context.
linux/tools/include/uapi/linux/bpf.h:3133: * 		it provides an easy way to load *len* bytes from *offset*
linux/tools/include/uapi/linux/bpf.h:3483: *		result is from *reuse*\ **->socks**\ [] using the hash of the
linux/tools/include/uapi/linux/bpf.h:3520: *		result is from *reuse*\ **->socks**\ [] using the hash of the
linux/tools/include/uapi/linux/bpf.h:3543: * 		Pop an element from *map*.
linux/tools/include/uapi/linux/bpf.h:3549: * 		Get an element from *map* without removing it.
linux/tools/include/uapi/linux/bpf.h:3700: *		result is from *reuse*\ **->socks**\ [] using the hash of the
linux/tools/include/uapi/linux/bpf.h:4253: *		returned from **bpf_sk_lookup_xxx**\ (),
linux/tools/include/uapi/linux/bpf.h:4282: * 		Copy *size* bytes from *data* into a ring buffer *ringbuf*.
linux/tools/include/uapi/linux/bpf.h:4664: * 		This helper differs from **bpf_get_cgroup_classid**\ () in that
linux/tools/include/uapi/linux/bpf.h:4715: *		the kernel. Different from **bpf_per_cpu_ptr**\ (), it would
linux/tools/include/uapi/linux/bpf.h:5226: *		xdp buffer. It can be used to load *len* bytes from *offset* from
linux/tools/include/uapi/linux/bpf.h:5359: *		Read *len* bytes from *src* into *dst*, starting from *offset*
linux/tools/include/uapi/linux/bpf.h:5369: *		Write *len* bytes from *src* into *dst*, starting from *offset*
linux/tools/include/uapi/drm/i915_drm.h:894:	/** Offset into the object to read from */
linux/tools/bpf/resolve_btfids/main.c:355:	 * from .BTF_ids section and symbols.
linux/tools/bpf/resolve_btfids/main.c:376:			pr_err("FAILED to get section(%d) data from %s\n",
linux/tools/bpf/resolve_btfids/main.c:520:			pr_err("FAILED: load base BTF from %s: %s\n",
linux/tools/bpf/resolve_btfids/main.c:529:		pr_err("FAILED: load BTF from %s: %s\n",
linux/tools/bpf/bpftool/Documentation/bpftool-prog.rst:195:		  input. Input context, if any, is read from *FILE* passed with
linux/tools/bpf/bpftool/Documentation/bpftool-struct_ops.rst:55:		  Register bpf struct_ops from *OBJ*.  All struct_ops under
linux/tools/bpf/bpftool/Documentation/bpftool-iter.rst:41:		  The *pin* command creates a bpf iterator from *OBJ*,
linux/tools/bpf/bpftool/prog.c:1150:			p_err("failed to read data_in/ctx_in from %s: %s",
linux/tools/bpf/bpftool/btf.c:636:			p_err("failed to load BTF from %s: %s",
linux/tools/bpf/bpftool/map.c:854:		p_info("Warning: cannot read values from %s map with value_size != 8",
linux/tools/bpf/bpf_dbg.c:20: *  2) > load bpf 6,40 0 0 12,21 0 3 20... (output from `bpf_asm` or
linux/tools/objtool/include/objtool/endianness.h:12: * To be used for multi-byte values conversion, which are read from / about
linux/tools/kvm/kvm_stat/kvm_stat:1422:            self.screen.addstr(2, 0, 'Change delay from %.1fs to ' %
linux/tools/memory-model/Documentation/ordering.txt:78:from "y", as indicated by the comment.  And yes, please comment your
linux/tools/memory-model/Documentation/ordering.txt:215:Then any given CPU will see the read from "y" as having preceded the read from
linux/tools/memory-model/Documentation/ordering.txt:278:from "x" instead of writing to it.  Then an smp_wmb() could not guarantee
linux/tools/memory-model/Documentation/ordering.txt:429:In this case, all CPUs would see the read from "a" as happening before
linux/tools/memory-model/Documentation/litmus-tests.txt:154:"r1 = READ_ONCE(*x)", which does an unordered load from "*x" into local
linux/tools/memory-model/Documentation/litmus-tests.txt:176:loaded a value from "x" that was equal to 1 but loaded a value from "y"
linux/tools/memory-model/Documentation/litmus-tests.txt:344:executed only if line 9 loads a non-zero value from "x".  Because P1()'s
linux/tools/memory-model/Documentation/litmus-tests.txt:345:write of "1" to "x" happens only after P1()'s read from "y", one would
linux/tools/memory-model/Documentation/litmus-tests.txt:548:process changes the value of "sl" from "0" to "1", and is released when
linux/tools/memory-model/Documentation/litmus-tests.txt:722:"exists" clause therefore tests whether line 20's load from "y" saw the
linux/tools/memory-model/Documentation/litmus-tests.txt:726:from "y", replacing "z".
linux/tools/memory-model/Documentation/litmus-tests.txt:728:P1()'s line 20 loads a pointer from "y", and line 21 dereferences that
linux/tools/memory-model/Documentation/litmus-tests.txt:869:call_rcu().  Line 30 first does an acquire load from "c", then line 31
linux/tools/memory-model/Documentation/recipes.txt:398:The kernel's control dependency between the load from ->data_tail
linux/tools/memory-model/Documentation/control-dependencies.txt:20:are permitted to predict the result of the load from "b".  This prediction
linux/tools/memory-model/Documentation/control-dependencies.txt:22:from "a".  This means that an explicit read barrier is required, for example
linux/tools/memory-model/Documentation/control-dependencies.txt:42:fuse the load from "a" with other loads.  Without the WRITE_ONCE(),
linux/tools/memory-model/Documentation/control-dependencies.txt:87:Now there is no conditional between the load from "a" and the store to
linux/tools/memory-model/Documentation/control-dependencies.txt:192:	WRITE_ONCE(c, 1);  /* BUG: No ordering against the read from "a". */
linux/tools/memory-model/Documentation/locking.txt:135:The smp_load_acquire() guarantees that its load from "flags" will
linux/tools/memory-model/litmus-tests/Z6.0+pooncerelease+poacquirerelease+fencembonceonce.litmus:7: * when there is but one non-reads-from (AKA non-rf) link, does not suffice
linux/tools/usb/usbip/src/usbip_list.c:143:		err("failed to get device list from %s", host);
linux/tools/usb/usbip/src/usbip.c:81:		.help  = "Unbind device from " USBIP_HOST_DRV_NAME ".ko",
linux/tools/usb/usbip/src/usbipd.c:332:		info("denied access from %s", host);
linux/tools/usb/usbip/src/usbipd.c:337:	info("connection from %s:%s", host, port);
linux/tools/usb/usbip/src/usbip_unbind.c:22:	"    -b, --busid=<busid>    Unbind " USBIP_HOST_DRV_NAME ".ko from "
linux/tools/tracing/rtla/src/osnoise.c:63:	debug_msg("setting cpus to %s from %s", cpus, context->orig_cpus);
linux/tools/tracing/latency/latency-collector.c:1671:"Collect closely occurring latencies from %s\n"
linux/tools/perf/include/perf/perf_dlfilter.h:101:	/* Return arguments from --dlarg option */
linux/tools/perf/include/perf/perf_dlfilter.h:125: * but most perf_dlfilter_fns are not valid when called from 'start'.
linux/tools/perf/include/perf/perf_dlfilter.h:134: * are not valid when called from 'stop'.
linux/tools/perf/pmu-events/jevents.py:18:# List of event tables generated from "/sys" directories.
linux/tools/perf/pmu-events/jevents.py:22:# List of metric tables generated from "/sys" directories.
linux/tools/perf/pmu-events/jevents.py:656:  """C struct mapping table array for tables from /sys directories."""
linux/tools/perf/pmu-events/arch/x86/haswell/hsw-metrics.json:252:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/haswellx/hsx-metrics.json:252:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/icelakex/icx-metrics.json:251:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_info_memory_bandwidth, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:1861:        "PublicDescription": "Horizontal BL Ring in Use : Left and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:1870:        "PublicDescription": "Horizontal BL Ring in Use : Left and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:1879:        "PublicDescription": "Horizontal BL Ring in Use : Right and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:1888:        "PublicDescription": "Horizontal BL Ring in Use : Right and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:6248:        "PublicDescription": "Vertical BL Ring in Use : Down and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:6257:        "PublicDescription": "Vertical BL Ring in Use : Down and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:6266:        "PublicDescription": "Vertical BL Ring in Use : Up and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:6275:        "PublicDescription": "Vertical BL Ring in Use : Up and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:7739:        "PublicDescription": "Horizontal BL Ring in Use : Left and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:7748:        "PublicDescription": "Horizontal BL Ring in Use : Left and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:7757:        "PublicDescription": "Horizontal BL Ring in Use : Right and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:7766:        "PublicDescription": "Horizontal BL Ring in Use : Right and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:12725:        "PublicDescription": "Vertical BL Ring in Use : Down and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:12734:        "PublicDescription": "Vertical BL Ring in Use : Down and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:12743:        "PublicDescription": "Vertical BL Ring in Use : Up and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-interconnect.json:12752:        "PublicDescription": "Vertical BL Ring in Use : Up and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-io.json:5461:        "PublicDescription": "Horizontal BL Ring in Use : Left and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-io.json:5470:        "PublicDescription": "Horizontal BL Ring in Use : Left and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-io.json:5479:        "PublicDescription": "Horizontal BL Ring in Use : Right and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-io.json:5488:        "PublicDescription": "Horizontal BL Ring in Use : Right and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-io.json:9185:        "PublicDescription": "Vertical BL Ring in Use : Down and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-io.json:9194:        "PublicDescription": "Vertical BL Ring in Use : Down and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-io.json:9203:        "PublicDescription": "Vertical BL Ring in Use : Up and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-io.json:9212:        "PublicDescription": "Vertical BL Ring in Use : Up and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-cache.json:1120:        "BriefDescription": "Multi-socket cacheline directory state updates; memory write due to directory update from (table of requests) TOR pipe",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-cache.json:1453:        "PublicDescription": "Horizontal BL Ring in Use : Left and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-cache.json:1462:        "PublicDescription": "Horizontal BL Ring in Use : Left and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-cache.json:1471:        "PublicDescription": "Horizontal BL Ring in Use : Right and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-cache.json:1480:        "PublicDescription": "Horizontal BL Ring in Use : Right and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-cache.json:9583:        "PublicDescription": "Vertical BL Ring in Use : Down and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-cache.json:9592:        "PublicDescription": "Vertical BL Ring in Use : Down and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-cache.json:9601:        "PublicDescription": "Vertical BL Ring in Use : Up and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/icelakex/uncore-cache.json:9610:        "PublicDescription": "Vertical BL Ring in Use : Up and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/tigerlake/tgl-metrics.json:280:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_info_memory_bandwidth, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:1500:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:1509:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:1518:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:1527:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:4108:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:4117:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:4126:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:4135:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:4940:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:4949:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:4958:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:4967:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:9597:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:9606:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:9615:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-interconnect.json:9624:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-cache.json:895:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-cache.json:904:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-cache.json:913:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-cache.json:922:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-cache.json:5377:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-cache.json:5386:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-cache.json:5395:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/uncore-cache.json:5404:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/skylakex/skx-metrics.json:269:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_info_memory_bandwidth, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/alderlake/adl-metrics.json:1042:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_info_memory_bandwidth, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/sapphirerapids/spr-metrics.json:250:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_info_memory_bandwidth, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/icelake/icl-metrics.json:286:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_info_memory_bandwidth, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/skylake/skl-metrics.json:269:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_info_memory_bandwidth, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:1500:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:1509:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:1518:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:1527:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:4210:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:4219:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:4228:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:4237:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:5042:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:5051:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:5060:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:5069:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:9699:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:9708:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:9717:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-interconnect.json:9726:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-cache.json:947:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-cache.json:956:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-cache.json:965:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-cache.json:974:        "PublicDescription": "Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-cache.json:5492:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-cache.json:5501:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-cache.json:5510:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/uncore-cache.json:5519:        "PublicDescription": "Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/cascadelakex/clx-metrics.json:269:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_info_memory_bandwidth, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/ivytown/ivt-metrics.json:252:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/broadwellx/bdx-metrics.json:261:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/jaketown/uncore-cache.json:216:        "PublicDescription": "Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the 'UP' direction is on the clockwise ring and 'DN' is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/jaketown/uncore-cache.json:225:        "PublicDescription": "Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the 'UP' direction is on the clockwise ring and 'DN' is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/jaketown/uncore-cache.json:234:        "PublicDescription": "Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the 'UP' direction is on the clockwise ring and 'DN' is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/jaketown/uncore-cache.json:243:        "PublicDescription": "Counts the number of cycles that the BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings in JKT -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the 'UP' direction is on the clockwise ring and 'DN' is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/ivybridge/ivb-metrics.json:252:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-interconnect.json:1639:        "PublicDescription": "Horizontal BL Ring in Use : Left and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-interconnect.json:1648:        "PublicDescription": "Horizontal BL Ring in Use : Left and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-interconnect.json:1657:        "PublicDescription": "Horizontal BL Ring in Use : Right and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-interconnect.json:1666:        "PublicDescription": "Horizontal BL Ring in Use : Right and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-interconnect.json:5471:        "PublicDescription": "Vertical BL Ring in Use : Down and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-interconnect.json:5480:        "PublicDescription": "Vertical BL Ring in Use : Down and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-interconnect.json:5489:        "PublicDescription": "Vertical BL Ring in Use : Up and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-interconnect.json:5498:        "PublicDescription": "Vertical BL Ring in Use : Up and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-io.json:5479:        "PublicDescription": "Horizontal BL Ring in Use : Left and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-io.json:5488:        "PublicDescription": "Horizontal BL Ring in Use : Left and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-io.json:5497:        "PublicDescription": "Horizontal BL Ring in Use : Right and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-io.json:5506:        "PublicDescription": "Horizontal BL Ring in Use : Right and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-io.json:8859:        "PublicDescription": "Vertical BL Ring in Use : Down and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-io.json:8868:        "PublicDescription": "Vertical BL Ring in Use : Down and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-io.json:8877:        "PublicDescription": "Vertical BL Ring in Use : Up and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-io.json:8886:        "PublicDescription": "Vertical BL Ring in Use : Up and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-cache.json:1239:        "PublicDescription": "Horizontal BL Ring in Use : Left and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-cache.json:1248:        "PublicDescription": "Horizontal BL Ring in Use : Left and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-cache.json:1257:        "PublicDescription": "Horizontal BL Ring in Use : Right and Even : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-cache.json:1266:        "PublicDescription": "Horizontal BL Ring in Use : Right and Odd : Counts the number of cycles that the Horizontal BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-cache.json:6823:        "PublicDescription": "Vertical BL Ring in Use : Down and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-cache.json:6832:        "PublicDescription": "Vertical BL Ring in Use : Down and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-cache.json:6841:        "PublicDescription": "Vertical BL Ring in Use : Up and Even : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/snowridgex/uncore-cache.json:6850:        "PublicDescription": "Vertical BL Ring in Use : Up and Odd : Counts the number of cycles that the Vertical BL ring is being used at this ring stop.  This includes when packets are passing by and when packets are being sunk, but does not include when packets are being sent from  the ring stop.We really have two rings -- a clockwise ring and a counter-clockwise ring.  On the left side of the ring, the UP direction is on the clockwise ring and DN is on the counter-clockwise ring.  On the right side of the ring, this is reversed.  The first half of the CBos are on the left side of the ring, and the 2nd half are on the right side of the ring.  In other words (for example), in a 4c part, Cbo 0 UP AD is NOT the same ring as CBo 2 UP AD because they are on opposite sides of the ring.",
linux/tools/perf/pmu-events/arch/x86/broadwellde/bdwde-metrics.json:246:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/pmu-events/arch/x86/broadwell/bdw-metrics.json:261:        "PublicDescription": "This metric does a *rough estimation* of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value; the deeper the memory hierarchy level the misses are satisfied from (metric values >1 are valid). Often it hints on approaching bandwidth limits (to L2 cache; L3 cache or external memory). Related metrics: tma_info_dram_bw_use, tma_mem_bandwidth, tma_sq_full, tma_store_latency, tma_streaming_stores",
linux/tools/perf/Documentation/perf-kvm.txt:47:  for use by perf report. As buildid is read from /sys/kernel/notes in os, then
linux/tools/perf/Documentation/perf-test.txt:22:from 'perf test list'.
linux/tools/perf/Documentation/perf-intel-pt.txt:1539:	- branches entering and exiting the virtual machine are split, and show as 2 branches to/from "0 [unknown] ([unknown])"
linux/tools/perf/Documentation/perf-dlfilter.txt:48:perf_dlfilter_fns are not valid when called from 'start'.
linux/tools/perf/Documentation/perf-dlfilter.txt:54:when called from 'stop'.
linux/tools/perf/Documentation/perf-dlfilter.txt:161:'args' returns arguments from --dlarg options.
linux/tools/perf/Documentation/perf-dlfilter.txt:232:Filter out everything except branches from "foo" to "bar":
linux/tools/perf/Documentation/perf-script-python.txt:675:		print "from %s, to %s, cycles %s" % (entry["from"], entry["to"], entry["cycles"])
linux/tools/perf/Documentation/perf-diff.txt:160:	For example, we get the timestamp information from 'perf script'.
linux/tools/perf/Documentation/perf-config.txt:205:		This selects colors for addresses from 'annotate'.
linux/tools/perf/Documentation/perf-config.txt:465:		This output is a 'fractal' format. The 'foo' came from 'bar' and 'baz' exactly
linux/tools/perf/Documentation/perf-config.txt:503:		Allows changing the default sort order from "comm,dso,symbol" to
linux/tools/perf/Documentation/perf-config.txt:662:		Path to clang. If omit, search it from $PATH.
linux/tools/perf/builtin-timechart.c:1049:		int from = 0, to = 0;
linux/tools/perf/builtin-timechart.c:1060:							from = c->Y;
linux/tools/perf/builtin-timechart.c:1073:						from = c->Y;
linux/tools/perf/builtin-timechart.c:1097:		else if (from && to && abs(from - to) == 1)
linux/tools/perf/tests/vmlinux-kallsyms.c:132:	 * both vmlinux + .ko files and from /proc/kallsyms split by modules.
linux/tools/perf/tests/vmlinux-kallsyms.c:143:	 * load /proc/kallsyms. Also create the modules maps from /proc/modules
linux/tools/perf/tests/vmlinux-kallsyms.c:159:	 * of modules extracted from /proc/kcore, in its current form, can't
linux/tools/perf/tests/vmlinux-kallsyms.c:161:	 * code and with the one got from /proc/modules from the "kallsyms" code.
linux/tools/perf/tests/shell/stat+json_output.sh:165:# example, socket value is fetched from "physical_package_id"
linux/tools/perf/tests/shell/stat+csv_output.sh:190:# example, socket value is fetched from "physical_package_id"
linux/tools/perf/builtin-inject.c:1110:	size_t from = evlist->core.nr_entries - new_cnt;
linux/tools/perf/bench/epoll-ctl.c:359:	printinfo("Setting RLIMIT_NOFILE rlimit from %" PRIu64 " to: %" PRIu64 "\n",
linux/tools/perf/bench/futex-requeue.c:205:	printf("Run summary [PID %d]: Requeuing %d threads (from [%s] %p to %s%p), "
linux/tools/perf/bench/futex-requeue.c:256:				err(EXIT_FAILURE, "couldn't requeue from %p to %p",
linux/tools/perf/bench/epoll-wait.c:479:	printinfo("Setting RLIMIT_NOFILE rlimit from %" PRIu64 " to: %" PRIu64 "\n",
linux/tools/perf/builtin-script.c:921:		from = entries[i].from;
linux/tools/perf/builtin-script.c:968:		from = entries[i].from;
linux/tools/perf/builtin-script.c:1010:		from = entries[i].from;
linux/tools/perf/builtin-script.c:1015:			from = map__dso_map_ip(alf.map, from);
linux/tools/perf/builtin-script.c:1266:		if (entries[i].from || entries[i].to)
linux/tools/perf/builtin-script.c:1316:	if (entries[0].from == sample->ip)
linux/tools/perf/ui/browsers/annotate.c:199:		from = cursor->al.idx_asm;
linux/tools/perf/ui/browsers/annotate.c:202:		from = (u64)cursor->al.idx;
linux/tools/perf/ui/browsers/annotate.c:217:				       from - diff, diff, to > from);
linux/tools/perf/examples/bpf/5sec.c:22:      I.e. add where it comes from (rqtp->tv_nsec) and where it will be
linux/tools/perf/builtin-trace.c:3974:	 * reading it from /proc/pid/fd/ in cases where that doesn't make
linux/tools/perf/builtin-trace.c:4856:	 * events from .perfconfig, so that if those events fail parsing, say some
linux/tools/perf/util/symbol.c:896:			 * So that we look just like we get from .ko files,
linux/tools/perf/util/tsc.c:126:	 * The event TIME_CONV was extended for the fields from "time_cycles"
linux/tools/perf/util/cpumap.c:21: * The numa node X as read from /sys/devices/system/node/nodeX indexed by the
linux/tools/perf/util/cpumap.c:671:		online = perf_cpu_map__new(NULL); /* from /sys/devices/system/cpu/online */
linux/tools/perf/util/auxtrace.c:65: * Make a group from 'leader' to 'last', requiring that the events were not
linux/tools/perf/util/parse-events.c:1807: * instance of any modifier (apart from 'p') present.
linux/tools/perf/util/evlist.h:303: * __evlist__for_each_entry_from - continue iteration from @evsel (included)
linux/tools/perf/util/evlist.h:311: * evlist__for_each_entry_from - continue iteration from @evsel (included)
linux/tools/perf/util/expr.c:199:	 * originally from 'struct pmu_event' object.
linux/tools/perf/util/pmu.h:97:	 * event read from <sysfs>/bus/event_source/devices/<name>/events/ or
linux/tools/perf/util/dsos.c:199:	 * references to the 'thread', 'map', 'dso' structs all from 'struct
linux/tools/perf/util/sort.c:1058:		struct addr_map_symbol *from = &he->branch_info->from;
linux/tools/perf/util/sort.c:1171:		struct addr_map_symbol *from = &he->branch_info->from;
linux/tools/perf/util/annotate.c:2111:		pr_err("No output from %s\n", command);
linux/tools/perf/util/probe-finder.c:708:				pr_warning("Ignoring tail call from %s\n",
linux/tools/perf/util/probe-finder.c:1181:	/* Fastpath: lookup by function name from .debug_pubnames section */
linux/tools/perf/util/probe-finder.c:1949:	/* Fastpath: lookup by function name from .debug_pubnames section */
linux/tools/perf/util/parse-events.l:325:	 * and we'd need to parse it manually. During the escape from <mem>
linux/tools/perf/util/strfilter.h:79: * Reconstruct a rule string from @filter. This will be good for
linux/tools/perf/util/probe-event.c:3054:			pr_err("Failed to load symbols from %s\n",
linux/tools/perf/util/evsel.c:390: * evsel__clone - create a new evsel copied from @orig
linux/tools/perf/util/cpumap.h:14:	/** The numa node X as read from /sys/devices/system/node/nodeX. */
linux/tools/perf/util/cpumap.h:21:	/** The die id as read from /sys/devices/system/cpu/cpuX/topology/die_id. */
linux/tools/perf/util/cpumap.h:23:	/** The core id as read from /sys/devices/system/cpu/cpuX/topology/core_id. */
linux/tools/perf/util/record.c:192:			pr_warning("warning: Maximum frequency rate (%'u Hz) exceeded, throttling from %'u Hz to %'u Hz.\n"
linux/tools/perf/util/record.c:206:		pr_warning("Lowering default frequency rate from %u to %u.\n"
linux/tools/perf/util/jitdump.c:405:	 * The event TIME_CONV was extended for the fields from "time_cycles"
linux/tools/perf/util/branch.c:21:	if (flags->type == PERF_BR_UNKNOWN || from == 0)
linux/tools/perf/util/stat-display.c:1331:			"The events in group usually have to be from "
linux/tools/perf/util/header.c:4443:	 * data from 'fd' so we need to set it directly behind the
linux/tools/perf/util/probe-file.c:478:		pr_debug("Failed to get build-id from %s.\n", target);
linux/tools/perf/util/probe-file.c:496:		pr_debug("Failed to get cache from %s\n", target);
linux/tools/perf/util/probe-finder.h:84:	/* Call Frame Information from .eh_frame */
linux/tools/perf/util/probe-finder.h:86:	/* Call Frame Information from .debug_frame */
linux/tools/perf/util/symbol-elf.c:2424:	from = open(from_filename, O_RDONLY);
linux/tools/perf/util/symbol-elf.c:2425:	if (from < 0)
linux/tools/perf/util/dwarf-aux.c:522: * Trace DIE tree from @rt_die and call @callback for each child DIE.
linux/tools/perf/util/print-events.c:59: * Print the events from <debugfs_mount_point>/tracing/events
linux/tools/perf/util/ordered-events.c:131:	 *   - use recently removed object from 'cache' list
linux/tools/perf/util/cs-etm.c:1129:	 * determine how many branches to copy from ->entries.
linux/tools/perf/util/cs-etm.c:1242:	be->from = cs_etm__last_executed_instr(tidq->prev_packet);
linux/tools/perf/util/cs-etm.c:1495:				.from = sample.ip,
linux/tools/perf/util/cs-etm.c:2790:	/* Override timeless mode with user input from --itrace=Z */
linux/tools/perf/util/machine.c:1170:/* Figure out the start address of kernel map from /proc/kallsyms.
linux/tools/perf/util/machine.c:2440:		} else if (l[chash[h]].from == l[i].from) {
linux/tools/perf/util/machine.c:2445:				if (l[j].from != l[i + off].from) {
linux/tools/perf/util/machine.c:2704:		if ((prev_entries[i].from != cur_entries[j].from) ||
linux/tools/perf/util/machine.c:2962:				else if (be[i].from < chain->ips[first_call] &&
linux/tools/perf/util/machine.c:2963:				    be[i].from >= chain->ips[first_call] - 8)
linux/tools/perf/util/mmap.c:179:			 * Use cblock.aio_fildes value different from -1
linux/tools/perf/util/synthetic-events.c:1117:	 * We should get this from /sys/kernel/sections/.text, but till that is
linux/tools/perf/util/util.c:356:		pr_debug("Reading from /proc/version_signature failed: %s\n",
linux/tools/perf/util/util.c:370:		pr_debug("Unable to get kernel version from /proc/version_signature '%s'\n",
linux/tools/perf/util/metricgroup.c:959:		 * from 'pe' object, so they never go away. We don't
linux/tools/perf/util/evlist-hybrid.c:69:			pr_warning("WARNING: events in group from "
linux/tools/perf/util/intel-pt.c:1768:				.from = sample.ip,
linux/tools/perf/util/intel-pt.c:2196:		const u64 *from = items->val[i];
linux/tools/perf/util/intel-pt.c:2198:		for (; mask; mask >>= 3, from += 3) {
linux/tools/perf/util/map.c:217: * Constructor variant for modules (where we know from /proc/modules where
linux/tools/perf/util/llvm-utils.c:372:"WARNING:\tunable to get kernel include directories from '%s'\n"
linux/tools/perf/util/config.c:551:	 *   - there is no place to read it from (HOME)
linux/tools/perf/util/intel-bts.c:427:		if (!branch->from && !branch->to)
linux/tools/perf/util/thread-stack.c:68: * struct thread_stack - thread stack constructed from 'call' and 'return'
linux/tools/perf/util/thread-stack.c:394:	be->from        = from_ip;
linux/tools/perf/util/thread-stack.c:666:			 be->from < kernel_start ||
linux/tools/perf/builtin-record.c:2227:		pr_warning("threads[%d]: failed to receive termination notification from %d\n",
linux/tools/perf/builtin-record.c:2276:			pr_warning("threads[%d]: failed to receive start notification from %d\n",
linux/tools/perf/builtin-sched.c:886:	pr_debug(" ... switch from %s/%d to %s/%d [ran %" PRIu64 " nsecs]\n",
linux/tools/perf/builtin-sched.c:3267:		pr_err("failed to get cpus map from %s\n", sched->map.cpus_str);
linux/tools/perf/builtin-sched.c:3284:		pr_err("failed to get thread map from %s\n", sched->map.color_pids_str);
linux/tools/perf/builtin-sched.c:3301:		pr_err("failed to get thread map from %s\n", sched->map.color_cpus_str);
linux/tools/perf/dlfilters/dlfilter-test-api-v0.c:98:	/* Return arguments from --dlarg option */
linux/tools/perf/arch/arm/util/cs-etm.c:773:	/* Where the next CPU entry should start from */
linux/tools/perf/arch/s390/util/machine.c:27:		 * (from /proc/modules) and module text segment start
linux/tools/iio/iio_generic_buffer.c:693:			perror("Reading from '%s' should not be possible after ioctl()");
linux/tools/power/x86/intel-speed-select/isst-daemon.c:71:	debug_printf("**Config level change for cpu:%d pkg:%d die:%d from %d to %d\n",
linux/tools/power/cpupower/utils/helpers/helpers.h:94: * Extract CPU vendor, family, model, stepping info from /proc/cpuinfo
linux/tools/power/cpupower/utils/helpers/cpuid.c:40: * Extract CPU vendor, family, model, stepping info from /proc/cpuinfo
linux/tools/power/cpupower/utils/helpers/sysfs.c:119: * helper function to read file from /sys into given buffer
linux/tools/power/cpupower/utils/helpers/sysfs.c:381: * helper function to read file from /sys into given buffer
linux/tools/power/cpupower/lib/cpufreq.c:21:/* helper function to read file from /sys into given buffer */
linux/tools/power/cpupower/lib/cpuidle.c:45: * helper function to read file from /sys into given buffer
linux/tools/power/cpupower/lib/cpuidle.c:311: * helper function to read file from /sys into given buffer
linux/tools/power/acpi/tools/ec/ec_access.c:134:		err(EXIT_FAILURE, "Could not read from %s\n", SYSFS_PATH);
linux/tools/power/acpi/tools/ec/ec_access.c:157:		err(EXIT_FAILURE, "Could not read from %s\n", SYSFS_PATH);
linux/tools/power/acpi/tools/ec/ec_access.c:186:		err(EXIT_FAILURE, "Could not read byte 0x%.2x from %s\n",
linux/tools/power/pm-graph/sleepgraph.py:4685:		rtitle = 'time from %s mode to kernel resume complete [%s time]' % \
linux/tools/lib/bpf/btf.h:154: * @brief **btf__add_btf()** appends all the BTF types from *src_btf* into *btf*
linux/tools/lib/bpf/btf.c:953:		pr_warn("failed to get EHDR from %s\n", path);
linux/tools/lib/bpf/btf.c:964:		pr_warn("failed to get e_shstrndx from %s\n", path);
linux/tools/lib/bpf/btf.c:974:			pr_warn("failed to get section(%d) header from %s\n",
linux/tools/lib/bpf/btf.c:980:			pr_warn("failed to get section(%d) name from %s\n",
linux/tools/lib/bpf/btf.c:987:				pr_warn("failed to get section(%d, %s) data from %s\n",
linux/tools/lib/bpf/btf.c:995:				pr_warn("failed to get section(%d, %s) data from %s\n",
linux/tools/lib/bpf/btf.c:2908: * is provided, all the strings referenced from .BTF.ext section are honored
linux/tools/lib/bpf/btf.c:3941: * except referenced type IDs is exactly the same), a mapping from `canon_id` to
linux/tools/lib/bpf/usdt.c:555:	/* for VMA segments from /proc/<pid>/maps file, provided "address" is
linux/tools/lib/bpf/usdt.c:1086:/* Parse out USDT ELF note from '.note.stapsdt' section.
linux/tools/lib/bpf/linker.c:623:			pr_warn_elf("failed to get section #%zu (%s) data from %s",
linux/tools/lib/bpf/linker.c:659:					pr_warn("failed to parse .BTF from %s: %d\n", filename, err);
linux/tools/lib/bpf/linker.c:669:					pr_warn("failed to parse .BTF.ext from '%s': %d\n", filename, err);
linux/tools/lib/bpf/linker.c:2168:			 * from .extern BTF section and might end up not
linux/tools/lib/bpf/linker.c:2450:			pr_warn("can't find section '%s' referenced from .BTF.ext\n", sec_name);
linux/tools/lib/bpf/linker.c:2479:			pr_warn("can't find section '%s' referenced from .BTF.ext\n", sec_name);
linux/tools/lib/bpf/linker.c:2521:			pr_warn("can't find section '%s' referenced from .BTF.ext\n", sec_name);
linux/tools/lib/bpf/libbpf.c:466:	 * from "data".
linux/tools/lib/bpf/libbpf.c:1353:		pr_warn("elf: failed to get ELF header from %s: %s\n", obj->path, elf_errmsg(-1));
linux/tools/lib/bpf/libbpf.c:1367:		pr_warn("elf: failed to get section names strings from %s: %s\n",
linux/tools/lib/bpf/libbpf.c:3176:		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
linux/tools/lib/bpf/libbpf.c:3190:		pr_warn("elf: failed to get section name string at offset %zu from %s: %s\n",
linux/tools/lib/bpf/libbpf.c:3204:		pr_warn("elf: failed to get section(%zu) from %s: %s\n",
linux/tools/lib/bpf/libbpf.c:3239:		pr_warn("elf: failed to get section(%zu) header from %s: %s\n",
linux/tools/lib/bpf/libbpf.c:3261:		pr_warn("elf: failed to get section(%zu) name from %s: %s\n",
linux/tools/lib/bpf/libbpf.c:3278:		pr_warn("elf: failed to get section(%zu) %s data from %s: %s\n",
linux/tools/lib/bpf/libbpf.c:7993:	pr_debug("prog '%s': unpinned from '%s'\n", prog->name, path);
linux/tools/lib/bpf/libbpf.c:8009:			pr_warn("map '%s' already has pin path '%s' different from '%s'\n",
linux/tools/lib/bpf/libbpf.c:8069:			pr_warn("map '%s' already has pin path '%s' different from '%s'\n",
linux/tools/lib/bpf/libbpf.c:8089:	pr_debug("unpinned map '%s' from '%s'\n", bpf_map__name(map), path);
linux/tools/lib/bpf/libbpf.c:9325:	 * This check distinguishes .data/.rodata from .data.* and .rodata.*
linux/tools/lib/bpf/libbpf.c:9817:	pr_debug("link fd=%d: unpinned from %s\n", link->fd, link->pin_path);
linux/tools/lib/bpf/libbpf.c:10723:		pr_warn("elf: failed to get ehdr from %s: %s\n", binary_path, elf_errmsg(-1));
linux/tools/lib/bpf/libbpf.c:10869:		pr_warn("elf: could not read elf from %s: %s\n", binary_path, elf_errmsg(-1));
linux/tools/lib/bpf/libbpf.c:10922:		pr_warn("elf: could not read elf file %s from %s: %s\n", file_name, archive_path,
linux/tools/lib/bpf/libbpf.c:12489:		pr_warn("Failed to read cpu mask from %s: %d\n", fcpu, err);
linux/tools/lib/bpf/bpf_helpers.h:345: * provided integer variable *i* to values starting from *start* through,
linux/tools/lib/string.c:119: * skip_spaces - Removes leading whitespace from @str.
linux/tools/lib/string.c:132: * strim - Removes leading and trailing whitespace from @s.
linux/tools/debugging/kernel-chktaint:16:retrieved from /proc/sys/kernel/tainted on another system.
linux/tools/testing/kunit/kunit_kernel.py:183:			diff_str = '\n\n'.join(f'{a}\n  vs from {path}\n{b}' for a, b in diff)
linux/tools/testing/kunit/kunit.py:162:		# That only happens after we get the last line of output from `run_result`.
linux/tools/testing/kunit/qemu_configs/arm.py:1:from ..qemu_config import QemuArchParams
linux/tools/testing/kunit/qemu_configs/alpha.py:1:from ..qemu_config import QemuArchParams
linux/tools/testing/kunit/qemu_configs/s390.py:1:from ..qemu_config import QemuArchParams
linux/tools/testing/kunit/qemu_configs/arm64.py:1:from ..qemu_config import QemuArchParams
linux/tools/testing/kunit/qemu_configs/i386.py:1:from ..qemu_config import QemuArchParams
linux/tools/testing/kunit/qemu_configs/m68k.py:2:from ..qemu_config import QemuArchParams
linux/tools/testing/kunit/qemu_configs/riscv.py:1:from ..qemu_config import QemuArchParams
linux/tools/testing/kunit/qemu_configs/x86_64.py:1:from ..qemu_config import QemuArchParams
linux/tools/testing/kunit/qemu_configs/powerpc.py:1:from ..qemu_config import QemuArchParams
linux/tools/testing/kunit/qemu_configs/sparc.py:1:from ..qemu_config import QemuArchParams
linux/tools/testing/kunit/qemu_configs/sh.py:2:from ..qemu_config import QemuArchParams
linux/tools/testing/nvdimm/test/nfit.c:3012:	/* test ars_status with 'status' trimmed from 'out_length' */
linux/tools/testing/selftests/livepatch/test-livepatch.sh:13:# - load a livepatch that modifies the output from /proc/cmdline and
linux/tools/testing/selftests/livepatch/test-livepatch.sh:48:# - load a livepatch that modifies the output from /proc/cmdline and
linux/tools/testing/selftests/livepatch/test-livepatch.sh:108:# - load a livepatch that modifies the output from /proc/cmdline and
linux/tools/testing/selftests/memfd/run_hugetlbfs_test.sh:14:# Get count of free huge pages from /proc/meminfo
linux/tools/testing/selftests/bpf/benchs/bench_bpf_hashmap_lookup.c:266:			       " (approximated from %d samples of ~%lums)\n",
linux/tools/testing/selftests/bpf/test_bpftool_synctypes.py:613:            f'Comparing common options from {main_hdr_info.filename} (HELP_SPEC_OPTIONS) and {man_substitutions.filename}:')
linux/tools/testing/selftests/bpf/test_verifier.c:1721:	unsigned int from = 0, to = ARRAY_SIZE(tests);
linux/tools/testing/selftests/bpf/test_verifier.c:1743:			from = l;
linux/tools/testing/selftests/bpf/test_verifier.c:1750:			from = t;
linux/tools/testing/selftests/bpf/xdping.c:56:		printf("64 bytes from %s: icmp_seq=%d ttl=64 time=%#.5f ms\n",
linux/tools/testing/selftests/bpf/trace_helpers.c:265:/* Reads binary from *path* file and returns it in the *build_id* buffer
linux/tools/testing/selftests/bpf/progs/test_stacktrace_map.c:41:/* taken from /sys/kernel/tracing/events/sched/sched_switch/format */
linux/tools/testing/selftests/bpf/progs/test_tracepoint.c:7:/* taken from /sys/kernel/tracing/events/sched/sched_switch/format */
linux/tools/testing/selftests/bpf/progs/verifier_jeq_infer_not_null.c:26: * The test verifies that relation r0 == r7 is propagated from (b) to (c).
linux/tools/testing/selftests/bpf/test_loader.c:127:		PRINT_FAIL("failed to parse %s from '%s'\n", name, str);
linux/tools/testing/selftests/bpf/veristat.c:1771:		fprintf(stderr, "Failed to parse stats from '%s': %d\n", env.filenames[0], err);
linux/tools/testing/selftests/bpf/veristat.c:1777:		fprintf(stderr, "Failed to parse stats from '%s': %d\n", env.filenames[1], err);
linux/tools/testing/selftests/bpf/veristat.c:2021:		fprintf(stderr, "Failed to parse stats from '%s': %d\n", env.filenames[0], err);
linux/tools/testing/selftests/bpf/prog_tests/bpf_iter.c:1445:	/* read CMP_BUFFER_SIZE (1kB) from /proc/pid/maps */
linux/tools/testing/selftests/bpf/prog_tests/btf.c:7214:			/* int, referenced from [5] */
linux/tools/testing/selftests/bpf/prog_tests/linked_vars.c:34:	/* 10 comes from "winner" input_data_weak in first obj file */
linux/tools/testing/selftests/bpf/prog_tests/linked_vars.c:37:	/* 100 comes from "winner" input_rodata_weak in first obj file */
linux/tools/testing/selftests/bpf/prog_tests/core_reloc.c:551:		.btf_src_file = NULL, /* load from /lib/modules/$(uname -r) */
linux/tools/testing/selftests/bpf/prog_tests/cgroup_attach_override.c:74:		  "detach prog from %s failed, errno=%d\n", BAR, errno))
linux/tools/testing/selftests/bpf/prog_tests/cgroup_attach_override.c:89:		  "detach prog from %s failed, errno=%d\n", FOO, errno))
linux/tools/testing/selftests/bpf/prog_tests/cgroup_attach_override.c:108:		  "detach prog from %s failed, errno=%d\n", BAR, errno))
linux/tools/testing/selftests/bpf/prog_tests/cgroup_attach_override.c:113:		  "double detach from %s unexpectedly succeeded\n", FOO))
linux/tools/testing/selftests/bpf/prog_tests/align.c:646:					sscanf(line_ptr, "from %u to %u: ", &tmp, &cur_line);
linux/tools/testing/selftests/arm64/fp/vec-syscfg.c:73:		ksft_print_msg("failed to parse integer from %s\n", what);
linux/tools/testing/selftests/arm64/fp/za-fork-asm.S:30:	_ldr_za 12, 0			// ZA.H[W12] loaded from [X0]
linux/tools/testing/selftests/arm64/fp/zt-ptrace.c:224:			ksft_print_msg("VL changed from %d to %d\n",
linux/tools/testing/selftests/arm64/fp/fpsimd-test.S:31:// x1 is the memory address to read from (getv,setp) or store to (setv,setp)
linux/tools/testing/selftests/arm64/fp/sve-test.S:43:// x1 is the memory address to read from (getz,setp) or store to (setz,setp)
linux/tools/testing/selftests/arm64/signal/testcases/testcases.c:304: *	    head pointer from @shead
linux/tools/testing/selftests/arm64/signal/testcases/fake_sigreturn_sve_change_vl.c:77:	fprintf(stderr, "Attempting to change VL from %d to %d\n",
linux/tools/testing/selftests/arm64/signal/testcases/fake_sigreturn_sme_change_vl.c:75:	fprintf(stderr, "Attempting to change VL from %d to %d\n",
linux/tools/testing/selftests/arm64/mte/mte_common_util.h:89:		ksft_test_result_error("Unknown return code %d from %s",
linux/tools/testing/selftests/capabilities/test_execve.c:156:	int from = openat(fromfd, fromname, O_RDONLY);
linux/tools/testing/selftests/capabilities/test_execve.c:157:	if (from == -1)
linux/tools/testing/selftests/kvm/access_tracking_perf_test.c:85:		    "pread from %s offset 0x%" PRIx64 " failed!",
linux/tools/testing/selftests/kvm/lib/x86_64/handlers.S:53:	.rept \to - \from + 1
linux/tools/testing/selftests/kvm/x86_64/xapic_ipi_test.c:295:	from = 0;
linux/tools/testing/selftests/kvm/x86_64/xapic_ipi_test.c:328:		from = to;
linux/tools/testing/selftests/mqueue/mq_open_tests.c:354:		printf("Kernel supports setting defaults separately from "
linux/tools/testing/selftests/cpufreq/module.sh:136:	printf "Switch from $CUR_GOV to $1\n"
linux/tools/testing/selftests/cpufreq/module.sh:150:	printf "Switchback to $CUR_GOV from $1\n"
linux/tools/testing/selftests/media_tests/media_dev_allocator.sh:19:echo "Running unbind of $MDEV from $MDRIVER"
linux/tools/testing/selftests/media_tests/media_dev_allocator.sh:28:echo "Running unbind of $ADEV from $ADRIVER"
linux/tools/testing/selftests/media_tests/media_dev_allocator.sh:38:echo "Running bind of $MDEV from $MDRIVER"
linux/tools/testing/selftests/media_tests/media_dev_allocator.sh:44:echo "Running bind of $ADEV from $ADRIVER"
linux/tools/testing/selftests/media_tests/media_dev_allocator.sh:56:echo "Running unbind of $MDEV from $MDRIVER"
linux/tools/testing/selftests/media_tests/media_dev_allocator.sh:64:echo "Running bind of $MDEV from $MDRIVER"
linux/tools/testing/selftests/media_tests/media_dev_allocator.sh:70:echo "Running unbind of $ADEV from $ADRIVER"
linux/tools/testing/selftests/media_tests/media_dev_allocator.sh:78:echo "Running bind of $ADEV from $ADRIVER"
linux/tools/testing/selftests/cgroup/test_memcontrol.c:670: * Reclaim from @memcg until usage reaches @goal by writing to
linux/tools/testing/selftests/proc/read.c:44:	/* read from /proc/kmsg can block */
linux/tools/testing/selftests/proc/fd-003-kthread.c:162:	 * from /proc.
linux/tools/testing/selftests/proc/proc-pid-vm.c:24: * FIXME test other values from "smaps"
linux/tools/testing/selftests/tc-testing/tdc_multibatch.py:39:    help="start handle range from (default: 1)")
linux/tools/testing/selftests/tc-testing/tdc_batch.py:21:    help="start handle range from (default: 1)")
linux/tools/testing/selftests/powerpc/nx-gzip/gunz_test.c:417:	/* Read from .gz file */
linux/tools/testing/selftests/powerpc/mm/pkey_exec_prot.c:180:	printf("read from %p, pkey permissions are %s\n", fault_addr,
linux/tools/testing/selftests/powerpc/mm/pkey_exec_prot.c:218:	printf("read from %p, pkey permissions are %s\n", fault_addr,
linux/tools/testing/selftests/nolibc/Makefile:113:	@echo "  QEMU_ARCH     = $(if $(QEMU_ARCH),$(QEMU_ARCH),UNKNOWN_ARCH) [determined from \$$ARCH]"
linux/tools/testing/selftests/nolibc/Makefile:114:	@echo "  IMAGE_NAME    = $(if $(IMAGE_NAME),$(IMAGE_NAME),UNKNOWN_ARCH) [determined from \$$ARCH]"
linux/tools/testing/selftests/nolibc/nolibc-test.c:748:	 * we need to reopen it from /dev/console. If it failed above, it will
linux/tools/testing/selftests/ftrace/test.d/functions:176:# The fork function in the kernel was renamed from "_do_fork" to
linux/tools/testing/selftests/hid/tests/test_apple_keyboard.py:9:from .test_keyboard import ArrayKeyboard, TestArrayKeyboard
linux/tools/testing/selftests/hid/tests/test_tablet.py:9:from . import base
linux/tools/testing/selftests/hid/tests/test_tablet.py:87:        ), f"moving from {self} to {new_state} is forbidden"
linux/tools/testing/selftests/hid/tests/test_usb_crash.py:11:from . import base
linux/tools/testing/selftests/hid/tests/test_keyboard.py:9:from . import base
linux/tools/testing/selftests/hid/tests/test_wacom_generic.py:21:from .descriptors_wacom import (
linux/tools/testing/selftests/hid/tests/test_wacom_generic.py:33:from . import base
linux/tools/testing/selftests/hid/tests/test_ite_keyboard.py:9:from .test_keyboard import ArrayKeyboard, TestArrayKeyboard
linux/tools/testing/selftests/hid/tests/test_mouse.py:9:from . import base
linux/tools/testing/selftests/hid/tests/test_gamepad.py:9:from . import base
linux/tools/testing/selftests/hid/tests/test_sony.py:9:from .base import application_matches
linux/tools/testing/selftests/hid/tests/test_sony.py:10:from .test_gamepad import BaseTest
linux/tools/testing/selftests/hid/tests/test_multitouch.py:9:from . import base
linux/tools/testing/selftests/hid/tests/test_hid_core.py:24:from . import base
linux/tools/testing/selftests/hid/tests/conftest.py:13:from .base import HIDTestUdevRule
linux/tools/testing/selftests/rcutorture/bin/kvm-remote.sh:269:	echo " ---" Collecting results from $i `date` | tee -a "$oldrun/remote-log"
linux/tools/testing/selftests/rcutorture/bin/torture.sh:360:		echo " --- Summary: Exit code $retcode from $buildphase, see Make.out" >> $amcdir/log
linux/tools/testing/selftests/rcutorture/bin/kvm-test-1-run.sh:148:	echo CPU count limited from $cpu_count to $TORTURE_ALLOTED_CPUS | tee -a $resdir/Warnings
linux/tools/testing/selftests/rcutorture/bin/kvm-again.sh:179:	echo "Cannot copy from $oldrun to $rundir."
linux/tools/testing/selftests/netfilter/nft_queue.sh:433:# we ping ${ns2} from ${ns1} via ${nsrouter} using ipv4 and ipv6, so:
linux/tools/testing/selftests/netfilter/nft_concat_range.sh:1159:# Return packet count from 'test' counter in 'inet filter' table
linux/tools/testing/selftests/netfilter/nft_concat_range.sh:1168:# Return packet count from 'test' counter in 'netdev perf' table
linux/tools/testing/selftests/netfilter/nft_nat_zones.sh:231:     echo FAIL: Ping failure from $cl 1>&2
linux/tools/testing/selftests/netfilter/nft_nat.sh:429:		echo "ERROR: cannot ping $ns1 from $ns2 via ipv6"
linux/tools/testing/selftests/netfilter/nft_nat.sh:467:		echo "ERROR: cannot ping $ns1 from $ns2 with active $family masquerade $natflags"
linux/tools/testing/selftests/netfilter/nft_nat.sh:505:		echo "ERROR: cannot ping $ns1 from $ns2 with active ipv6 masquerade $natflags (attempt 2)"
linux/tools/testing/selftests/netfilter/nft_nat.sh:531:		echo "ERROR: cannot ping $ns1 from "$ns2" $natflags"
linux/tools/testing/selftests/netfilter/nft_nat.sh:568:		echo "ERROR: cannot ping $ns1 from $ns2 with active $family masquerade $natflags"
linux/tools/testing/selftests/netfilter/nft_nat.sh:606:		echo "ERROR: cannot ping $ns1 from $ns2 with active ip masquerade $natflags (attempt 2)"
linux/tools/testing/selftests/netfilter/nft_nat.sh:630:		echo "ERROR: cannnot ping $ns1 from $ns2 via ipv6"
linux/tools/testing/selftests/netfilter/nft_nat.sh:667:		echo "ERROR: cannot ping $ns1 from $ns2 via ipv6 with active $family redirect"
linux/tools/testing/selftests/netfilter/nft_nat.sh:712:		echo "ERROR: cannot ping $ns1 from $ns2"
linux/tools/testing/selftests/netfilter/nft_nat.sh:749:		echo "ERROR: cannot ping $ns1 from $ns2 with active $family ip redirect"
linux/tools/testing/selftests/netfilter/nft_nat.sh:820:		echo "PASS: portshadow test $test: got reply from ${expect}${logmsg}"
linux/tools/testing/selftests/netfilter/nft_nat.sh:822:		echo "ERROR: portshadow test $test: got reply from \"$result\", not $expect as intended"
linux/tools/testing/selftests/netfilter/nft_nat.sh:951:		echo "ERROR: cannot ping $ns1 from $ns2 before loading stateless rules"
linux/tools/testing/selftests/netfilter/nft_nat.sh:986:		echo "ERROR: cannot ping $ns1 from $ns2 with stateless rules"
linux/tools/testing/selftests/netfilter/nft_nat.sh:990:	# ns1 should have seen packets from .2.2, due to stateless rewrite.
linux/tools/testing/selftests/kselftest.h:217:/* TODO: how does "error" differ from "fail" or "skip"? */
linux/tools/testing/selftests/mm/hmm-tests.c:734: * /proc and /sys data (without a tag) and from /proc/meminfo (with a tag).
linux/tools/testing/selftests/mm/run_vmtests.sh:88:# get huge pagesize and freepages from /proc/meminfo
linux/tools/testing/selftests/mm/protection_keys.c:391:	dprintf1("signal pkey_reg from  pkey_reg: %016llx\n",
linux/tools/testing/selftests/mm/compaction_test.c:102:		perror("Failed to read from /proc/sys/vm/nr_hugepages");
linux/tools/testing/selftests/mm/compaction_test.c:124:		perror("Failed to re-read from /proc/sys/vm/nr_hugepages\n");
linux/tools/testing/selftests/pidfd/pidfd_getfd_test.c:123:	/* pid points to the child which we are fetching FDs from */
linux/tools/testing/selftests/kselftest_harness.h:1191:	ksft_print_msg("Starting %u tests from %u test cases.\n",
linux/tools/testing/selftests/net/icmp.sh:69:    echo "FAIL - got ICMP response from $RESP_IP, should be 192.0.0.8"
linux/tools/testing/selftests/net/fcnal-test.sh:634:	setup_cmd ip rule add pref 51 from ${NSB_IP} prohibit
linux/tools/testing/selftests/net/fcnal-test.sh:655:	setup_cmd ip rule del pref 51 from ${NSB_IP} prohibit
linux/tools/testing/selftests/net/fcnal-test.sh:768:	setup_cmd ip rule add pref 51 from ${NSB_IP} prohibit
linux/tools/testing/selftests/net/fcnal-test.sh:786:	setup_cmd ip rule del pref 51 from ${NSB_IP} prohibit
linux/tools/testing/selftests/net/fcnal-test.sh:2229:	setup_cmd ip -6 rule add pref 51 from ${NSB_IP6} prohibit
linux/tools/testing/selftests/net/fcnal-test.sh:2248:	setup_cmd ip -6 rule del pref 51 from ${NSB_IP6} prohibit
linux/tools/testing/selftests/net/fcnal-test.sh:2383:	setup_cmd ip -6 rule add pref 51 from ${NSB_IP6} prohibit
linux/tools/testing/selftests/net/fcnal-test.sh:2401:	setup_cmd ip -6 rule del pref 51 from ${NSB_IP6} prohibit
linux/tools/testing/selftests/net/fib_rule_tests.sh:206:	match="from $SRC_IP6 iif $DEV"
linux/tools/testing/selftests/net/fib_rule_tests.sh:342:	match="from $SRC_IP iif $DEV"
linux/tools/testing/selftests/net/forwarding/router_broadcast.sh:174:	log_info "ping $dip, expected reply from $from"
linux/tools/testing/selftests/net/forwarding/router_broadcast.sh:177:		| grep "bytes from $from" > /dev/null
linux/tools/testing/selftests/net/rtnetlink.sh:246:	ip route get ::1 from ::1 iif lo oif lo tos 0x10 mark 0x1 > /dev/null
linux/tools/testing/selftests/net/fib_nexthop_multiprefix.sh:212:		echo "    ${dst} from :: via ${r1} dev eth0 src ${h0} .* mtu ${mtu}"
linux/tools/testing/selftests/net/fib_nexthop_multiprefix.sh:217:	grep -q "${dst} from :: via ${r1} dev eth0 src ${h0} .* mtu ${mtu}"
linux/tools/testing/selftests/net/toeplitz.sh:8:# irq-pattern-prefix can be derived from /sys/kernel/irq/*/action,
linux/tools/testing/selftests/net/timestamping.c:166:	printf("%ld.%06ld: received %s data, %d bytes from %s, %zu bytes control messages\n",
linux/tools/testing/selftests/openat2/resolve_test.c:332:		{ .name = "[no_xdev] jump to / (from /) directly",
linux/tools/testing/ktest/config-bisect.pl:251:    doprint "Reading configs from $config\n";
linux/tools/testing/ktest/config-bisect.pl:310:    doprint "Creating old config from $name configs\n";
linux/tools/testing/ktest/config-bisect.pl:466:# $sconfigs: The source to update $oconfigs with (from $phalf)
linux/tools/testing/ktest/ktest.pl:1409:	doprint("$name changed from '$old_option' to '$option'\n");
linux/tools/testing/ktest/ktest.pl:2591:    doprint "Loading force configs from $config\n";
linux/tools/testing/ktest/ktest.pl:3183:    doprint "Reading configs from $config\n";
linux/tools/testing/ktest/ktest.pl:3242:    doprint "Creating old config from $name configs\n";
linux/tools/testing/ktest/ktest.pl:3879:    doprint "Load initial configs from $start_minconfig\n";
linux/tools/leds/uledmon.c:53:			perror("Failed to read from /dev/uleds");
linux/tools/net/ynl/lib/ynl.py:10:from .nlspec import SpecFamily
linux/tools/net/ynl/lib/__init__.py:3:from .nlspec import SpecAttr, SpecAttrSet, SpecEnumEntry, SpecEnumSet, \
linux/tools/net/ynl/lib/__init__.py:5:from .ynl import YnlFamily
linux/tools/arch/x86/include/asm/asm.h:162:	" .long (" #from ") - .\n"				\
linux/block/genhd.c:85:	pr_info("%s: detected capacity change from %lld to %lld\n",
linux/block/blk-mq.c:2255: * Return prefered queue to dispatch from (if any) for non-mq aware IO
linux/block/blk-mq.c:2919: * Builds up a request structure from @q and @bio and send to the device. The
linux/block/blk-mq.c:4618:	/* q->elevator needs protection from ->sysfs_lock */
linux/block/blk-cgroup.c:559:	 * Both setting lookup hint to and clearing it from @blkg are done
linux/block/blk-cgroup.c:662: * is %true, the sum of the return values from @prfill is printed with
linux/block/blk-cgroup.c:776: * Parse per-blkg config update from @ctx->input and initialize @ctx
linux/block/holder.c:41: * - from "slaves" directory of the holder @disk to the claimed @bdev
linux/block/holder.c:42: * - from "holders" directory of the @bdev to the holder @disk
linux/block/bio.c:1234: * Pins pages from *iter and appends them to @bio's bvec array. The
linux/block/bfq-cgroup.c:372:/* @to += @from */
linux/block/blk-flush.c:223:	/* release the tag's ownership to the req cloned from */
linux/block/blk-iolatency.c:95:	 * from ->enable_work with the request_queue frozen. For details, See
linux/block/blk-throttle.c:46:/* We measure latency for request size from <= 4k to >= 1M */
linux/block/blk-throttle.c:295: * qnode is removed from @queued if empty or moved to the end of @queued so
linux/block/blk-throttle.c:1048:	 * @bio is being transferred from @tg to @parent_sq.  Popping a bio
linux/block/blk-throttle.c:1049:	 * from @tg may put its reference and @parent_sq might end up
linux/block/mq-deadline.c:306: * Skip all write requests that are sequential from @rq, even if we cross
linux/block/disk-events.c:146: * doesn't clear the events from @disk->ev.
linux/block/partitions/check.h:42:		p->parts[n].from = from;
linux/block/partitions/efi.c:232: * Description: Reads @count bytes from @state->disk into @buffer.
linux/block/partitions/efi.c:303: * and fills a GPT header starting at @ from @state->disk.
linux/block/partitions/efi.c:675: * Description: Converts @size UTF16-LE symbols from @in string to 7-bit
linux/block/partitions/cmdline.c:67:		new_subpart->from = (sector_t)memparse(partdef, &partdef);
linux/block/partitions/cmdline.c:69:		new_subpart->from = (sector_t)(~0ULL);
linux/block/partitions/cmdline.c:263:	put_partition(state, slot, subpart->from >> 9,
linux/block/partitions/cmdline.c:284:	sector_t from = 0;
linux/block/partitions/cmdline.c:290:		if (subpart->from == (sector_t)(~0ULL))
linux/block/partitions/cmdline.c:291:			subpart->from = from;
linux/block/partitions/cmdline.c:293:			from = subpart->from;
linux/block/partitions/cmdline.c:295:		if (from >= disk_size)
linux/block/partitions/cmdline.c:301:		from += subpart->size;
linux/block/partitions/cmdline.c:320:	sector_t end = from + size;
linux/block/partitions/cmdline.c:323:	if (from >= from2 && from < end2)
linux/block/partitions/cmdline.c:329:	if (from2 >= from && from2 < end)
linux/block/partitions/cmdline.c:332:	if (end2 > from && end2 <= end)
linux/block/partitions/cmdline.c:363:					(u64)state->parts[slot].from << 9,
linux/block/partitions/cmdline.c:366:					(u64)state->parts[i].from << 9,
linux/block/partitions/aix.c:76: * Description:  Reads @count bytes from @state->disk into @buffer.
linux/block/partitions/core.c:537:	sector_t from = state->parts[p].from;
linux/block/partitions/core.c:543:	if (from >= get_capacity(disk)) {
linux/block/partitions/core.c:552:	if (from + size > get_capacity(disk)) {
linux/block/blk-zoned.c:136: *    To report all zones in a device starting from @sector, the BLK_ALL_ZONES
linux/block/blk-ioc.c:86:	 * Both setting lookup hint to and clearing it from @icq are done
linux/block/blk-ioc.c:325: * Look up io_cq associated with @ioc - @q pair from @ioc.  Must be called
linux/block/blk-ioc.c:336:	 * icq's are indexed from @ioc using radix tree and hint pointer,
linux/block/blk-merge.c:193: * @offset: Offset from @start_page where to add a segment.
linux/block/blk-merge.c:216: *            by the number of segments from @bv that may be appended to that
linux/block/blk-merge.c:219: *            by the number of bytes from @bv that may be appended to that
linux/block/blk-merge.c:351: * The split bio is allocated from @q->bio_split, which is provided by the
linux/block/blk-merge.c:398: * The split bio is allocated from @q->bio_split, which is provided by the
linux/scripts/link-vmlinux.sh:186:# Create map file with all symbols from ${1}
linux/scripts/patch-kernel:214:	#echo "$PNAME: changing EXTRAVERSION from $EXTRAVERSION to $EXTRAVER"
linux/scripts/coccinelle/api/kstrdup.cocci:25:   ... when != \(from = E1 \| to = E1 \)
linux/scripts/coccinelle/api/kstrdup.cocci:27:   ... when != \(from = E2 \| to = E2 \)
linux/scripts/coccinelle/api/kstrdup.cocci:37:    ... when != \( x = E1 \| from = E1 \)
linux/scripts/coccinelle/api/kstrdup.cocci:40:    ... when != \(x = E2 \| from = E2 \| to = E2 \)
linux/scripts/coccinelle/api/kstrdup.cocci:42:    ... when != \(x = E3 \| from = E3 \| to = E3 \)
linux/scripts/coccinelle/api/kstrdup.cocci:55:   ... when != \(from = E1 \| to = E1 \)
linux/scripts/coccinelle/api/kstrdup.cocci:57:   ... when != \(from = E2 \| to = E2 \)
linux/scripts/coccinelle/api/kstrdup.cocci:68:    ... when != \( x = E1 \| from = E1 \)
linux/scripts/coccinelle/api/kstrdup.cocci:70:    ... when != \(x = E2 \| from = E2 \| to = E2 \)
linux/scripts/coccinelle/api/kstrdup.cocci:72:    ... when != \(x = E3 \| from = E3 \| to = E3 \)
linux/scripts/coccinelle/api/memdup.cocci:32:    ... when != \( x = E1 \| from = E1 \)
linux/scripts/Makefile.host:57:# Object (.o) files compiled from .c files
linux/scripts/Makefile.host:65:# C++ Object (.o) files compiled from .cc files
linux/scripts/clang-tools/gen_compile_commands.py:146:            # Read from *.mod, to get a list of objects that compose the module.
linux/scripts/clang-tools/gen_compile_commands.py:220:                        logging.info('Could not add line from %s: %s',
linux/scripts/kconfig/menu.c:124:		"ignoring type redefinition of '%s' from '%s' to '%s'",
linux/scripts/kconfig/confdata.c:1125:		 *	different from 'no').
linux/scripts/kconfig/tests/choice_value_with_m_dep/__init__.py:6:hidden when the choice containing them is changed from 'm' to 'y'
linux/scripts/kconfig/mconf.c:129:"saved settings from \".config\" without restarting Menuconfig.\n"
linux/scripts/Makefile.lib:84:# Primitive DTB compiled from *.dts
linux/scripts/check-sysctl-docs:50:    printf "* %s from %s", entry, file[entry]
linux/scripts/headerdep.pl:128:	printf "%s from %s,\n", $msg, $last->[1] if defined $last;
linux/scripts/headerdep.pl:131:		printf "%s from %s:%d%s\n",
linux/scripts/generate_rust_target.rs:109:    /// Parses `include/config/auto.conf` from `stdin`.
linux/scripts/generate_rust_target.rs:150:    // `llvm-target`s are taken from `scripts/Makefile.clang`.
linux/scripts/atomic/fallbacks/sub_and_test:7: * Atomically subtracts @i from @v and returns
linux/scripts/kernel-doc:1582:	# strip spaces from $param so that it is one continuous string
linux/scripts/mod/modpost.c:489:		 * read count from .sh_size.
linux/scripts/mod/modpost.c:677: * Parse tag=value strings from .modinfo section
linux/scripts/mod/modpost.c:1029: *   Whitelist all references from .head.text to any init section
linux/scripts/mod/modpost.c:1272:	from = find_elf_symbol2(elf, r->r_offset, fromsec);
linux/scripts/mod/modpost.h:120:	bool from_dump;		/* true if module was loaded from *.symvers */
linux/scripts/decodecode:112:# Match the maximum number of opcode bytes from @op_bytes contained within
linux/scripts/Makefile.build:137:# Generate .ll files from .c
linux/scripts/Makefile.build:163:# o compile a <file>.o from <file>.c
linux/scripts/dtc/util.c:294:		fprintf(stderr, "Couldn't open blob from '%s': %s\n", filename,
linux/scripts/dtc/checks.c:810:				  "#address-cells (%d) differs from %s (%d)",
linux/scripts/dtc/checks.c:815:				  "#size-cells (%d) differs from %s (%d)",
linux/scripts/dtc/checks.c:1447:			FAIL(c, dti, node, "Missing property '%s' in node %s or bad phandle (referred from %s[%d])",
linux/scripts/sphinx-pre-install:295:	die "Can't get needs_sphinx version from $conf" if (!$min_version);
linux/scripts/sphinx-pre-install:306:	die "Can't get default sphinx version from $requirement_file" if (!$default_version);
linux/scripts/Makefile.userprogs:12:# Objects compiled from .c files
linux/scripts/recordmcount.pl:54:# offset from .sched.text. If we choose global symbol func2 as a reference and
linux/lib/string_helpers.c:503: *	1. The character is not matched to the one from @only string and thus
linux/lib/string_helpers.c:546: *		append characters from @only to be escaped by the given classes
linux/lib/string_helpers.c:591:		 * When %ESCAPE_APPEND is passed, the characters from @only
linux/lib/string_helpers.c:846: * skip_spaces - Removes leading whitespace from @str.
linux/lib/string_helpers.c:860: * strim - Removes leading and trailing whitespace from @s.
linux/lib/zstd/decompress/zstd_decompress.c:2002:                        DEBUGLOG(4, "inBuff  : from %u to %u",
linux/lib/zstd/decompress/zstd_decompress.c:2004:                        DEBUGLOG(4, "outBuff : from %u to %u",
linux/lib/zstd/decompress/huf_decompress.c:861: * Fills the DTable rank with all the symbols from [begin, end) that are each
linux/lib/zstd/compress/zstd_opt.c:538:    DEBUGLOG(6, "ZSTD_updateTree_internal, from %u to %u  (dictMode:%u)",
linux/lib/zstd/compress/zstd_compress_internal.h:142:  size_t capacity;      /* The capacity starting from `seq` pointer */
linux/lib/zstd/compress/zstd_compress_internal.h:1139:            DEBUGLOG(5, "Update dictLimit to match lowLimit, from %u to %u",
linux/lib/zstd/compress/zstd_compress_internal.h:1189:    window->dictLimit = ZSTD_WINDOW_START_INDEX;    /* start from >0, so that 1st position is valid */
linux/lib/zstd/compress/zstd_lazy.c:37:        DEBUGLOG(7, "ZSTD_updateDUBT, from %u to %u (dictLimit:%u)",
linux/lib/zstd/compress/zstd_lazy.c:824: * value to reflect the update. Essentially cycles backwards from [0, {entries per row})
linux/lib/zstd/compress/zstd_compress.c:1813:                DEBUGLOG(4, "Resize workspaceSize from %zuKB to %zuKB",
linux/lib/zstd/compress/zstd_compress.c:3305:/* Derives the seqStore that is a chunk of the originalSeqStore from [startIdx, endIdx).
linux/lib/zstd/common/huf.h:224: * @return : size read from `src` , or an error Code .
linux/lib/zstd/common/huf.h:270: *  The space used depends on HUF_TABLELOG_MAX, ranging from ~1500 bytes when
linux/lib/zstd/common/fse.h:226:    Read compactly saved 'normalizedCounter' from 'rBuffer'.
linux/lib/zstd/common/fse.h:227:    @return : size read from 'rBuffer',
linux/lib/zstd/common/fse.h:272:The result of FSE_readNCount() is the number of bytes read from 'rBuffer'.
linux/lib/zstd/common/fse.h:276:The next step is to build the decompression tables 'FSE_DTable' from 'normalizedCounter'.
linux/lib/zstd/common/entropy_common.c:248:    @return : size read from `src` , or an error Code .
linux/lib/zlib_deflate/deftree.c:415:     * from 'ar' written by Haruhiko Okumura.)
linux/lib/bitmap.c:202: *                          from @src)
linux/lib/kfifo.c:196:		ret = copy_from_user(fifo->data, from + l, len - l);
linux/lib/sort.c:222:	/* called from 'sort' without swap function, let's pick the default */
linux/lib/sort.c:269:		/* Now backtrack from "b" to the correct location for "a" */
linux/lib/zlib_inflate/inflate.h:95:    unsigned offset;            /* distance back to copy string from */
linux/lib/zlib_inflate/inffast.c:93:    unsigned char *from;        /* where to copy match from */
linux/lib/zlib_inflate/inffast.c:187:                    from = window;
linux/lib/zlib_inflate/inffast.c:189:                        from += wsize - op;
linux/lib/zlib_inflate/inffast.c:195:                            from = out - dist;  /* rest from output */
linux/lib/zlib_inflate/inffast.c:199:                        from += wsize + write - op;
linux/lib/zlib_inflate/inffast.c:206:                            from = window;
linux/lib/zlib_inflate/inffast.c:213:                                from = out - dist;      /* rest from output */
linux/lib/zlib_inflate/inffast.c:218:                        from += write - op;
linux/lib/zlib_inflate/inffast.c:224:                            from = out - dist;  /* rest from output */
linux/lib/zlib_inflate/inffast.c:243:                    from = out - dist;          /* copy direct from output */
linux/lib/zlib_inflate/inffast.c:263:			from = (unsigned char *)sfrom;
linux/lib/zlib_inflate/inflate.c:341:    unsigned char *from;        /* where to copy match bytes from */
linux/lib/zlib_inflate/inflate.c:680:                    from = state->window + (state->wsize - copy);
linux/lib/zlib_inflate/inflate.c:683:                    from = state->window + (state->write - copy);
linux/lib/zlib_inflate/inflate.c:687:                from = put - state->offset;
linux/lib/test_maple_tree.c:741:		pr_debug("Search from %lu-%lu for gap %lu should be at %lu\n",
linux/lib/crypto/sha1.c:98:	/* Round 1 - iterations 0-16 take their input from 'data' */
linux/lib/crypto/utils.c:13: * XOR @len bytes from @src1 and @src2 together, writing the result to @dst
linux/lib/crypto/curve25519-fiat32.c:26: * Addition and subtraction produce fe_loose from (fe, fe).
linux/lib/vsprintf.c:3197: * arguments from stack, and bstr_printf gets arguments from @bin_buf which is
linux/lib/bch.c:1017: * @calc_ecc: calculated ecc, if NULL then calc_ecc is computed from @data
linux/lib/usercopy.c:65:	uintptr_t align = (uintptr_t) from % sizeof(unsigned long);
linux/lib/usercopy.c:70:	from -= align;
linux/lib/usercopy.c:84:		from += sizeof(unsigned long);
linux/lib/stackdepot.c:426:			 * smp_load_acquire() from |bucket| above.
linux/lib/xarray.c:1485: * After this function returns, loading from @index will return %NULL.
linux/lib/xarray.c:1504: * After this function returns, loading from @index will return %NULL.
linux/lib/buildid.c:168: * @build_id: Build ID parsed from @buf, at least BUILD_ID_SIZE_MAX long
linux/lib/kobject.c:275:	 * returned something from .rodata.
linux/lib/parser.c:66:		args[argc].from = s;
linux/lib/cmdline.c:38: *	@pint: (optional output) integer value parsed from @str
linux/lib/scatterlist.c:98: *   exist from @sgl@.
linux/lib/test_firmware.c:1123: * This table is replicated from .../firmware_loader/sysfs_upload.c
linux/lib/mpi/generic_mpih-sub1.c:26:	/* The loop counter and index J goes from -SIZE to -1.  This way
linux/lib/mpi/generic_mpih-mul1.c:27:	/* The loop counter and index J goes from -S1_SIZE to -1.  This way
linux/lib/mpi/generic_mpih-mul3.c:28:	/* The loop counter and index J goes from -SIZE to -1.  This way
linux/lib/mpi/generic_mpih-mul2.c:28:	/* The loop counter and index J goes from -SIZE to -1.  This way
linux/lib/mpi/generic_mpih-add1.c:27:	/* The loop counter and index J goes from -SIZE to -1.  This way
linux/lib/inflate.c:1142: * Code to compute the CRC-32 table. Borrowed from 
linux/lib/lru_cache.c:296: * @e must be unused (refcnt == 0). Moves @e from "lru" to "free" list,
linux/lib/genalloc.c:77: * Set @nr bits start from @start in @map lock-lessly. Several users
linux/lib/genalloc.c:113: * Clear @nr bits start from @start in @map lock-lessly. Several users
linux/lib/test_rhashtable.c:743:	pr_info("Testing concurrent rhashtable access from %d threads\n",
linux/lib/maple_tree.c:2746: * is taken from @mast->l.
linux/lib/maple_tree.c:3001: * Follow the tree upwards from @l_mas and @r_mas for @count, or until the root
linux/drivers/cxl/cxlmem.h:104: * @size_in: (input) Number of bytes to load from @payload_in.
linux/drivers/cxl/pmem.c:347:		dev_dbg(&cxlr->dev, "changing target node from %d to %d",
linux/drivers/cxl/core/port.c:1270:		dev_dbg(&cxlmd->dev, "disconnect %s from %s\n",
linux/drivers/cxl/core/trace.h:154:	TP_printk("memdev=%s host=%s serial=%lld: log=%s : %u records from %llu to %llu",
linux/drivers/parisc/superio.c:347:	printk(KERN_DEBUG "superio_fixup_irq(%s) ven 0x%x dev 0x%x from %ps\n",
linux/drivers/parisc/dino.c:462:	printk(KERN_INFO "PCI: Cirrus Cardbus IRQ fixup for %s, from %d to %d\n",
linux/drivers/parisc/led.c:12: *	- interface to write to second row of LCD from /proc (if technically possible)
linux/drivers/parisc/iosapic_private.h:66:	/* Source Bus ID identifies the bus where interrupt signal comes from */
linux/drivers/parisc/sba_iommu.c:1741:			/* region from +1408K to +1536 is un-usable. */
linux/drivers/dma/ti/edma.c:512:	from = EDMA_CHAN_SLOT(from);
linux/drivers/dma/ti/edma.c:514:	if (from >= ecc->num_slots || to >= ecc->num_slots)
linux/drivers/dma/ti/k3-udma.c:1279:	if (from >= 0 && start != from)
linux/drivers/dma/ti/k3-udma.c:1288:	if (from < ud->rchan_cnt)
linux/drivers/dma/ti/k3-udma.c:1290:	if (from + cnt > ud->rflow_cnt)
linux/drivers/dma/amba-pl08x.c:2053:	dev_dbg(&pl08x->adev->dev, "%s prepare transaction of %d bytes from %s\n",
linux/drivers/dma/bcm-sba-raid.c:1721:	dev_info(sba->dev, "%s using SBAv%d mailbox channel from %s",
linux/drivers/dma/stm32-dma.c:126: * Valid transfer starts from @0 to @0xFFFE leading to unaligned scatter
linux/drivers/dma/ipu/ipu_idmac.c:486:	dev_dbg(ipu_data.dev, "resizing from %u -> %u pixels, "
linux/drivers/dma/xilinx/xilinx_dpdma.c:500: * from @dma_addr. If a previous descriptor is specified in @prev, its next
linux/drivers/mtd/mtdconcat.c:65:		if (from >= subdev->size) {
linux/drivers/mtd/mtdconcat.c:68:			from -= subdev->size;
linux/drivers/mtd/mtdconcat.c:71:		if (from + len > subdev->size)
linux/drivers/mtd/mtdconcat.c:100:		from = 0;
linux/drivers/mtd/mtdconcat.c:271:		if (from >= subdev->size) {
linux/drivers/mtd/mtdconcat.c:272:			from -= subdev->size;
linux/drivers/mtd/mtdconcat.c:277:		if (from + devops.len > subdev->size)
linux/drivers/mtd/mtdconcat.c:311:		from = 0;
linux/drivers/mtd/hyperbus/rpc-if.c:52:	op.addr.val = from >> 1;
linux/drivers/mtd/maps/physmap-bt1-rom.c:66:	if (len <= 0 || from >= map->size)
linux/drivers/mtd/maps/pcmciamtd.c:143:	pr_debug("to = %p from = %lu len = %zd\n", to, from, len);
linux/drivers/mtd/maps/pcmciamtd.c:145:		int toread = win_size - (from & (win_size-1));
linux/drivers/mtd/maps/pcmciamtd.c:155:		pr_debug("memcpy from %p to %p len = %d\n", addr, to, toread);
linux/drivers/mtd/maps/pcmciamtd.c:159:		from += toread;
linux/drivers/mtd/maps/pcmciamtd.c:192:	pr_debug("to = %lu from = %p len = %zd\n", to, from, len);
linux/drivers/mtd/maps/pcmciamtd.c:204:		pr_debug("memcpy from %p to %p len = %d\n", from, addr, towrite);
linux/drivers/mtd/maps/pcmciamtd.c:208:		from += towrite;
linux/drivers/mtd/maps/pcmciamtd.c:254:	pr_debug("to = %p from = %lu len = %zd\n", to, from, len);
linux/drivers/mtd/maps/pcmciamtd.c:292:	pr_debug("to = %lu from = %p len = %zd\n", to, from, len);
linux/drivers/mtd/maps/physmap-ixp4xx.c:91:	if (from & 1) {
linux/drivers/mtd/maps/sbc_gxx.c:116:		if (len > (WINDOW_LENGTH - (from & WINDOW_MASK)))
linux/drivers/mtd/maps/sbc_gxx.c:117:			thislen = WINDOW_LENGTH-(from & WINDOW_MASK);
linux/drivers/mtd/maps/sbc_gxx.c:121:		memcpy_fromio(to, iomapadr + (from & WINDOW_MASK), thislen);
linux/drivers/mtd/maps/sbc_gxx.c:124:		from += thislen;
linux/drivers/mtd/maps/sbc_gxx.c:149:		from += thislen;
linux/drivers/mtd/maps/dc21285.c:111:		from += 4;
linux/drivers/mtd/maps/dc21285.c:123:		from += 2;
linux/drivers/mtd/maps/vmu-flash.c:367:	if (from + len > numblocks * card->blocklen)
linux/drivers/mtd/maps/vmu-flash.c:374:		vblock =  ofs_to_block(from + index, mtd, partition);
linux/drivers/mtd/maps/vmu-flash.c:400:			cx = vmu_flash_read_char(from + index, &retval, mtd);
linux/drivers/mtd/ubi/vmt.c:416:	dbg_gen("re-size device %d, volume %d to from %d to %d PEBs",
linux/drivers/mtd/ubi/io.c:1324:		ubi_msg(ubi, "hex dump of the original buffer from %d to %d",
linux/drivers/mtd/ubi/io.c:1328:		ubi_msg(ubi, "hex dump of the read buffer from %d to %d",
linux/drivers/mtd/ubi/kapi.c:497: * This function writes @len bytes of data from @buf to offset @offset of
linux/drivers/mtd/ubi/block.c:187:	/* Get LEB:offset address to read from */
linux/drivers/mtd/ubi/block.c:648:	 * Attach block devices from 'block=' module param.
linux/drivers/mtd/ubi/cdev.c:756:		dbg_gen("will rename volume %d from \"%s\" to \"%s\"",
linux/drivers/mtd/ubi/build.c:816:	ubi_msg(ubi, "volume %d (\"%s\") re-sized from %d to %d LEBs",
linux/drivers/mtd/chips/cfi_cmdset_0020.c:392:	chipnum = (from >> cfi->chipshift);
linux/drivers/mtd/chips/cfi_cmdset_0020.c:393:	ofs = from - (chipnum <<  cfi->chipshift);
linux/drivers/mtd/chips/cfi_cmdset_0002.c:1246:	chipnum = (from >> cfi->chipshift);
linux/drivers/mtd/chips/cfi_cmdset_0002.c:1247:	ofs = from - (chipnum <<  cfi->chipshift);
linux/drivers/mtd/chips/cfi_cmdset_0002.c:1356:	ofs=from & 7;
linux/drivers/mtd/chips/cfi_cmdset_0002.c:1580:			from += otpsize;
linux/drivers/mtd/chips/cfi_cmdset_0002.c:1581:		} else if ((from < otpsize) && (len > 0)) {
linux/drivers/mtd/chips/cfi_cmdset_0002.c:1592:			from = 0;
linux/drivers/mtd/chips/cfi_cmdset_0002.c:1594:			from -= otpsize;
linux/drivers/mtd/chips/cfi_cmdset_0001.c:1034:				/* give back ownership to who we loaned it from */
linux/drivers/mtd/chips/cfi_cmdset_0001.c:1398:	chipnum = (from >> cfi->chipshift);
linux/drivers/mtd/chips/cfi_cmdset_0001.c:1399:	ofs = from - (chipnum << cfi->chipshift);
linux/drivers/mtd/chips/cfi_cmdset_0001.c:1446:	chipnum = (from >> cfi->chipshift);
linux/drivers/mtd/chips/cfi_cmdset_0001.c:1447:	ofs = from - (chipnum <<  cfi->chipshift);
linux/drivers/mtd/chips/cfi_cmdset_0001.c:1524:	chipnum = (from >> cfi->chipshift);
linux/drivers/mtd/chips/cfi_cmdset_0001.c:1525:	ofs = from - (chipnum <<  cfi->chipshift);
linux/drivers/mtd/chips/cfi_cmdset_0001.c:2391:					from += groupsize;
linux/drivers/mtd/chips/cfi_cmdset_0001.c:2394:				} else if (from >= groupsize) {
linux/drivers/mtd/chips/cfi_cmdset_0001.c:2395:					from -= groupsize;
linux/drivers/mtd/chips/cfi_cmdset_0001.c:2401:					from = 0;
linux/drivers/mtd/nand/raw/fsl_elbc_nand.c:54:	unsigned int page;       /* Last page written to / read from      */
linux/drivers/mtd/nand/raw/s3c2410.c:146: * @clk_rate: The clock rate from @clk.
linux/drivers/mtd/nand/raw/s3c2410.c:259:	pr_debug("result %d from %ld, %d\n", result, clk, wanted);
linux/drivers/mtd/nand/raw/nand_base.c:125: * @nbits: number of bits to copy from @src to @dst
linux/drivers/mtd/nand/raw/nand_base.c:3511:	chipnr = (int)(from >> chip->chip_shift);
linux/drivers/mtd/nand/raw/nand_base.c:3514:	realpage = (int)(from >> chip->page_shift);
linux/drivers/mtd/nand/raw/nand_base.c:3517:	col = (int)(from & (mtd->writesize - 1));
linux/drivers/mtd/nand/raw/nand_base.c:3841:	pr_debug("%s: from = 0x%08Lx, len = %i\n",
linux/drivers/mtd/nand/raw/nand_base.c:3852:	chipnr = (int)(from >> chip->chip_shift);
linux/drivers/mtd/nand/raw/nand_base.c:3856:	realpage = (int)(from >> chip->page_shift);
linux/drivers/mtd/nand/raw/gpmi-nand/gpmi-nand.c:896:	 * Derive NFC ideal delay from {3}:
linux/drivers/mtd/nand/raw/nand_bbt.c:180:	from = ((loff_t)page) << this->page_shift;
linux/drivers/mtd/nand/raw/nand_bbt.c:190:			from += marker_len;
linux/drivers/mtd/nand/raw/nand_bbt.c:197:					from & ~mtd->writesize);
linux/drivers/mtd/nand/raw/nand_bbt.c:201:					from & ~mtd->writesize);
linux/drivers/mtd/nand/raw/nand_bbt.c:243:		from += len;
linux/drivers/mtd/nand/raw/nand_bbt.c:503:		from = 0;
linux/drivers/mtd/nand/raw/nand_bbt.c:513:		from = (loff_t)startblock << this->bbt_erase_shift;
linux/drivers/mtd/nand/raw/nand_bbt.c:532:		from += (1 << this->bbt_erase_shift);
linux/drivers/mtd/nand/raw/nandsim.c:480:		unsigned long from = (i ? decile_max[i - 1] + 1 : 0);
linux/drivers/mtd/nand/raw/nandsim.c:481:		if (from > decile_max[i])
linux/drivers/mtd/nand/raw/nandsim.c:483:		seq_printf(m, "Number of ebs with erase counts from %lu to %lu : %lu\n",
linux/drivers/mtd/nand/raw/nandsim.c:1413:				"reading from %d ecc: corrected=%u failed=%u\n",
linux/drivers/mtd/nand/raw/nandsim.c:1435:			NS_DBG("read_page: page %d written, reading from %d\n",
linux/drivers/mtd/nand/raw/nandsim.c:1456:		NS_DBG("read_page: page %d allocated, reading from %d\n",
linux/drivers/mtd/nand/onenand/onenand_bbt.c:81:	from = 0;
linux/drivers/mtd/nand/onenand/onenand_bbt.c:95:				from + j * this->writesize + bd->offs, &ops);
linux/drivers/mtd/nand/onenand/onenand_bbt.c:114:			from += mtd->eraseregions[rgn].erasesize;
linux/drivers/mtd/nand/onenand/onenand_bbt.c:116:			from += (1 << bbm->bbt_erase_shift);
linux/drivers/mtd/nand/onenand/onenand_base.c:1128:	pr_debug("%s: from = 0x%08x, len = %i\n", __func__, (unsigned int)from,
linux/drivers/mtd/nand/onenand/onenand_base.c:1132:	oobcolumn = from & (mtd->oobsize - 1);
linux/drivers/mtd/nand/onenand/onenand_base.c:1135:	if (from + len > mtd->size) {
linux/drivers/mtd/nand/onenand/onenand_base.c:1150:		column = from & (writesize - 1);
linux/drivers/mtd/nand/onenand/onenand_base.c:1185:		from += thislen;
linux/drivers/mtd/nand/onenand/onenand_base.c:1229:	pr_debug("%s: from = 0x%08x, len = %i\n", __func__, (unsigned int)from,
linux/drivers/mtd/nand/onenand/onenand_base.c:1233:	oobcolumn = from & (mtd->oobsize - 1);
linux/drivers/mtd/nand/onenand/onenand_base.c:1236:	if ((from + len) > mtd->size) {
linux/drivers/mtd/nand/onenand/onenand_base.c:1260:	column = from & (writesize - 1);
linux/drivers/mtd/nand/onenand/onenand_base.c:1266:		from += thislen;
linux/drivers/mtd/nand/onenand/onenand_base.c:1275:			    unlikely(from == (this->chipsize >> 1))) {
linux/drivers/mtd/nand/onenand/onenand_base.c:1355:	from += ops->ooboffs;
linux/drivers/mtd/nand/onenand/onenand_base.c:1357:	pr_debug("%s: from = 0x%08x, len = %i\n", __func__, (unsigned int)from,
linux/drivers/mtd/nand/onenand/onenand_base.c:1368:	column = from & (mtd->oobsize - 1);
linux/drivers/mtd/nand/onenand/onenand_base.c:1415:			from += mtd->writesize;
linux/drivers/mtd/nand/onenand/onenand_base.c:1547:	pr_debug("%s: from = 0x%08x, len = %zi\n", __func__, (unsigned int)from,
linux/drivers/mtd/nand/onenand/onenand_base.c:1554:	if (unlikely((from + len) > mtd->size)) {
linux/drivers/mtd/nand/onenand/onenand_base.c:1563:	column = from & (mtd->oobsize - 1);
linux/drivers/mtd/nand/onenand/onenand_base.c:1594:			from += this->writesize;
linux/drivers/mtd/nand/onenand/onenand_base.c:3056:		from += mtd->writesize * otp_pages;
linux/drivers/mtd/nand/onenand/onenand_base.c:3062:		if (mtd->writesize * otp_pages < from + len)
linux/drivers/mtd/nand/onenand/onenand_base.c:3085:			from += mtd->writesize;
linux/drivers/mtd/nand/onenand/onenand_base.c:3214:	from = 0;
linux/drivers/mtd/nand/onenand/onenand_base.c:3530:	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);
linux/drivers/mtd/parsers/brcm_u-boot.c:49:			pr_err("Failed to read from %s at 0x%zx: %d\n", mtd->name, offset, err);
linux/drivers/mtd/parsers/tplink_safeloader.c:44:		pr_err("Failed to read from %s at 0x%x\n", mtd->name, offset);
linux/drivers/mtd/parsers/tplink_safeloader.c:56:		pr_err("Failed to read from %s at 0x%zx\n", mtd->name, offset + sizeof(hdr));
linux/drivers/mtd/parsers/sharpslpart.c:241:	final_log_num = mtd_div_by_eb(((u32)from + len - 1), mtd);
linux/drivers/mtd/mtdcore.c:1393:	if (from < 0 || from >= mtd->size || len > mtd->size - from)
linux/drivers/mtd/mtdcore.c:1398:	from = mtd_get_master_ofs(mtd, from);
linux/drivers/mtd/mtdcore.c:1410:	if (from < 0 || from >= mtd->size || len > mtd->size - from)
linux/drivers/mtd/mtdcore.c:1560:	from = mtd_get_master_ofs(mtd, from);
linux/drivers/mtd/devices/st_spi_fsm.c:1686:		from += bytes;
linux/drivers/mtd/devices/st_spi_fsm.c:1977:	uint32_t boot_device;     /* Value we read from *boot_device_reg */
linux/drivers/mtd/devices/mtd_dataflash.c:231: *   from   : Start offset in flash device
linux/drivers/mtd/devices/mtd_dataflash.c:247:		  (unsigned int)from, (unsigned int)(from + len));
linux/drivers/mtd/devices/mtd_dataflash.c:250:	addr = (((unsigned)from / priv->page_size) << priv->page_offset)
linux/drivers/mtd/devices/mtd_dataflash.c:251:		+ ((unsigned)from % priv->page_size);
linux/drivers/mtd/devices/mtd_dataflash.c:288:			(unsigned)from, (unsigned)(from + len),
linux/drivers/mtd/devices/mtd_dataflash.c:546:	if (from >= 64) {
linux/drivers/mtd/devices/mtd_dataflash.c:556:	if ((from + len) > 64)
linux/drivers/mtd/devices/pmc551.c:200:	soff_hi = from & ~(priv->asize - 1);
linux/drivers/mtd/devices/pmc551.c:201:	soff_lo = from & (priv->asize - 1);
linux/drivers/mtd/devices/pmc551.c:238:	end = from + len - 1;
linux/drivers/mtd/devices/pmc551.c:239:	soff_hi = from & ~(priv->asize - 1);
linux/drivers/mtd/devices/sst25l.c:219:	command[1] = from >> 16;
linux/drivers/mtd/devices/sst25l.c:220:	command[2] = from >> 8;
linux/drivers/mtd/devices/slram.c:191:	T("slram: Registered device %s from %luKiB to %luKiB\n", name,
linux/drivers/mtd/devices/phram.c:386:	/* mtd_set_of_node() reads name from "label" */
linux/drivers/mtd/devices/spear_smi.c:605:	const unsigned char *from = src;
linux/drivers/mtd/devices/docg3.c:841:	sector = from / DOC_LAYOUT_PAGE_SIZE;
linux/drivers/mtd/devices/docg3.c:897:	skip = from % DOC_LAYOUT_PAGE_SIZE;
linux/drivers/mtd/devices/docg3.c:901:		calc_block_sector(from - skip, &block0, &block1, &page, &ofs,
linux/drivers/mtd/devices/docg3.c:966:		from += DOC_LAYOUT_PAGE_SIZE;
linux/drivers/mtd/devices/docg3.c:1050:	if (from % DOC_LAYOUT_PAGE_SIZE)
linux/drivers/mtd/devices/docg3.c:1218: * @oob: buffer to get out of band bytes from (can be NULL if no OOB should be
linux/drivers/mtd/devices/bcm47xxsflash.c:102:	if ((from + len) > mtd->size)
linux/drivers/mtd/devices/bcm47xxsflash.c:106:	if (from < BCM47XXSFLASH_WINDOW_SZ) {
linux/drivers/mtd/devices/bcm47xxsflash.c:111:		from += memcpy_len;
linux/drivers/mtd/devices/block2mtd.c:90:	size_t from = instr->addr;
linux/drivers/mtd/devices/block2mtd.c:109:	pgoff_t index = from >> PAGE_SHIFT;
linux/drivers/mtd/devices/block2mtd.c:110:	int offset = from & (PAGE_SIZE-1);
linux/drivers/mtd/spi-nor/otp.c:411:	if (from < 0 || (from + len) > spi_nor_otp_size(nor))
linux/drivers/mtd/spi-nor/otp.c:439:		from += rlen;
linux/drivers/mtd/spi-nor/otp.c:456:	if (from < 0 || (from + len) > spi_nor_otp_size(nor))
linux/drivers/mtd/spi-nor/otp.c:474:		from += rlen;
linux/drivers/mtd/spi-nor/controllers/hisi-sfc.c:280:			from + offset, host->dma_buffer, trans, FMC_OP_READ);
linux/drivers/mtd/spi-nor/core.c:2115:		from += ret;
linux/drivers/devfreq/imx8m-ddrc.c:262:		dev_err(dev, "ddrc failed freq switch to %lu from %lu: error %d. now at %lu\n",
linux/drivers/devfreq/imx8m-ddrc.c:265:		dev_err(dev, "ddrc failed freq update to %lu from %lu, now at %lu\n",
linux/drivers/siox/siox-core.c:140:	 * The counter bits hold values from [0, 6]. 7 would be possible
linux/drivers/nvdimm/virtio_pmem.c:86:		dev_dbg(&vdev->dev, "changing target node from %d to %d",
linux/drivers/nvdimm/btt.c:1352:		/* Wait if the new block is being read from */
linux/drivers/nvdimm/pfn_devs.c:709:					"number of pfns truncated from %lld to %ld\n",
linux/drivers/nvdimm/of_pmem.c:45:	dev_dbg(&pdev->dev, "Registering %s regions from %pOF\n",
linux/drivers/nvdimm/of_pmem.c:71:			dev_warn(&pdev->dev, "Unable to register region %pR from %pOF\n",
linux/drivers/nvdimm/of_pmem.c:74:			dev_dbg(&pdev->dev, "Registered region %pR from %pOF\n",
linux/drivers/pnp/quirks.c:95:					 "from %#02x to 0x0A (1, 3)\n",
linux/drivers/pnp/quirks.c:127:					 "range from %#llx-%#llx to "
linux/drivers/irqchip/irq-gic-v3-its.c:2431:			 * subtract ID bits that sparse lvl2 table from 'ids'
linux/drivers/irqchip/irq-gic-v3-its.c:3810:	from = vpe_to_cpuid_lock(vpe, &flags);
linux/drivers/irqchip/irq-gic-v3-its.c:3811:	if (from == cpu)
linux/drivers/infiniband/core/mad.c:2057:	/* Setup MAD receive work completion from "normal" work completion */
linux/drivers/infiniband/hw/vmw_pvrdma/pvrdma_main.c:654:	dev_dbg(&dev->pdev->dev, "removing gid at index %u from %s",
linux/drivers/infiniband/hw/hfi1/hfi.h:706:	 * SMA-facing value.  Should be set from .latest when
linux/drivers/infiniband/hw/hfi1/chip.c:10953:	dd_dev_err(dd, "%s: unexpected state transition from %s to %s\n",
linux/drivers/infiniband/hw/hfi1/chip.c:13391:			   "Reducing # kernel rcv contexts to: %d, from %lu\n",
linux/drivers/infiniband/hw/hfi1/chip.c:13411:			   "Reducing # user receive contexts to: %u, from %u\n",
linux/drivers/infiniband/hw/hfi1/chip.c:13448:		dd_dev_err(dd, "RMT overflow: reducing # user contexts from %u to %u\n",
linux/drivers/infiniband/hw/hfi1/mad.c:1505:				    "MTU change on vl %d from %d to %d\n",
linux/drivers/infiniband/hw/hfi1/mad.c:1519:			    "MTU change on vl 15 from %d to %d\n",
linux/drivers/infiniband/hw/hfi1/pio_copy.c:52:			from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:68:			from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:87:				from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:98:			from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:175: * Read nbytes from "from" and place them in the low bytes
linux/drivers/infiniband/hw/hfi1/pio_copy.c:192: * Read nbytes bytes from "from" and put them at the end of pbuf->carry.
linux/drivers/infiniband/hw/hfi1/pio_copy.c:283:			from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:299:			from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:318:				from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:329:			from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:388:			from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:415:			from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:426:		from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:464:		from += nread; /* from is now not aligned */
linux/drivers/infiniband/hw/hfi1/pio_copy.c:514:			from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:541:			from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:552:		from += sizeof(u64);
linux/drivers/infiniband/hw/hfi1/pio_copy.c:573:	unsigned long from_align = (unsigned long)from & 0x7;
linux/drivers/infiniband/hw/hfi1/pio_copy.c:597:			from += to_align;
linux/drivers/infiniband/hw/hfi1/pio_copy.c:608:			from += to_fill;
linux/drivers/infiniband/hw/hfi1/pio_copy.c:638:			from += extra;
linux/drivers/infiniband/hw/hfi1/sdma.c:825: * ordering, the mapping from <selector, vl> to sde must remain unchanged.
linux/drivers/infiniband/hw/hfi1/trace_tx.h:295:	    TP_printk("[%s] SDMA from %u:%u (%lu)",
linux/drivers/infiniband/hw/hns/hns_roce_hw_v2.c:1338:		dev_warn(hr_dev->dev, "CMDQ move tail from %u to %u.\n",
linux/drivers/infiniband/hw/mlx5/qp.c:218:	 * from  wqe_index 0
linux/drivers/infiniband/hw/mlx5/qp.c:4569:		mlx5_ib_warn(dev, "Modify DCT: Invalid transition from %d to %d\n", cur_state, new_state);
linux/drivers/infiniband/hw/mlx5/qp.c:4690:		mlx5_ib_dbg(dev, "invalid QP state transition from %d to %d, qp_type %d, attr_mask 0x%x\n",
linux/drivers/infiniband/hw/mlx5/qp.c:4695:		mlx5_ib_dbg(dev, "invalid QP state transition from %d to %d, qp_type %d, attr_mask 0x%x\n",
linux/drivers/infiniband/hw/usnic/usnic_ib_main.c:123:					usnic_err("Failed to transition qp grp %u from %s to %s\n",
linux/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c:517:		usnic_info("Transitioned %u from %s to %s",
linux/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c:522:		usnic_err("Failed to transition %u from %s to %s",
linux/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c:560:			usnic_err("Failed to get %s from %s with err %d\n",
linux/drivers/infiniband/hw/usnic/usnic_uiom_interval_tree.h:70: * Removed {start...last} from {root}.  The nodes removed are returned in
linux/drivers/infiniband/hw/usnic/usnic_ib_verbs.c:201:				usnic_dbg("Found used vnic %s from %s\n",
linux/drivers/infiniband/hw/qedr/verbs.c:930:		 "create_cq: called from %s. entries=%d, vector=%d\n",
linux/drivers/infiniband/hw/qedr/verbs.c:1557:		 "create SRQ called from %s (pd %p)\n",
linux/drivers/infiniband/hw/qedr/verbs.c:2268:	DP_DEBUG(dev, QEDR_MSG_QP, "create qp: called from %s, pd=%p\n",
linux/drivers/infiniband/hw/qedr/verbs.c:2276:		 "create qp: called from %s, event_handler=%p, eepd=%p sq_cq=%p, sq_icid=%d, rq_cq=%p, rq_icid=%d\n",
linux/drivers/infiniband/hw/qedr/main.c:1030:					  "Mtu was changed from %d to %d. This will not take affect for iWARP until qedr is reloaded\n",
linux/drivers/infiniband/hw/irdma/cm.c:44: * irdma_copy_ip_ntohl - copy IP address from  network to host
linux/drivers/infiniband/ulp/srpt/ib_srpt.c:1420:			pr_warn("truncated sense data from %d to %d bytes\n",
linux/drivers/infiniband/ulp/isert/ib_isert.c:1159:		  "sg_nents: %u from %p %u\n", sg_start, sg_off,
linux/drivers/infiniband/ulp/srp/ib_srp.c:349:		pr_err("No route available from %pISpsc to %pISpsc (%d)\n",
linux/drivers/infiniband/ulp/srp/ib_srp.c:2489:					     "SRP LOGIN from %pI6 to %pI6 REJECTED, reason 0x%08x\n",
linux/drivers/infiniband/ulp/iser/iscsi_iser.c:675:		iser_warn("max_sectors was reduced from %u to %u\n",
linux/drivers/rpmsg/virtio_rpmsg_bus.c:529: * It will send @data of length @len to @dst, and say it's from @src. The
linux/drivers/tty/mips_ejtag_fdc.c:132: * @xmit_next:		Next port number to transmit from (round robin).
linux/drivers/tty/nozomi.c:1140:			dev_err(&dc->pdev->dev, "Could not read status from "
linux/drivers/tty/vt/consolemap.c:598:	 * empty rows. We are copying entries from "old" to "new".
linux/drivers/tty/vt/selection.c:35:/* Don't take this from <ctype.h>: 011-015 on the screen aren't spaces */
linux/drivers/tty/vt/vt.c:2821:			draw->from = vc->vc_pos;
linux/drivers/tty/vt/vt.c:4773:		from = scr_end;
linux/drivers/tty/vt/vt.c:4776:		from = 0;
linux/drivers/tty/vt/vt.c:4780:	from_off = (vorigin - from + wrap) % wrap + lines * c->vc_size_row;
linux/drivers/tty/vt/vt.c:4781:	avail = (origin - from + wrap) % wrap;
linux/drivers/tty/vt/vt.c:4791:	c->vc_visible_origin = ubase + (from + from_off) % wrap;
linux/drivers/tty/serial/8250/8250_port.c:602: *	The function is supposed to be called from .rs485_config callback
linux/drivers/tty/serial/8250/8250_port.c:643: *	The function is supposed to be called from .rs485_config callback
linux/drivers/tty/serial/8250/Kconfig:228:	  from <https://www.tldp.org/docs.html#howto>), or other custom
linux/drivers/tty/serial/8250/Kconfig:274:	  mini-HOWTO, available from <https://www.tldp.org/docs.html#howto>
linux/drivers/tty/serial/imx.c:1916:/* called with port.lock taken and irqs off or from .probe without locking */
linux/drivers/tty/serial/imx.c:2092:			dev_info(sport->port.dev, "Console IMX rounded baud rate from %d to %d\n",
linux/drivers/tty/serial/fsl_lpuart.c:2496:				"from %d to %d\n", baud_raw, *baud);
linux/drivers/tty/serial/fsl_lpuart.c:2542:				"from %d to %d\n", baud_raw, *baud);
linux/drivers/tty/serial/dz.c:19: *            field from "current" - somewhere between 2.1.121 and 2.1.131
linux/drivers/tty/tty_audit.c:17:	dev_t dev;		/* The TTY which the data is from */
linux/drivers/tty/tty_audit.c:200: *	Audit @data of @size from @tty, if necessary.
linux/drivers/tty/n_hdlc.c:532:		pr_debug("%s: truncating user packet from %zu to %d\n",
linux/drivers/tty/n_tty.c:174:	void *from = read_buf_addr(ldata, tail);
linux/drivers/tty/n_tty.c:182:		from = ldata->read_buf;
linux/drivers/tty/n_tty.c:1646: * Returns: the # of input chars from @cp which were processed.
linux/drivers/tty/n_tty.c:1938:		unsigned char *from = read_buf_addr(ldata, tail);
linux/drivers/tty/n_tty.c:1940:		is_eof = n == 1 && *from == EOF_CHAR(tty);
linux/drivers/tty/n_tty.c:2107: * @offset: where to continue reading from (unused in n_tty)
linux/drivers/tty/hvc/hvc_vio.c:390:	/* find the boot console from /chosen/stdout */
linux/drivers/tty/hvc/hvc_iucv.c:483: * instance that is derived from @id. Always returns 0.
linux/drivers/phy/ti/phy-j721e-wiz.c:1424:				"%s: Reading \"reg\" from \"%s\" failed: %d\n",
linux/drivers/auxdisplay/panel.c:618: * Converts a parallel port pin (from -25 to 25) to data and control ports
linux/drivers/hwmon/adm9240.c:150:		"fan%d clock divider changed from %lu to %lu\n",
linux/drivers/hwmon/via686a.c:246: * solving for each temp value from -50 to 110 (the useable range for
linux/drivers/hwmon/asus-ec-sensors.c:544:	/* EC registers to read from */
linux/drivers/hwmon/w83793.c:1294:	 * call misc_register() from  w83793_probe() with watchdog_data_mutex
linux/drivers/hwmon/nct6775-core.c:1273:		dev_dbg(dev, "Modifying fan%d clock divider from %u to %u\n",
linux/drivers/hwmon/nct6775-core.c:1977:		dev_dbg(dev, "fan%u clock divider changed from %u to %u\n",
linux/drivers/hwmon/pc87427.c:636:		dev_dbg(dev, "Switching PWM%d from %s to %s\n", nr + 1,
linux/drivers/hwmon/pc87427.c:642:		dev_dbg(dev, "Switching PWM%d from %s to %s\n", nr + 1,
linux/drivers/hwmon/w83627ehf.c:609:					"Increasing fan%d clock divider from %u to %u\n",
linux/drivers/hwmon/w83627ehf.c:772:		dev_dbg(dev, "fan%u clock divider changed from %u to %u\n",
linux/drivers/hwmon/sch56xx-common.c:433:	   the BIOS set timeout from (if any was set at all) ->
linux/drivers/hwmon/smm665.c:157: * Read 16 bit value from <reg>, <reg+1>. Upper 8 bits are in <reg>.
linux/drivers/hwmon/applesmc.c:581:		pr_warn("key count changed from %d to %d\n",
linux/drivers/hwmon/nzxt-smart2.c:275:			      "Fan %d type changed unexpectedly from %d to %d",
linux/drivers/hwmon/g762.c:564: * Helper to import hardware characteristics from .dts file and push
linux/drivers/hwmon/g762.c:693: * Helper to import hardware characteristics from .dts file and push
linux/drivers/hwmon/pmbus/pmbus_core.c:328:	from = _pmbus_read_byte_data(client, page,
linux/drivers/hwmon/pmbus/pmbus_core.c:330:	if (from < 0)
linux/drivers/hwmon/pmbus/pmbus_core.c:333:	to = (from & ~mask) | (config & mask);
linux/drivers/hwmon/fschmd.c:1124:				"Couldn't get voltage scaling factors from "
linux/drivers/hwmon/abituguru3.c:785:			ABIT_UGURU3_DEBUG("timeout reading byte %d from "
linux/drivers/hwmon/max16065.c:130: * Read 16 bit value from <reg>, <reg+1>.
linux/drivers/zorro/zorro.c:59:	for (z = from ? from+1 : &zorro_autocon[0];
linux/drivers/of/overlay.c:468: * Add the properties (if any) and nodes (if any) from @overlay_node to the
linux/drivers/of/overlay.c:621: * build_changeset() - populate overlay changeset in @ovcs from @ovcs->fragments
linux/drivers/of/kexec.c:192: * remove_ima_buffer - remove the IMA buffer property and reservation from @fdt
linux/drivers/mfd/rave-sp.c:622:	 * All of the following command codes were taken from "Table :
linux/drivers/mfd/stm32-timers.c:44: * @reg: registers start offset for DMA to read from (like CCRx for capture)
linux/drivers/mfd/mc13xxx-core.c:51:		dev_dbg(mc13xxx->dev, "wait for %s from %ps\n",
linux/drivers/mfd/mc13xxx-core.c:56:	dev_dbg(mc13xxx->dev, "%s from %ps\n",
linux/drivers/mfd/mc13xxx-core.c:63:	dev_dbg(mc13xxx->dev, "%s from %ps\n",
linux/drivers/isdn/hardware/mISDN/mISDNipac.c:745:	pr_debug("%s: %s dev(%d) open from %p\n", isac->name, __func__,
linux/drivers/isdn/hardware/mISDN/mISDNipac.c:1548:		pr_debug("%s: dev(%d) close from %p\n", ipac->name,
linux/drivers/isdn/hardware/mISDN/hfcmulti.c:2670:		printk(KERN_ERR "irq for card %d during irq from "
linux/drivers/isdn/hardware/mISDN/hfcmulti.c:4022:		printk(KERN_DEBUG "%s: dev(%d) open from %p\n", __func__,
linux/drivers/isdn/hardware/mISDN/hfcmulti.c:4181:			printk(KERN_DEBUG "%s: dev(%d) close from %p\n",
linux/drivers/isdn/hardware/mISDN/hfcmulti.c:4736:			printk(KERN_DEBUG "%s: PORT force getting clock from "
linux/drivers/isdn/hardware/mISDN/hfcpci.c:1884:		printk(KERN_DEBUG "%s: dev(%d) open from %p\n", __func__,
linux/drivers/isdn/hardware/mISDN/hfcpci.c:1974:			printk(KERN_DEBUG "%s: dev(%d) close from %p\n",
linux/drivers/isdn/hardware/mISDN/w6692.c:1160:	pr_debug("%s: %s dev(%d) open from %p\n", card->name, __func__,
linux/drivers/isdn/hardware/mISDN/w6692.c:1198:		pr_debug("%s: dev(%d) close from %p\n", card->name,
linux/drivers/isdn/hardware/mISDN/netjet.c:892:		pr_debug("%s: dev(%d) close from %p\n", card->name, dch->dev.id,
linux/drivers/isdn/hardware/mISDN/hfcsusb.c:421:		printk(KERN_DEBUG "%s: %s: dev(%d) open addr(%i) from %p\n",
linux/drivers/isdn/hardware/mISDN/hfcsusb.c:547:			       "%s: %s: dev(%d) close from %p (open %d)\n",
linux/drivers/isdn/hardware/mISDN/avmfritz.c:937:		pr_debug("%s: dev(%d) close from %p\n", fc->name, dch->dev.id,
linux/drivers/isdn/hardware/mISDN/speedfax.c:258:		pr_debug("%s: dev(%d) close from %p\n", sf->name,
linux/drivers/isdn/mISDN/l1oip_core.c:616:			printk(KERN_DEBUG "%s: remote address changes from "
linux/drivers/isdn/mISDN/l1oip_core.c:981:		printk(KERN_DEBUG "%s: dev(%d) open from %p\n", __func__,
linux/drivers/isdn/mISDN/l1oip_core.c:1068:			printk(KERN_DEBUG "%s: dev(%d) close from %p\n",
linux/drivers/crypto/sa2ul.c:155:	u32 type;		/* CRYPTO_ALG_TYPE from <linux/crypto.h> */
linux/drivers/crypto/atmel-sha.c:261:		dev_vdbg(dd->dev, "read 0x%08x from %s\n", value,
linux/drivers/crypto/cavium/nitrox/nitrox_csr.h:518: *   [CNT] field from [CNT].
linux/drivers/crypto/cavium/nitrox/nitrox_csr.h:640: *    amount written to the [CNT] field from [CNT], which will
linux/drivers/crypto/rockchip/rk3288_crypto.c:77:					dev_err(dev->dev, "Fail downclocking %s from %lu to %lu\n",
linux/drivers/crypto/rockchip/rk3288_crypto.c:81:					dev_info(dev->dev, "Downclocking %s from %lu to %lu\n",
linux/drivers/crypto/atmel-aes.c:355:		dev_vdbg(dd->dev, "read 0x%08x from %s\n", value,
linux/drivers/crypto/axis/artpec6_crypto.c:436:		pr_debug("bounce entry %p: %zu bytes @ %zu from %p\n",
linux/drivers/crypto/hisilicon/qm.c:465:	dev_dbg(&qm->pdev->dev, "change qm state from %s to %s\n",
linux/drivers/crypto/hisilicon/qm.c:469:		dev_warn(&qm->pdev->dev, "Can not change qm state from %s to %s\n",
linux/drivers/crypto/hisilicon/qm.c:511:	dev_dbg(&qm->pdev->dev, "change qp state from %s to %s in QM %s\n",
linux/drivers/crypto/hisilicon/qm.c:516:			 "Can not change qp state from %s to %s in QM %s\n",
linux/drivers/crypto/hisilicon/hpre/hpre_crypto.c:1679:	 * The key from 'buf' is in little-endian, we should preprocess it as
linux/drivers/crypto/ccp/ccp-crypto-main.c:165:	/* Transition the state from -EBUSY to -EINPROGRESS first */
linux/drivers/crypto/nx/nx.c:73: * writing them until all of the data from @start_addr is described or
linux/drivers/crypto/allwinner/sun8i-ss/sun8i-ss-core.c:767:			dev_info(ss->dev, "Set %s clock to %lu (%lu Mhz) from %lu (%lu Mhz)\n",
linux/drivers/crypto/allwinner/sun8i-ce/sun8i-ce-core.c:808:			dev_info(ce->dev, "Set %s clock to %lu (%lu Mhz) from %lu (%lu Mhz)\n",
linux/drivers/crypto/bcm/util.c:139:	struct scatterlist *from = *from_sg;
linux/drivers/crypto/ccree/cc_driver.c:361:	dev_dbg(dev, "CC registers mapped from %pa to 0x%p\n",
linux/drivers/comedi/drivers/rtd520.c:1200:			 "PCI latency changed from %d to %d\n",
linux/drivers/comedi/drivers/comedi_bond.c:307:		 "%s: %s attached, %u channels from %u devices\n",
linux/drivers/comedi/drivers/ni_labpc_common.c:1012:	/*  send 8 bit address to read from */
linux/drivers/comedi/drivers/cb_pcidda.c:208:	/*  send address we want to read from */
linux/drivers/comedi/drivers/amplc_pci224.c:87: *      trigger source is switched from 'none' to 'timer' (scan_begin_src =
linux/drivers/edac/edac_device_sysfs.c:441:	/* map from 'block kobj' to 'block->instance->controller->main_kobj'
linux/drivers/edac/armada_xp_edac.c:81:/* derived from "DRAM Address Multiplexing" in the ARMADA XP Functional Spec */
linux/drivers/edac/edac_pci_sysfs.c:666:		/* If the count is different 'after' from 'before' */
linux/drivers/edac/amd64_edac.c:518:	 * | [0, (x - 1)]     | [x, 0xffffffff]    | addresses from     |
linux/drivers/edac/i10nm_base.c:586:	 * Detect present memory controllers from { PCI device: 8-5, function 7-1 }
linux/drivers/nvme/host/fc.c:2980:			"reconnect: revising io queue count from %d to %d\n",
linux/drivers/nvme/host/core.c:443: * Called to unwind from ->queue_rq on a failed command submission so that the
linux/drivers/nvme/host/core.c:1295:		 "keep alive interval updated from %u ms to %u ms\n",
linux/drivers/nvme/target/fcloop.c:48:	size_t blen = s->to - s->from + 1;
linux/drivers/pinctrl/renesas/pinctrl-rza2.c:380:	/* Create map where to retrieve function and mux settings from */
linux/drivers/pinctrl/renesas/pinctrl-rza1.c:1063:	/* Create map where to retrieve function and mux settings from */
linux/drivers/pinctrl/intel/pinctrl-intel.h:82: * @padown_offset: Register offset of PAD_OWN register from @regs. If %0
linux/drivers/pinctrl/intel/pinctrl-intel.h:84: * @padcfglock_offset: Register offset of PADCFGLOCK from @regs. If %0 then
linux/drivers/pinctrl/intel/pinctrl-intel.h:86: * @hostown_offset: Register offset of HOSTSW_OWN from @regs. If %0 then it
linux/drivers/pinctrl/intel/pinctrl-intel.h:89: * @is_offset: Register offset of GPI_IS from @regs.
linux/drivers/pinctrl/intel/pinctrl-intel.h:90: * @ie_offset: Register offset of GPI_IE from @regs.
linux/drivers/pinctrl/pinconf-generic.c:199: * Parse the config options described in @params from @np and puts the result
linux/drivers/pinctrl/aspeed/pinctrl-aspeed.c:311:	 * It's tempting to generalise the prefix test from "GPIO" to "GPI" to
linux/drivers/pinctrl/aspeed/pinmux-aspeed.h:582: * Create an expression symbol alias from (signal, group) to (pin, signal).
linux/drivers/pinctrl/core.c:1529: * We'll use this time to switch the pins from "init" to "default" unless the
linux/drivers/pinctrl/samsung/pinctrl-samsung.c:726:				"failed to read pin name %d from %pOFn node\n",
linux/drivers/regulator/vctrl-regulator.c:389:			dev_warn(&pdev->dev, "switching down from %duV may cause OVP shutdown\n",
linux/drivers/regulator/bd9571mwv-regulator.c:24:	u8 bkup_mode_cnt_keepon;	/* from "rohm,ddr-backup-power" */
linux/drivers/virtio/virtio_mem.c:808: * from (notifier) callbacks lockless.
linux/drivers/cpufreq/cpufreq-dt.c:231:	/* Get OPP-sharing information from "operating-points-v2" bindings */
linux/drivers/cpufreq/mediatek-cpufreq.c:456:	/* Get OPP-sharing information from "operating-points-v2" bindings */
linux/drivers/cpufreq/pxa2xx-cpufreq.c:198:		pr_debug("Changing CPU frequency from %d Mhz to %d Mhz\n",
linux/drivers/cpufreq/intel_pstate.c:2242:	int from = cpu->pstate.current_pstate;
linux/drivers/misc/cxl/flash.c:280:	from = (void *) ai->data;
linux/drivers/misc/cxl/flash.c:303:		from += s_copy;
linux/drivers/misc/eeprom/idt_89hpesx.c:70: * @eesize:	Size of EEPROM in bytes (calculated from "idt,eecompatible")
linux/drivers/misc/eeprom/idt_89hpesx.c:562:		/* Send EEPROM memory address to read data from */
linux/drivers/misc/eeprom/idt_89hpesx.c:745:	/* Send CSR address to read data from */
linux/drivers/misc/eeprom/idt_89hpesx.c:1118:	/* Get custom EEPROM address from 'reg' attribute */
linux/drivers/misc/eeprom/at24.c:65: * Other than binding model, current differences from "eeprom" driver are
linux/drivers/misc/lkdtm/bugs.c:208:			pr_warn("ERROR: canary offset changed from %ld to %ld!?\n",
linux/drivers/misc/vmw_vmci/vmci_guest.c:246:	pr_devel("Updating context from (ID=0x%x) to (ID=0x%x) on event (type=%d)\n",
linux/drivers/misc/vmw_vmci/vmci_queue_pair.c:2263:			/* Move state from *_NO_MEM to *_MEM */
linux/drivers/misc/vmw_vmci/vmci_queue_pair.c:2377:		 * Move state from *_MEM to *_NO_MEM.
linux/drivers/misc/ti-st/st_kim.c:569:/* called when debugfs entry is read from */
linux/drivers/misc/enclosure.c:28: * @start:	Optional enclosure device to start from (NULL if none)
linux/drivers/misc/sgi-gru/grumain.c:688:	gru_dbg(grudev, "retarget from %d to %d\n", gts->ts_tlb_int_select,
linux/drivers/misc/sgi-xp/xpc_main.c:1127:					dev_info(xpc_part, "deactivate from "
linux/drivers/misc/sgi-xp/xpc.h:129:	int mmr_blade;		/* blade where watchlist was allocated from */
linux/drivers/misc/sgi-xp/xpc.h:326:	int reason_line;	/* line# disconnect initiated from */
linux/drivers/misc/sgi-xp/xpc.h:486:	int reason_line;	/* line# deactivation initiated from */
linux/drivers/misc/sgi-xp/xpc_channel.c:431:		dev_dbg(xpc_chan, "XPC_CHCTL_OPENCOMPLETE received from "
linux/drivers/misc/c2port/core.c:431:		dev_err(dev, "cannot read from %s\n", c2dev->name);
linux/drivers/misc/c2port/core.c:468:		dev_err(c2dev->dev, "cannot read from %s\n", c2dev->name);
linux/drivers/memory/renesas-rpc-if.c:615:	if (count && ((unsigned long)from & 1)) {
linux/drivers/memory/renesas-rpc-if.c:616:		*(u16 *)buf = __raw_readw((void __iomem *)((unsigned long)from & ~1));
linux/drivers/memory/renesas-rpc-if.c:624:		from += 2;
linux/drivers/memory/renesas-rpc-if.c:634:		from += maxw;
linux/drivers/memory/renesas-rpc-if.c:640:		from += 2;
linux/drivers/memory/renesas-rpc-if.c:653:	loff_t from = offs & (rpc->size - 1);
linux/drivers/memory/ti-aemif.c:146:	dev_dbg(&pdev->dev, "%s: result %d from %ld, %d\n", __func__, result,
linux/drivers/memory/samsung/exynos5422-dmc.c:624:	 * Make sure if the voltage is not from 'bypass' settings and align to
linux/drivers/hv/ring_buffer.c:628:	 * be a null transition from "enough free space" to "enough free
linux/drivers/hv/channel_mgmt.c:600:	 * Forbids: CPU1's LOAD from *not* seing CPU2's STORE &&
linux/drivers/hv/channel_mgmt.c:601:	 *              CPU2's SEARCH from *not* seeing CPU1's INSERT
linux/drivers/hv/channel_mgmt.c:604:	 *              CPU2's LOAD from *not* seing CPU1's STORE
linux/drivers/hv/channel_mgmt.c:1156:	 * Forbids: CPU2's LOAD from *not* seeing CPU1's STORE
linux/drivers/usb/phy/phy.c:119: * If we get the charger type from ->charger_detect() instead of extcon
linux/drivers/usb/phy/phy.c:315: * type should be get from ->charger_detect().
linux/drivers/usb/gadget/function/f_fs.c:1210:		*from = p->data;
linux/drivers/usb/gadget/function/u_serial.c:758:	pr_vdebug("gs_put_char: (%d,%p) char=0x%x, called from %ps\n",
linux/drivers/usb/gadget/udc/dummy_hcd.c:779:				"dequeued req %p from %s, len %d buf %p\n",
linux/drivers/usb/gadget/udc/net2280.c:4: * Specs and errata are available from <http://www.plxtech.com>.
linux/drivers/usb/misc/usbtest.c:2549:		dev_info(&intf->dev, "TEST 24:  unlink from %d queues of "
linux/drivers/usb/misc/chaoskey.c:137:		usb_dbg(interface, "size reduced from %d to %d\n",
linux/drivers/usb/misc/sisusbvga/sisusbvga.c:305: * to copy from (non-DMA) kernel memory, give "kernbuffer". If
linux/drivers/usb/chipidea/otg.c:175:		dev_dbg(ci->dev, "switching from %s to %s\n",
linux/drivers/usb/dwc2/core_intr.c:470: * For HNP the USB Suspend interrupt signals the change from "a_peripheral"
linux/drivers/usb/host/isp1362.h:727:	RDBG("%s: Read %04x from %s[%02x]\n", __func__, __v, #r,	\
linux/drivers/usb/host/isp1362.h:737:	RDBG("%s: Read %08x from %s[%02x]\n", __func__, __v, #r,	\
linux/drivers/usb/host/oxu210hp-hcd.c:273:/* Type tag from {qh, itd, sitd, fstn}->hw_next */
linux/drivers/usb/host/ehci.h:16: * To facilitate the strongest possible byte-order checking from "sparse"
linux/drivers/usb/host/ehci.h:330:/* type tag from {qh,itd,sitd,fstn}->hw_next */
linux/drivers/usb/host/xhci-ring.c:2984:		xhci_dbg(xhci, "xHCI host dying, returning from "
linux/drivers/usb/host/uhci-hcd.h:110: * To facilitate the strongest possible byte-order checking from "sparse"
linux/drivers/usb/host/ohci-hub.c:616:/* wrap-aware logic morphed from <linux/jiffies.h> */
linux/drivers/usb/mon/mon_bin.c:251:		from += step_len;
linux/drivers/usb/core/urb.c:990: * Return: The oldest urb from @anchor, or %NULL if @anchor has no
linux/drivers/usb/core/generic.c:186:			"configuration #%d chosen from %d choice%s\n",
linux/drivers/usb/core/generic.c:191:			"no configuration chosen from %d choice%s\n",
linux/drivers/usb/core/config.c:743:		dev_notice(ddev, "config %d has %d interface%s, different from "
linux/drivers/usb/storage/transport.c:793:			usb_stor_dbg(us, "-- Sense data truncated to %i from %i\n",
linux/drivers/usb/storage/freecom.c:520:	from = (length - 1) % 16;
linux/drivers/usb/storage/freecom.c:523:	for (i = from + 1; i < 16; i++)
linux/drivers/usb/storage/freecom.c:525:	if (from < 8)
linux/drivers/usb/mtu3/mtu3.h:155: *	bit6: [EL] Zero Length Packet (ZLP), moved from @dw3_info[29]
linux/drivers/usb/common/common.c:130: * If the string from "maximum-speed" property is super-speed-plus-genXxY where
linux/drivers/usb/serial/f81534.c:1015:	dev_dbg(&port->dev, "%s: MSR from %02x to %02x\n", __func__, old_msr,
linux/drivers/usb/serial/f81534.c:1033:	dev_dbg(&port->dev, "%s: DCD Changed: phy_num: %d from %x to %x\n",
linux/drivers/usb/serial/io_edgeport.c:362:		dev_dbg(dev, "**Update Boot Image from %d.%d.%d to %d.%d.%d\n",
linux/drivers/usb/serial/io_ti.c:1168:			dev_dbg(dev, "%s - Update I2C dld from %d.%d to %d.%d\n",
linux/drivers/usb/serial/ezusb_convert.pl:37: * Generated from ${basename}.s by ezusb_convert.pl
linux/drivers/usb/musb/musb_core.c:633:	musb_dbg(musb, "HNP: stop from %s", musb_otg_state_string(musb));
linux/drivers/usb/musb/tusb6010_omap.c:316:		"ep%i %s using %i-bit %s dma from %pad to %pad\n",
linux/drivers/usb/fotg210/fotg210-hcd.h:14: * To facilitate the strongest possible byte-order checking from "sparse"
linux/drivers/usb/fotg210/fotg210-hcd.h:358:/* type tag from {qh,itd,fstn}->hw_next */
linux/drivers/usb/class/usblp.c:1303:			printk(KERN_INFO "usblp%d: Disabling reads from "
linux/drivers/mmc/host/dw_mmc.c:622:			/* Physical address to DMA to/from */
linux/drivers/mmc/host/dw_mmc.c:696:			/* Physical address to DMA to/from */
linux/drivers/mmc/host/usdhi6rol0.c:834:		 * We only also touch USDHI6_SD_OPTION from .request(), which
linux/drivers/mmc/host/sdhci-of-aspeed.c:177:			"Inverting clock to reduce phase correction from %d to %d degrees\n",
linux/drivers/mmc/core/block.c:1114:	from = blk_rq_pos(req);
linux/drivers/mmc/core/block.c:1169:	from = blk_rq_pos(req);
linux/drivers/mmc/core/core.c:1624:			(from >> card->erase_shift)) + 1;
linux/drivers/mmc/core/core.c:1626:		qty += to - from + 1;
linux/drivers/mmc/core/core.c:1629:			(from / card->erase_size)) + 1;
linux/drivers/mmc/core/core.c:1632:		from <<= 9;
linux/drivers/mmc/core/core.c:1740:	*from = from_new;
linux/drivers/mmc/core/core.c:1757:	unsigned int rem, to = from + nr;
linux/drivers/mmc/core/core.c:1778:		if (from % card->erase_size || nr % card->erase_size)
linux/drivers/mmc/core/core.c:1802:	rem = card->erase_size - (from % card->erase_size);
linux/drivers/mmc/core/core.c:1804:		err = mmc_do_erase(card, from, from + rem - 1, arg);
linux/drivers/mmc/core/core.c:1805:		from += rem;
linux/drivers/mmc/core/core.c:1866:	if (from % card->erase_size || nr % card->erase_size)
linux/drivers/rapidio/rio_cm.c:495:	riocm_debug(RX_CMD, "OP=%x for ch=%d from %d",
linux/drivers/rapidio/rio.c:846:	n = from ? from->global_list.next : rio_devices.next;
linux/drivers/rapidio/rio.c:1192:		pr_debug("RIO: Port-Write message from %s\n", rio_name(rdev));
linux/drivers/rapidio/rio.c:1350:	if (from == 0) {
linux/drivers/acpi/nfit/core.c:2635:		dev_info(acpi_desc->dev, "changing numa node from %d to %d for nfit region [%pa-%pa]",
linux/drivers/acpi/nfit/core.c:2640:		dev_info(acpi_desc->dev, "changing target node from %d to %d for nfit region [%pa-%pa]",
linux/drivers/acpi/device_pm.c:223:					  "Cannot transition from %s to %s\n",
linux/drivers/acpi/pci_irq.c:327:			dev_dbg(&dev->dev, "Derived GSI INT %c from %s\n",
linux/drivers/acpi/acpica/nsxfeval.c:115:		    "Incorrect return type from %s - received [%s], requested [%s]",
linux/drivers/acpi/acpica/uteval.c:134:			    "Type returned from %s was incorrect: %s, expected Btypes: 0x%X",
linux/drivers/acpi/acpica/exstorob.c:102:				  "Truncating source buffer from %X to %X\n",
linux/drivers/acpi/acpica/utcache.c:239:				      "%s: Object %p from %s cache\n",
linux/drivers/acpi/acpica/nsload.c:260: *                  event. Deletes an entire subtree starting from (and
linux/drivers/acpi/acpica/tbxfroot.c:276:			  "Searched entire block from %p, valid RSDP was not found\n",
linux/drivers/acpi/acpica/hwxface.c:377:		ACPI_ERROR((AE_INFO, "No Sleep State object returned from [%s]",
linux/drivers/acpi/acpica/dbnames.c:195:		acpi_os_printf("ACPI Namespace (from %4.4s (%p) subtree):\n",
linux/drivers/acpi/acpica/dbnames.c:199:		acpi_os_printf("ACPI Namespace (from %s):\n",
linux/drivers/acpi/acpica/acapps.h:68:		acpi_os_printf ("Unexpected %s from %s (%s-%d)\n", \
linux/drivers/acpi/acpica/hwregs.c:268:			  "Read:  %8.8X%8.8X width %2d from %8.8X%8.8X (%s)\n",
linux/drivers/acpi/resource.c:691: * acpi_dev_free_resource_list - Free resource from %acpi_dev_get_resources().
linux/drivers/media/tuners/xc4000.c:762:	dprintk(1, "Loading %d firmware images from %s, type: %s, ver %d.%d\n",
linux/drivers/media/tuners/mt20xx.c:307:		from = 40750*1000;
linux/drivers/media/tuners/mt20xx.c:312:		from = 32900*1000;
linux/drivers/media/tuners/xc2028.c:331:	tuner_info("Loading %d firmware images from %s, type: %s, ver %d.%d\n",
linux/drivers/media/rc/imon.c:1401:	 * from -14 to 14. We want to down-sample this to only 4 discrete values
linux/drivers/media/usb/dvb-usb-v2/af9035.c:917:			dev_info(&intf->dev, "[%d] overriding tuner from %02x to %02x\n",
linux/drivers/media/usb/au0828/au0828-core.c:408:		pr_err("Activate link from %s->%s. Error %d\n",
linux/drivers/media/usb/usbtv/usbtv-video.c:156:		/* "AVPAL" tuning sequence from .INF file */
linux/drivers/media/usb/usbtv/usbtv-video.c:184:		/* "AVNTSC" tuning sequence from .INF file */
linux/drivers/media/usb/usbtv/usbtv-video.c:212:		/* "AVSECAM" tuning sequence from .INF file */
linux/drivers/media/usb/uvc/uvc_video.c:161:			"Correct USB video probe response from {bmHint: 0x%04x, bFormatIndex: %u} to {bmHint: 0x%04x, bFormatIndex: %u}\n",
linux/drivers/media/usb/b2c2/flexcop-usb.c:93:		err("error while %s dword from %d (%d).", read ? "reading" :
linux/drivers/media/usb/pvrusb2/pvrusb2-hdw.c:4943:			   "Device state change from %s to %s",
linux/drivers/media/usb/s2255/s2255drv.c:306: *  =  V4L2_PIX_FMT_GREY(Y8)  = monochrome from = monochrome=
linux/drivers/media/usb/s2255/s2255drv.c:320: * COLORFILTER is different from "color killer" and "color effects"
linux/drivers/media/usb/cx231xx/cx231xx-dvb.c:923:		si2168_config.ts_mode = SI2168_TS_SERIAL; /* from *.inf file */
linux/drivers/media/usb/gspca/spca506.c:6: *                "Firma Frank Gmbh" from  Saarbruecken
linux/drivers/media/mc/mc-entity.c:672:	 * from @pad.
linux/drivers/media/dvb-frontends/drx39xyj/drxj.c:1819:* \param raddr    Address to read from (usually SIO_HI_RA_RAM_S0_RMWBUF__A)
linux/drivers/media/dvb-frontends/lgdt330x.c:504:		/* SNR for ranges from -15.61 to +41.58 */
linux/drivers/media/dvb-frontends/lgdt330x.c:509:		/* SNR for ranges from -13.11 to +44.08 */
linux/drivers/media/dvb-frontends/lgdt330x.c:551:		/* SNR for ranges from -16.12 to +44.08 */
linux/drivers/media/dvb-frontends/lgdt330x.c:556:		/* SNR for ranges from -13.11 to +44.08 */
linux/drivers/media/dvb-frontends/lgdt3305.c:993:		/* SNR for ranges from -13.11 to +44.08 */
linux/drivers/media/dvb-frontends/lgdt3305.c:1000:		/* SNR for ranges from -16.12 to +44.08 */
linux/drivers/media/dvb-frontends/tc90522.c:701:		from = 0;
linux/drivers/media/dvb-frontends/tc90522.c:705:			to = from + 1;
linux/drivers/media/dvb-frontends/tc90522.c:711:			from = to;
linux/drivers/media/dvb-frontends/tc90522.c:712:		} while (from < j && ret > 0);
linux/drivers/media/i2c/mt9p031.c:976:	/* If the power count is modified from 0 to != 0 or from != 0 to 0,
linux/drivers/media/i2c/et8ek8/et8ek8_driver.c:1306:	/* If the power count is modified from 0 to != 0 or from != 0 to 0,
linux/drivers/media/i2c/adp1653.c:334:	/* If the power count is modified from 0 to != 0 or from != 0 to 0,
linux/drivers/media/i2c/ov2640.c:807:	 * If the power count is modified from 0 to != 0 or from != 0 to 0,
linux/drivers/media/i2c/mt9m001.c:548:			dev_dbg(&client->dev, "Setting gain from %d to %d\n",
linux/drivers/media/i2c/mt9m001.c:561:				"Setting shutter width from %d to %lu\n",
linux/drivers/media/i2c/ov7670.c:735:		.hstart		= 158,	/* These values from */
linux/drivers/media/i2c/ov7670.c:786:		.hstart		= 158,	/* These values from */
linux/drivers/media/i2c/tda7432.c:138:/* Lower 7 bits control volume from -79dB to +32dB in 1dB steps
linux/drivers/media/i2c/max9271.h:225: * Program address translation from @source to @dest. This is required to
linux/drivers/media/i2c/adv7170.c:221:	v4l2_dbg(1, debug, sd, "set input from %s\n",
linux/drivers/media/i2c/ov772x.c:926:	/* If the power count is modified from 0 to != 0 or from != 0 to 0,
linux/drivers/media/i2c/mt9m111.c:1019:	 * If the power count is modified from 0 to != 0 or from != 0 to 0,
linux/drivers/media/i2c/mt9v032.c:857:	/* If the power count is modified from 0 to != 0 or from != 0 to 0,
linux/drivers/media/i2c/tvaudio.c:504:/* lower 7 bits control gain from -71dB (0x28) to 16dB (0x7f)
linux/drivers/media/i2c/tvaudio.c:509:/* lower 5 bits control bass gain from -12dB (0x06) to 16.5dB (0x19)
linux/drivers/media/i2c/tvaudio.c:514:/* 4 bits << 1 control treble gain from -12dB (0x3) to 12dB (0xb)
linux/drivers/media/i2c/tvaudio.c:520:/* 4 bits << 2 control subwoofer/surround gain from -14db (0x1) to 14db (0xf)
linux/drivers/media/i2c/tvaudio.c:564:/* lower 4 bits control input gain from -3.5dB (0x0) to 4dB (0xF)
linux/drivers/media/i2c/ad5820.c:225:	 * If the power count is modified from 0 to != 0 or from != 0 to 0,
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:226:				       args->from + payload_offset,
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:254:		.from               = &args->crc,
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:584:		length += desc->length; /* from 'length' field until the end of the descriptor */
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:633:		.from               = &args->desc->type,
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:655:		psi_args.from = &((struct vidtv_psi_desc_service *)args->desc)->service_type;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:661:		psi_args.from = ((struct vidtv_psi_desc_service *)args->desc)->provider_name;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:667:		psi_args.from = &((struct vidtv_psi_desc_service *)args->desc)->service_name_len;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:673:		psi_args.from = ((struct vidtv_psi_desc_service *)args->desc)->service_name;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:681:		psi_args.from = ((struct vidtv_psi_desc_network_name *)args->desc)->network_name;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:692:			psi_args.from = serv_list_entry;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:703:		psi_args.from = ((struct vidtv_psi_desc_short_event *)
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:710:		psi_args.from = &((struct vidtv_psi_desc_short_event *)
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:717:		psi_args.from = ((struct vidtv_psi_desc_short_event *)args->desc)->event_name;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:723:		psi_args.from = &((struct vidtv_psi_desc_short_event *)args->desc)->text_len;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:729:		psi_args.from = ((struct vidtv_psi_desc_short_event *)args->desc)->text;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:739:		psi_args.from = &args->desc->data;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:753:		.from               = args->h,
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:995:		psi_args.from = p;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:1171:		.from     = &args->pmt->bitfield,
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:1217:		psi_args.from = stream;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:1344:	psi_args.from               = &args->sdt->network_id;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:1359:		psi_args.from = service;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:1654:		.from               = &args->nit->bitfield,
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:1705:	psi_args.from = &args->nit->bitfield2;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:1716:		psi_args.from = transport;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:1895:	psi_args.from               = &args->eit->transport_id;
linux/drivers/media/test-drivers/vidtv/vidtv_psi.c:1908:		psi_args.from = event;
linux/drivers/media/test-drivers/vidtv/vidtv_mux.c:301:		args.from            = buf;
linux/drivers/media/test-drivers/vidtv/vidtv_common.c:27: * @len:	Number of elements to be copy from @from buffer
linux/drivers/media/test-drivers/vidtv/vidtv_common.c:63: * @len:	Number of elements to be copy from @from buffer
linux/drivers/media/test-drivers/vidtv/vidtv_pes.c:419:		args->from += payload_size;
linux/drivers/media/test-drivers/vivid/vivid-kthread-touch.c:165:	dprintk(dev, 1, "returning from %s\n", __func__);
linux/drivers/media/test-drivers/vivid/vivid-kthread-cap.c:820:	dprintk(dev, 1, "returning from %s\n", __func__);
linux/drivers/media/test-drivers/vivid/vivid-kthread-out.c:291:	dprintk(dev, 1, "returning from %s\n", __func__);
linux/drivers/media/pci/cobalt/cobalt-alsa-main.c:74:	/* sc->longname is read from /proc/asound/cards */
linux/drivers/media/pci/cobalt/cobalt-alsa-main.c:89:	/* Numbrs steps from "Writing an ALSA Driver" by Takashi Iwai */
linux/drivers/media/pci/cx23885/cx23888-ir.c:1168:		 * Ensure no interrupts arrive from '888 specific conditions,
linux/drivers/media/pci/zoran/zoran_card.c:1348:		pci_info(zr->pci_dev, "Changing PCI latency from %d to %d\n",
linux/drivers/media/pci/bt8xx/bttv-cards.c:3724:		pr_info("%d: Switching board type from %s to %s\n",
linux/drivers/media/pci/bt8xx/bttv-cards.c:4027:		pr_info("%d: osprey eeprom: Changing card type from %d to %d\n",
linux/drivers/media/pci/bt8xx/bttv-cards.c:4034:/* AVermedia specific stuff, from  bktr_card.c                             */
linux/drivers/media/pci/cx18/cx18-fileops.c:476:	CX18_DEBUG_HI_FILE("read %zd from %s, got %zd\n", count, s->name, rc);
linux/drivers/media/pci/cx18/cx18-fileops.c:579:	CX18_DEBUG_HI_FILE("read %zd bytes from %s\n", count, s->name);
linux/drivers/media/pci/cx18/cx18-alsa-main.c:105:	/* sc->longname is read from /proc/asound/cards */
linux/drivers/media/pci/cx18/cx18-alsa-main.c:120:	/* Numbrs steps from "Writing an ALSA Driver" by Takashi Iwai */
linux/drivers/media/pci/cx18/cx18-ioctl.c:540:	CX18_DEBUG_INFO("Changing input from %d to %d\n",
linux/drivers/media/pci/tw5864/tw5864-reg.h:1559: * value from +36o (7Fh) to -36o (80h) with an increment of 2.8o. The 2 LSB has
linux/drivers/media/pci/ivtv/ivtv-queue.c:94:   If 'needed_bytes' == 0, then move all buffers from 'from' into 'to'.
linux/drivers/media/pci/ivtv/ivtv-queue.c:115:	int from_free = from == &s->q_free;
linux/drivers/media/pci/ivtv/ivtv-ioctl.c:995:	IVTV_DEBUG_INFO("Changing input from %d to %d\n",
linux/drivers/media/pci/ivtv/ivtv-ioctl.c:1043:	IVTV_DEBUG_INFO("Changing output from %d to %d\n",
linux/drivers/media/pci/ivtv/ivtv-alsa-main.c:102:	/* sc->longname is read from /proc/asound/cards */
linux/drivers/media/pci/ivtv/ivtv-alsa-main.c:117:	/* Numbrs steps from "Writing an ALSA Driver" by Takashi Iwai */
linux/drivers/media/pci/ivtv/ivtv-fileops.c:409:	IVTV_DEBUG_HI_FILE("read %zd from %s, got %zd\n", count, s->name, rc);
linux/drivers/media/pci/ivtv/ivtv-fileops.c:500:	IVTV_DEBUG_HI_FILE("read %zd bytes from %s\n", count, s->name);
linux/drivers/media/pci/ivtv/ivtv-udma.c:111:		IVTV_DEBUG_WARN("ivtv_udma_setup: Error %d page_count from %d bytes %d offset\n",
linux/drivers/media/pci/ivtv/ivtv-i2c.c:577:		IVTV_DEBUG_I2C("i2c read from %x failed\n", addr);
linux/drivers/media/common/videobuf2/frame_vector.c:21: * This function maps virtual addresses from @start and fills @vec structure
linux/drivers/media/v4l2-core/v4l2-mc.c:452: * from 0 to != 0 or from != 0 to 0.
linux/drivers/media/cec/core/cec-adap.c:1944:	/* Don't Feature Abort messages from 'Unregistered' */
linux/drivers/media/platform/ti/vpe/vpdma.c:428: * channels from @channels array of size @size.
linux/drivers/media/platform/ti/omap3isp/isppreview.c:890:			void __user *from = *(void __user **)
linux/drivers/media/platform/ti/omap3isp/isppreview.c:895:			if (to && from && size) {
linux/drivers/media/platform/renesas/rcar-vin/rcar-core.c:606:		vin_err(vin, "Error adding link from %s to %s: %d\n",
linux/drivers/media/platform/renesas/rcar-vin/rcar-core.c:1029:			vin_err(vin, "Error adding link from %s to %s\n",
linux/drivers/media/platform/renesas/rzg2l-cru/rzg2l-core.c:72:		dev_err(cru->dev, "Error creating link from %s to %s\n",
linux/drivers/media/platform/renesas/rzg2l-cru/rzg2l-core.c:86:		dev_err(cru->dev, "Error creating link from %s to %s\n",
linux/drivers/media/platform/allegro-dvt/nal-h264.c:390: * Read RBSP data from @src and use it to fill @sps.
linux/drivers/media/platform/allegro-dvt/nal-h264.c:392: * Return: number of bytes read from @src or negative error code
linux/drivers/media/platform/allegro-dvt/nal-h264.c:482: * Read RBSP data from @src and use it to fill @pps.
linux/drivers/media/platform/allegro-dvt/nal-h264.c:484: * Return: number of bytes read from @src or negative error code
linux/drivers/media/platform/allegro-dvt/nal-h264.c:561: * Read a filler data RBSP from @src up to a maximum size of @n bytes and
linux/drivers/media/platform/allegro-dvt/nal-hevc.c:559: * Read RBSP data from @src and use it to fill @vps.
linux/drivers/media/platform/allegro-dvt/nal-hevc.c:561: * Return: number of bytes read from @src or negative error code
linux/drivers/media/platform/allegro-dvt/nal-hevc.c:654: * Read RBSP data from @src and use it to fill @sps.
linux/drivers/media/platform/allegro-dvt/nal-hevc.c:656: * Return: number of bytes read from @src or negative error code
linux/drivers/media/platform/allegro-dvt/nal-hevc.c:749: * Read RBSP data from @src and use it to fill @pps.
linux/drivers/media/platform/allegro-dvt/nal-hevc.c:751: * Return: number of bytes read from @src or negative error code
linux/drivers/media/platform/allegro-dvt/nal-hevc.c:839: * Read a filler data RBSP from @src up to a maximum size of @n bytes and
linux/drivers/media/platform/microchip/microchip-isc.h:107:			This differs from 'bpp' in the sense that in planar
linux/drivers/media/platform/st/sti/bdisp/bdisp-hw.c:607:	tmp = (from << 10) / to;
linux/drivers/media/platform/st/stm32/stm32-dcmi.c:1335:		dev_dbg(dcmi->dev, "s_selection: crop %ux%u@(%u,%u) from %ux%u\n",
linux/drivers/media/platform/mediatek/vcodec/mtk_vcodec_enc.c:653:		/* Only support crop from (0,0) */
linux/drivers/media/platform/mediatek/vcodec/vdec/vdec_vp8_if.c:131: *		     once user remove fb from [fb_free_list],
linux/drivers/media/platform/mediatek/vcodec/vdec/vdec_vp8_if.c:134: *                   once user remove fb from [fb_disp_list] it is
linux/drivers/media/platform/mediatek/vcodec/vdec/vdec_vp9_req_lat_if.c:580:	mtk_vcodec_debug(instance, "resolution level changed, from %u to %u, %ux%u",
linux/drivers/media/platform/marvell/mcam-core.h:113:	int mclk_src;	/* which clock source the mclk derives from */
linux/drivers/media/platform/amphion/vpu_core.c:178:		vpu_trace(core->dev, "vpu core state change from %d to %d\n", core->state, state);
linux/drivers/media/platform/samsung/exynos-gsc/gsc-core.c:296:		pr_info("cropped src width size is recalculated from %d to %d",
linux/drivers/media/platform/samsung/exynos-gsc/gsc-core.c:304:		pr_info("cropped src height size is recalculated from %d to %d",
linux/drivers/media/platform/samsung/exynos-gsc/gsc-core.c:444:		pr_debug("Image size has been modified from %dx%d to %dx%d\n",
linux/drivers/media/platform/samsung/exynos-gsc/gsc-core.c:510:		pr_info("Cropped size has been modified from %dx%d to %dx%d",
linux/drivers/media/platform/nxp/imx8-isi/imx8-isi-hw.c:104:	unsigned int ratio = from / to;
linux/drivers/media/platform/nxp/imx8-isi/imx8-isi-hw.c:115:	return min_t(u32, from * 0x1000 / (to * *dec), ISI_DOWNSCALE_THRESHOLD);
linux/drivers/media/platform/nxp/imx8-isi/imx8-isi-crossbar.c:65:			"failed to get frame descriptor from '%s':%u: %d\n",
linux/drivers/media/firewire/firedtv-avc.c:92:	memset(&c->operand[from], 0, to - from + 1);
linux/drivers/media/firewire/firedtv-avc.c:99:	if (from <= to && to <= LAST_OPERAND)
linux/drivers/media/spi/cxd2880-spi.c:465:				pr_debug("removed PID %d from #%d\n",
linux/drivers/gpio/gpiolib-sysfs.c:654: * Set up a symlink from /sys/.../dev/name to /sys/class/gpio/gpioN
linux/drivers/gpio/gpio-realtek-otto.c:55: * a value from (to) these registers. The IMR register consists of four 16-bit
linux/drivers/gpio/gpio-ich.c:466:	dev_info(dev, "GPIO from %d to %d\n", ichx_priv.chip.base,
linux/drivers/gpio/gpio-max732x.c:50: * GPIO numbers start from 'gpio_base + 0' to 'gpio_base + 8/16',
linux/drivers/gpio/TODO:48:  numberspace accessors from <linux/gpio.h> and eventually delete
linux/drivers/gpio/gpiolib.c:3402:	 * IRQ is referenced from .to_irq()) we set up a label here
linux/drivers/gpio/gpiolib-acpi.c:874: * @index: index of GpioIo/GpioInt resource (starting from %0)
linux/drivers/gpio/gpiolib-acpi.c:880: * are total %3 GPIO resources, the index goes from %0 to %2.
linux/drivers/gpio/gpiolib-acpi.c:930: * @index: index of GpioIo/GpioInt resource (starting from %0)
linux/drivers/gpio/gpiolib-acpi.c:1033: * @index: index of GpioInt resource (starting from %0)
linux/drivers/scsi/esp_scsi.c:1036:	esp_log_reset("esp_schedule_reset() from %ps\n",
linux/drivers/scsi/mpi3mr/mpi3mr_os.c:4505:			    "truncating param_len from (%d) to (%d)\n",
linux/drivers/scsi/mpi3mr/mpi3mr_fw.c:1141:		    "cannot increase reply size from %d to %d\n",
linux/drivers/scsi/mpi3mr/mpi3mr_fw.c:1148:		    "cannot reduce number of operational reply queues from %d to %d\n",
linux/drivers/scsi/mpi3mr/mpi3mr_fw.c:1156:		    "cannot reduce number of operational request queues from %d to %d\n",
linux/drivers/scsi/mpi3mr/mpi3mr_fw.c:1173:				"failed to increase removepend_bitmap bits from %d to %d\n",
linux/drivers/scsi/mpi3mr/mpi3mr_fw.c:1181:			 "increased bits of dev_handle_bitmap from %d to %d\n",
linux/drivers/scsi/lpfc/lpfc_init.c:381:					"2701 FA-PWWN change WWPN from %llx to "
linux/drivers/scsi/lpfc/lpfc_init.c:522:				"3359 HBA queue depth changed from %d to %d\n",
linux/drivers/scsi/lpfc/lpfc_init.c:4078:				"3157 ELS xri-sgl count increased from "
linux/drivers/scsi/lpfc/lpfc_init.c:4118:				"3158 ELS xri-sgl count decreased from "
linux/drivers/scsi/lpfc/lpfc_init.c:4199:				"6302 NVMET xri-sgl cnt grew from %d to %d\n",
linux/drivers/scsi/lpfc/lpfc_init.c:4241:				"6305 NVMET xri-sgl count decreased from "
linux/drivers/scsi/lpfc/lpfc_init.c:7078:			"from %dMbps to %dMbps\n", prev_ll_spd,
linux/drivers/scsi/lpfc/lpfc_init.c:10247:				"3361 HBA queue depth changed from %d to %d\n",
linux/drivers/scsi/lpfc/lpfc_hbadisc.c:3010:				"2848 Remove ineligible FCF (x%x) from "
linux/drivers/scsi/lpfc/lpfc_hbadisc.c:4924: * to phba from @ndlp can be obtained indirectly through it's reference to
linux/drivers/scsi/lpfc/lpfc_scsi.c:782: * The routine copies the entire FCP command from @fcp_cmnd to @data while
linux/drivers/scsi/lpfc/lpfc_scsi.c:3106:					" %s: Too many sg segments from "
linux/drivers/scsi/lpfc/lpfc_sli.c:435: * This routine will get the first valid Event Queue Entry from @q, update
linux/drivers/scsi/lpfc/lpfc_sli.c:676: * This routine will get the first valid Completion Queue Entry from @q, update
linux/drivers/scsi/lpfc/lpfc_sli.c:3232:	lpfc_nvmeio_data(phba, "NVME LS    RCV: xri x%x sz %d from %06x\n",
linux/drivers/scsi/lpfc/lpfc_attr.c:2475:		"3051 lpfc_poll changed from %d to %d\n",
linux/drivers/scsi/lpfc/lpfc_attr.c:2567:				"3068 lpfc_enable_bbcr changed from %d to "
linux/drivers/scsi/lpfc/lpfc_attr.c:2692:			"3052 lpfc_" #attr " changed from %d to %d\n", \
linux/drivers/scsi/lpfc/lpfc_attr.c:2849:			" changed from %d (x%x) to %d (x%x)\n", \
linux/drivers/scsi/lpfc/lpfc_attr.c:4155:			"3054 lpfc_topology changed from %d to %d\n",
linux/drivers/scsi/lpfc/lpfc_attr.c:4259:		"3055 lpfc_link_speed changed from %d to %d %s\n",
linux/drivers/scsi/lpfc/lpfc_attr.c:4966:				"%d of %d CPUs online from %d possible CPUs\n",
linux/drivers/scsi/lpfc/lpfc_nvme.c:1368:					"6058 Too many sg segments from "
linux/drivers/scsi/lpfc/lpfc_mbox.c:2179: * fields from @vport. INIT_VFI configures virtual fabrics identified by VFI
linux/drivers/scsi/lpfc/lpfc_mbox.c:2211: * fields from @vport, and uses @buf as a DMAable buffer to send the vport's
linux/drivers/scsi/lpfc/lpfc_nvmet.c:2249:				 "from %06x\n",
linux/drivers/scsi/lpfc/lpfc_nvmet.c:2277:	lpfc_nvmeio_data(phba, "NVMET FCP DROP: xri x%x sz %d from %06x\n",
linux/drivers/scsi/lpfc/lpfc_bsg.c:4748:		from = pmbx;
linux/drivers/scsi/lpfc/lpfc_bsg.c:4749:		ext = from + sizeof(MAILBOX_t);
linux/drivers/scsi/aha1740.c:145:	printk("makecode from %x,%x,%x,%x %x,%x,%x,%x",
linux/drivers/scsi/scsi_proc.c:246: * scsi_proc_host_rm - remove this host's entry from /proc
linux/drivers/scsi/pmcraid.c:300:		/* first time initialization (called from  probe) */
linux/drivers/scsi/aic7xxx/aic79xx_core.c:1981:				printk("Unexpected command phase from "
linux/drivers/scsi/aic7xxx/aic79xx_core.c:10649:		printk("Incoming command from %d for %d:%d%s\n",
linux/drivers/scsi/aic7xxx/aic7xxx_core.c:1193:		printk("%s:%c:%d: Warning - unknown message received from "
linux/drivers/scsi/aic7xxx/aic7xxx_core.c:7827:	printk("Incoming command from %d for %d:%d%s\n",
linux/drivers/scsi/aic7xxx/aic79xx.h:886:#define		CFBOOTLUN	0x0f00	/* Lun to boot from */
linux/drivers/scsi/aic7xxx/aic79xx.h:887:#define		CFBOOTID	0xf000	/* Target to boot from */
linux/drivers/scsi/aic7xxx/aic7xxx.h:841:#define		CFBOOTLUN	0x0f00	/* Lun to boot from */
linux/drivers/scsi/aic7xxx/aic7xxx.h:842:#define		CFBOOTID	0xf000	/* Target to boot from */
linux/drivers/scsi/scsi_lib.c:3036:	/* Bytes in this sg-entry from *offset to the end of the page */
linux/drivers/scsi/qedf/qedf_els.c:816:		    "Reissued SCSI command from  orig_xid=0x%x on "
linux/drivers/scsi/wd719x.c:364:	/* address to read firmware from */
linux/drivers/scsi/isci/request.c:1315:/* transmit DATA_FIS from (current sgl + offset) for input
linux/drivers/scsi/imm.c:150:#define imm_fail(x,y) printk("imm: imm_fail(%i) from %s at line %d\n",\
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:505:			"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:513:			"failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:541:				"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:549:				"failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:568:				"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:605:			"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:617:				"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:639:			"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:655:				"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:678:				"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:689:				"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:700:			"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:724:			"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:733:			"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:755:				"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:766:				"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:807:			"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:827:			"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:847:				"Failed from %s %d\n",  __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:873:					"Failed from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:1321:			"Could not get mfi cmd. Fail from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:1908:			"Could not get controller info. Fail from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:1964:						"Failed from %s %d, do not re-arm timer\n",
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:1994:		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:4076:				"Host diag unlock failed from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:4365:				"return -EBUSY from %s %d cmd 0x%x opcode 0x%x\n",
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:4547:		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:4712:				" without JBOD MAP support from %s %d\n", __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:5071:					"Failed from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:5297:		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_fusion.c:5314:			dev_err(&instance->pdev->dev, "Failed from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:1130:		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:1159:		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:1225:		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:5617:			"Fail from %s %d\n", instance->unique_id,
linux/drivers/scsi/megaraid/megaraid_sas_base.c:5687:				"Failed to register IRQ from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:5815:				"Failed to allocate memory from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:6080:			 "Failed to transition controller to ready from %s!\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:6106:			 "FW restarted successfully from %s!\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:6542:	dev_err(&instance->pdev->dev, "Failed from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:6619:		dev_err(&instance->pdev->dev, "Failed from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:6865:			"return from %s %d return value %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:6978:			"Failed to add host from %s %d\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:7668:			"return from %s %d\n", __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_base.c:7720:			"return from %s %d\n", __func__, __LINE__);
linux/drivers/scsi/megaraid/megaraid_sas_base.c:7803:			 "Failed to transition controller to ready from %s!\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:7826:			 "FW restarted successfully from %s!\n",
linux/drivers/scsi/megaraid/megaraid_sas_base.c:8395:			"return -EBUSY from %s %d cmd 0x%x opcode 0x%x cmd->cmd_status_drv 0x%x\n",
linux/drivers/scsi/megaraid/megaraid_sas_fp.c:1043:			dev_info(&instance->pdev->dev, "return from %s %d."
linux/drivers/scsi/megaraid/megaraid_sas_fp.c:1056:			dev_info(&instance->pdev->dev, "return from %s %d"
linux/drivers/scsi/esas2r/esas2r_flash.c:1016:			iatvr = MW_DATA_ADDR_SER_FLASH + (from & -WINDOW_SIZE);
linux/drivers/scsi/esas2r/esas2r_flash.c:1018:			iatvr = MW_DATA_ADDR_PAR_FLASH + (from & -WINDOW_SIZE);
linux/drivers/scsi/esas2r/esas2r_flash.c:1021:		offset = from & (WINDOW_SIZE - 1);
linux/drivers/scsi/esas2r/esas2r_flash.c:1027:		from += len;
linux/drivers/scsi/esas2r/esas2r_main.c:1292:		iatvr = (from & -(signed int)MW_DATA_WINDOW_SIZE);
linux/drivers/scsi/esas2r/esas2r_main.c:1296:		offset = from & (MW_DATA_WINDOW_SIZE - 1);
linux/drivers/scsi/esas2r/esas2r_main.c:1302:		from += len;
linux/drivers/scsi/a100u2w.h:285:        /* from "CTRL-I SCSI Host Adapter SetUp menu "  */
linux/drivers/scsi/a100u2w.h:293:        /* from "CTRL-I SCSI device SetUp menu "                        */
linux/drivers/scsi/a100u2w.h:318:        /* from "CTRL-I SCSI device SetUp menu "                                          */
linux/drivers/scsi/mesh.c:1230:				       "(%d != %llu) on reselection from "
linux/drivers/scsi/sym53c8xx_2/sym53c8xx.h:49: *  These options are not tunable from 'make config'
linux/drivers/scsi/sym53c8xx_2/sym_fw2.h:603:	 *  since we may have to tamper the start queue from 
linux/drivers/scsi/sym53c8xx_2/sym_fw1.h:614:	 *  since we may have to tamper the start queue from 
linux/drivers/scsi/sym53c8xx_2/sym_hipd.c:2263:	printf("%s: SCSI BUS mode change from %s to %s.\n", sym_name(np),
linux/drivers/scsi/sym53c8xx_2/sym_hipd.c:3100:		 *  If we are currently using anything different from 
linux/drivers/scsi/sym53c8xx_2/sym_hipd.c:5345: *  can safely access IO registers and remove JOBs from  
linux/drivers/scsi/sym53c8xx_2/sym_glue.h:132: *  These ones are used as return code from 
linux/drivers/scsi/fcoe/fcoe_ctlr.c:1375:	 * Actually need to subtract 'sizeof(*mp) - sizeof(*wp)' from 'rlen'
linux/drivers/scsi/fcoe/fcoe_ctlr.c:2608:				"ignoring claim from %x\n",
linux/drivers/scsi/snic/snic_debugfs.c:66: * copy up to @cnt of data to @ubuf from @buf.
linux/drivers/scsi/snic/snic_main.c:335:	SNIC_HOST_INFO(snic->shost, "snic state change from %s to %s\n",
linux/drivers/scsi/dc395x.c:1618:		 * transfer out from ... previous dc395x_statev
linux/drivers/scsi/dc395x.c:1849: * KG: Currently called from  StatusPhase1 ()
linux/drivers/scsi/dc395x.c:3602:		       "device_alloc: <%02i-%i> copy from <%02i-%i>\n",
linux/drivers/scsi/elx/libefc_sli/sli4.c:4137:		efc_log_info(sli4, "[%s]: max_qentries from %d to %d\n",
linux/drivers/scsi/ppa.c:163:#define ppa_fail(x,y) printk("ppa: ppa_fail(%i) from %s at line %d\n",\
linux/drivers/scsi/arm/fas216.c:371:	cmd_list[cmd_ptr].from = __builtin_return_address(0);
linux/drivers/scsi/script_asm.pl:871:"$0 : symbol $label is too far ($tmp) from $address to reference as 
linux/drivers/scsi/ncr53c8xx.c:3931:	**	Allow to override sync, wide and NOSCAN from 
linux/drivers/scsi/ncr53c8xx.c:5961:		printk("%s: SCSI bus mode change from %x to %x.\n",
linux/drivers/scsi/qla4xxx/ql4_os.c:5535:	DEBUG2(printk(KERN_INFO "%s: ioremap from %lx a size of %lx\n",
linux/drivers/scsi/qla4xxx/ql4_os.c:6980:					  "Updating NT parent idx from [%d] to [%d]\n",
linux/drivers/scsi/qla4xxx/ql4_os.c:9112:		ql4_printk(KERN_WARNING, ha, "scsi%ld: Return from %s\n",
linux/drivers/scsi/bnx2fc/bnx2fc_fcoe.c:1113:		BNX2FC_MISC_DBG("Sending FKA from %pM to %pM.\n",
linux/drivers/scsi/hpsa.c:4427:		/* Figure out where the LUN ID info is coming from */
linux/drivers/scsi/sd_zbc.c:733:					"Changing capacity from %llu to max LBA+1 %llu\n",
linux/drivers/scsi/libfc/fc_lport.c:1025:	FC_LPORT_DBG(lport, "Entered RESET state from %s state\n",
linux/drivers/scsi/libfc/fc_lport.c:1054:	FC_LPORT_DBG(lport, "Entered disabled state from %s state\n",
linux/drivers/scsi/libfc/fc_lport.c:1317:	FC_LPORT_DBG(lport, "Entered SCR state from %s state\n",
linux/drivers/scsi/libfc/fc_lport.c:1348:	FC_LPORT_DBG(lport, "Entered %s state from %s state\n",
linux/drivers/scsi/libfc/fc_lport.c:1414:	FC_LPORT_DBG(lport, "Entered DNS state from %s state\n",
linux/drivers/scsi/libfc/fc_lport.c:1448:	FC_LPORT_DBG(lport, "Entered %s state from %s state\n",
linux/drivers/scsi/libfc/fc_lport.c:1560:	FC_LPORT_DBG(lport, "Entered FDMI state from %s state\n",
linux/drivers/scsi/libfc/fc_lport.c:1700:	FC_LPORT_DBG(lport, "Entered LOGO state from %s state\n",
linux/drivers/scsi/libfc/fc_lport.c:1841:	FC_LPORT_DBG(lport, "Entered FLOGI state from %s state\n",
linux/drivers/scsi/libfc/fc_exch.c:1128:				 * which is totally different from "seq_id"
linux/drivers/scsi/libfc/fc_exch.c:2044:			     "REC request from %x: invalid rxid %x oxid %x\n",
linux/drivers/scsi/libfc/fc_exch.c:2051:			     "REC request from %x: rxid %x oxid %x not found\n",
linux/drivers/scsi/libfc/fc_exch.c:2055:	FC_EXCH_DBG(ep, "REC request from %x: rxid %x oxid %x\n",
linux/drivers/scsi/libfc/fc_exch.c:2319:	FC_EXCH_DBG(ep, "RRQ request from %x: xid %x rxid %x oxid %x\n",
linux/drivers/scsi/libfc/fc_rport.c:830:	FC_RPORT_DBG(rdata, "Entered FLOGI state from %s state\n",
linux/drivers/scsi/libfc/fc_rport.c:1082:	FC_RPORT_DBG(rdata, "Port entered PLOGI state from %s state\n",
linux/drivers/scsi/libfc/fc_rport.c:1275:	FC_RPORT_DBG(rdata, "Port entered PRLI state from %s state\n",
linux/drivers/scsi/libfc/fc_rport.c:1391:	FC_RPORT_DBG(rdata, "Port entered RTV state from %s state\n",
linux/drivers/scsi/libfc/fc_rport.c:1479:	FC_RPORT_DBG(rdata, "Port sending LOGO from %s state\n",
linux/drivers/scsi/libfc/fc_rport.c:1566:	FC_RPORT_DBG(rdata, "sending ADISC from %s state\n",
linux/drivers/scsi/qla2xxx/qla_init.c:5231:		       "FCPort %8phC state transitioned from %s to %s - portid=%02x%02x%02x.\n",
linux/drivers/scsi/BusLogic.c:1465:	   Termination Information from "W" series MultiMaster Host Adapters.
linux/drivers/scsi/BusLogic.c:1485:	   AutoSCSI data from "W" and "C" series MultiMaster Host Adapters.
linux/drivers/scsi/fnic/fnic_debugfs.c:92: * copy up to @cnt of data to @ubuf from @buf.
linux/drivers/scsi/fnic/fnic_debugfs.c:460: * copy up to @cnt of data to @ubuf from @buf.
linux/drivers/scsi/fnic/vnic_devcmd.h:102:	/* add addr from (u48)a0 */
linux/drivers/scsi/fnic/vnic_devcmd.h:106:	/* del addr from (u48)a0 */
linux/drivers/scsi/st.c:1054:		DEBC_printk(STp, "Mode change from %d to %d.\n",
linux/drivers/scsi/st.c:3217:				    "from %d to %d\n", STp->partition,
linux/drivers/scsi/xen-scsifront.c:1146:			 "SG entries decreased from %d to %u - device may not work properly anymore\n",
linux/drivers/scsi/advansys.c:9615: * Write the EEPROM from 'cfg_buf'.
linux/drivers/scsi/advansys.c:9682: * Write the EEPROM from 'cfg_buf'.
linux/drivers/scsi/advansys.c:9749: * Write the EEPROM from 'cfg_buf'.
linux/drivers/scsi/advansys.c:10830:	 * from /proc/scsi/advansys/[0...].
linux/drivers/scsi/mpt3sas/mpt3sas_scsih.c:9138: * _scsih_sas_pd_hide - hide pd component from /dev/sdX
linux/drivers/scsi/mpt3sas/mpt3sas_scsih.c:9987:			ioc_info(ioc, "\tbreak from %s: ioc_status(0x%04x), loginfo(0x%08x)\n",
linux/drivers/scsi/mpt3sas/mpt3sas_transport.c:936:				    "remove vphy entry: %p of port:%p,from %d port's vphys list\n",
linux/drivers/scsi/scsi_debug.c:2979:		/* needs work to find which cdb byte 'num' comes from */
linux/drivers/scsi/sd.c:2744:			  "data from %d to %d bytes\n", len, SD_BUF_SIZE);
linux/drivers/block/loop.c:1146:	 * thus an open device.  When called from ->release we are guaranteed
linux/drivers/block/mtip32xx/mtip32xx.c:3528:	/* Delete our gendisk. This also removes the device from /dev */
linux/drivers/block/rnbd/rnbd-clt.c:80:	rnbd_clt_info(dev, "Device size changed from %llu to %llu sectors\n",
linux/drivers/block/aoe/aoenet.c:165:				"aoe: error packet from ",
linux/drivers/block/ps3vram.c:433:	if (from >= priv->size)
linux/drivers/block/ps3vram.c:445:		offset = (unsigned int) (from & (priv->cache.page_size - 1));
linux/drivers/block/ps3vram.c:461:		from += avail;
linux/drivers/block/floppy.c:1600:		  "calling disk change from %s\n", __func__);
linux/drivers/block/xen-blkback/xenbus.c:730:			pr_warn("changing physical device (from %x:%x to %x:%x) not supported.\n",
linux/drivers/block/nbd.c:608:		request.from = cpu_to_be64((u64)blk_rq_pos(req) << 9);
linux/drivers/block/drbd/drbd_main.c:386:		drbd_info(resource, "Starting %s thread (from %s [%d])\n",
linux/drivers/block/drbd/drbd_main.c:426:		drbd_info(resource, "Restarting %s thread (from %s [%d])\n",
linux/drivers/block/drbd/drbd_receiver.c:3532:			     "automatically solved. Sync from %s node\n",
linux/drivers/block/drbd/drbd_receiver.c:3550:			     "Sync from %s node\n",
linux/drivers/block/drbd/drbd_worker.c:137:	 * Removed from the tree from "drbd_process_done_ee" within the
linux/drivers/block/drbd/drbd_worker.c:706:		 * reset the offset to start the next drbd_bm_find_next from */
linux/drivers/target/target_core_alua.c:1098:	 * For all other LU groups aside from 'default_lu_gp', walk all of
linux/drivers/target/sbp/sbp_target.c:293:	pr_notice("mgt_agent LOGIN to LUN %d from %016llx\n",
linux/drivers/target/sbp/sbp_target.c:509:	pr_notice("mgt_agent RECONNECT from %016llx\n", guid);
linux/drivers/target/target_core_configfs.c:2615:			pr_err("Only %d from %d port groups definitions "
linux/drivers/target/target_core_configfs.c:2923:				" from %s\n", page);
linux/drivers/target/target_core_configfs.c:3408:	 * core_alua_free_tg_pt_gp() is called from ->default_tg_pt_gp
linux/drivers/target/iscsi/iscsi_target_login.c:725:		pr_debug("iSCSI Login successful on CID: %hu from %pISpc to"
linux/drivers/target/iscsi/iscsi_target_login.c:772:	pr_debug("iSCSI Login successful on CID: %hu from %pISpc to %pISpc,%hu\n",
linux/drivers/target/iscsi/iscsi_target_login.c:1291:	pr_debug("Received iSCSI login request from %pISpc on %s Network"
linux/drivers/target/iscsi/iscsi_target_erl0.c:901:			" Connection ID: %hu from %s\n", conn->cid,
linux/drivers/target/iscsi/iscsi_target_nego.c:195:			" from %d to %d, login failed.\n", login->current_stage,
linux/drivers/target/target_core_spc.c:2096:			" with unsupported REPORTING OPTIONS %#x for 0x%08llx from %s\n",
linux/drivers/target/target_core_pr.c:278:			" from %s \n", cmd->se_lun->unpacked_lun,
linux/drivers/target/target_core_pr.c:1099:		 * obtained from  __core_scsi3_alloc_registration() code.
linux/drivers/target/target_core_pr.c:2586:			" reservation from [%s]: %s with different TYPE "
linux/drivers/target/target_core_user.c:3253:		pr_debug("Freed %u pages (total %u) from %u blocks (total %u) from %s.\n",
linux/drivers/target/target_core_device.c:101:				" Access for 0x%08llx from %s\n",
linux/drivers/target/target_core_device.c:507:		pr_info("Rounding down aligned max_sectors from %u to %u\n",
linux/drivers/target/tcm_fc/tfc_io.c:141:			from = kmap_atomic(page + (mem_off >> PAGE_SHIFT));
linux/drivers/target/tcm_fc/tfc_io.c:143:			from += offset_in_page(mem_off);
linux/drivers/target/tcm_fc/tfc_io.c:265:	from = fc_frame_payload_get(fp, 0);
linux/drivers/target/tcm_fc/tfc_io.c:308:		from += tlen;
linux/drivers/input/touchscreen/silead.c:416:	 * UEFI driver when the firmware is missing from /lib/firmware. This makes the
linux/drivers/input/serio/i8042.c:1122: * not see the console and will help distinguishing panics from "real"
linux/drivers/input/mouse/sentelic.h:104:	unsigned char	last_reg;	/* Last register we requested read from */
linux/drivers/input/mouse/cyapa.c:1020:		dev_err(dev, "Could not load firmware from %s: %d\n",
linux/drivers/input/mouse/alps.c:313:	 * from (!fin && ges) to (fin && ges). This should be translated to the
linux/drivers/input/input.c:2569:	 * Since we are supposed to be called from ->connect()
linux/drivers/input/rmi4/rmi_driver.c:1169:		dev_warn(dev, "Could not read PDT properties from %#06x (code %d). Assuming 0x00.\n",
linux/drivers/input/joystick/zhenhua.c:3: *  derived from "twidjoy.c"
linux/drivers/input/joystick/xpad.c:16: *  - information from     http://euc.jp/periphs/xbox-controller.ja.html
linux/drivers/input/Kconfig:109:	  the same as the data from /dev/input/mice.
linux/drivers/input/keyboard/gpio_keys.c:237: * This function parses stringified bitmap from @buf and disables/enables
linux/drivers/input/keyboard/applespi.c:1080:		if (trans->from == key)
linux/drivers/memstick/host/r592.c:580:				dbg("IO: unknown error from "
linux/drivers/video/logo/pnmtologo.c:238:	fprintf(out, " *  It was automatically generated from %s\n", filename);
linux/drivers/video/fbdev/sm501fb.c:2141:	dev_dbg(info->dev, "restoring screen from %p\n", par->store_fb);
linux/drivers/video/fbdev/sm501fb.c:2142:	dev_dbg(info->dev, "restoring cursor from %p\n", par->store_cursor);
linux/drivers/video/fbdev/riva/fbdev.c:610: * Loads chip state from @regs.
linux/drivers/video/fbdev/core/fb_defio.c:167:	 * We want the page to remain locked from ->page_mkwrite until
linux/drivers/video/fbdev/core/fbcmap.c:163: *	Copy contents of colormap from @from to @to.
linux/drivers/video/fbdev/omap2/omapfb/dss/omapdss-boot-init.c:10: * encoder nodes from "panel-foo" to "omapdss,panel-foo". This way we can have
linux/drivers/video/fbdev/omap2/omapfb/dss/display.c:212:	if (from == NULL) {
linux/drivers/video/fbdev/atafb_iplan2p8.c:24:/* Copies a 8 plane column from 's', height 'h', to 'd'. */
linux/drivers/video/fbdev/sis/sis_main.c:732:					DPRINTK("sisfb: Adjusting rate from %d up to %d\n",
linux/drivers/video/fbdev/sis/sis_main.c:738:					DPRINTK("sisfb: Adjusting rate from %d down to %d\n",
linux/drivers/video/fbdev/sis/sis_main.c:745:				DPRINTK("sisfb: Adjusting rate from %d down to %d\n",
linux/drivers/video/fbdev/sis/sis_main.c:1529:				"sisfb: Adapted from %dx%dx%d to %dx%dx%d\n",
linux/drivers/video/fbdev/intelfb/intelfbdrv.c:1074:	DBG_MSG("Initial video mode is from %d.\n", msrc);
linux/drivers/video/console/mdacon.c:161:	if (mda_cursor_size_from==from && mda_cursor_size_to==to)
linux/drivers/video/console/mdacon.c:164:	if (from > to) {
linux/drivers/video/console/vgacon.c:453:	if ((from == cursor_size_lastfrom) && (to == cursor_size_lastto))
linux/drivers/firmware/efi/fdtparams.c:112:			pr_info("Getting UEFI parameters from %s in DT:\n",
linux/drivers/firmware/efi/esrt.c:330:	pr_info("Reserving ESRT space from %pa to %pa.\n", &esrt_data, &end);
linux/drivers/firmware/cirrus/cs_dsp.c:840:		cs_dsp_err(dsp, "Failed to read %zu bytes from %x: %d\n",
linux/drivers/firmware/cirrus/cs_dsp.c:845:	cs_dsp_dbg(dsp, "Read %zu bytes from %x\n", len, reg);
linux/drivers/firmware/arm_scmi/driver.c:628: * removing xfer from @pending_xfers and putting it back into free_xfers.
linux/drivers/firmware/raspberrypi.c:194:	dev_info(fw->cl.dev, "Attached to firmware from %ptT\n", &date_and_time);
linux/drivers/firmware/dmi_scan.c:991:	const struct list_head *head = from ? &from->list : &dmi_devices;
linux/drivers/firmware/memmap.c:106:		 * map_entries_bootmem here, and deleted from &map_entries in
linux/drivers/thunderbolt/switch.c:2844: * Sets the link upstream from @sw configured (from both ends) so that
linux/drivers/thunderbolt/usb4.c:1602: * @buf: Data from @reg is stored here
linux/drivers/thunderbolt/usb4.c:1605: * Function reads retimer sideband registers starting from @reg. The
linux/drivers/thunderbolt/usb4.c:1623: * @buf: Data that is written starting from @reg
linux/drivers/thunderbolt/usb4.c:1626: * Writes retimer sideband registers starting from @reg. The retimer is
linux/drivers/thunderbolt/usb4.c:1750: * Writes @size bytes from @buf to the retimer NVM. Used for NVM
linux/drivers/thunderbolt/usb4.c:2522: * Reads the programmed granularity from @port. If the DP IN adapter does
linux/drivers/thunderbolt/tunnel.c:968:	tb_port_dbg(in, "bandwidth from %#x capability %d Mb/s\n", cap,
linux/drivers/thunderbolt/tunnel.c:2153: * @consumed_up: Consumed bandwidth in Mb/s from @dst_port to @src_port.
linux/drivers/thunderbolt/tunnel.c:2155: * @consumed_down: Consumed bandwidth in Mb/s from @src_port to @dst_port.
linux/drivers/thunderbolt/tunnel.c:2221: * Reclaims bandwidth from @available_up and @available_down and updates
linux/drivers/thunderbolt/lc.c:321: * Tells LC to disconnect the internal xHCI from @port. Can be called
linux/drivers/thunderbolt/lc.c:594: * De-allocate DP sink from @in using LC SNK_ALLOCATION registers.
linux/drivers/thunderbolt/nvm.c:458: * written to the flash. Copies @bytes from @val to @nvm->buf starting
linux/drivers/thunderbolt/nvm.c:459: * from @offset.
linux/drivers/thunderbolt/tb.h:359: * @next_hop_index: HopID of the packet when it is routed out from @out_port
linux/drivers/thunderbolt/tb.h:1068: * Walks over each port on path from @src to @dst.
linux/drivers/thunderbolt/xdomain.c:850: * Registers new service driver from @drv to the bus.
linux/drivers/thunderbolt/xdomain.c:1371:		dev_err(&xd->dev, "failed read XDomain properties from %pUb\n",
linux/drivers/thunderbolt/xdomain.c:2113: * @receive_ring: DMA ring used to receive packets from @receive_path
linux/drivers/thunderbolt/xdomain.c:2138: * @receive_ring: DMA ring used to receive packets from @receive_path
linux/drivers/thunderbolt/acpi.c:85:			dev_dbg(&nhi->pdev->dev, "created link from %s\n",
linux/drivers/thunderbolt/acpi.c:88:			dev_warn(&nhi->pdev->dev, "device link creation from %s failed\n",
linux/drivers/thunderbolt/domain.c:788: * @receive_ring: DMA ring used to receive packets from @receive_path
linux/drivers/thunderbolt/domain.c:815: * @receive_ring: DMA ring used to receive packets from @receive_path
linux/drivers/thunderbolt/path.c:90: * Follows a path starting from @src and @src_hopid to the last output
linux/drivers/thunderbolt/path.c:169:	tb_dbg(path->tb, "discovering %s path starting from %llx:%u\n",
linux/drivers/thunderbolt/path.c:231: * HopIDs for each port (they can be different from @src_hopid depending on
linux/drivers/thunderbolt/path.c:471:	       "deactivating %s path from %llx:%u to %llx:%u\n",
linux/drivers/thunderbolt/path.c:500:	       "activating %s path from %llx:%u to %llx:%u\n",
linux/drivers/thunderbolt/ctl.c:882: * @port: Port number when reading from %TB_CFG_PORT, %0 otherwise
linux/drivers/thunderbolt/ctl.c:1057:		tb_ctl_warn(ctl, "%llx: timeout reading config space %u from %#x\n",
linux/drivers/thunderbolt/tb.c:2269:			dev_dbg(&nhi->pdev->dev, "created link from %s\n",
linux/drivers/thunderbolt/tb.c:2272:			dev_warn(&nhi->pdev->dev, "device link creation from %s failed\n",
linux/drivers/md/dm-thin.c:3496:			DMINFO("%s: growing the data device from %llu to %llu blocks",
linux/drivers/md/dm-thin.c:3543:		DMINFO("%s: growing the metadata device from %llu to %llu blocks",
linux/drivers/md/dm-thin.c:3803:		DMWARN("Failed to change transaction id from %s to %s.",
linux/drivers/md/dm-era-target.c:586:		DMERR("changing the data block size (from %u to %llu) is not supported",
linux/drivers/md/raid5-cache.c:93:					 * starts from */
linux/drivers/md/dm-zoned-metadata.c:2366: * Set @nr_bits bits in @bitmap starting from @bit.
linux/drivers/md/dm-zoned-metadata.c:2689: * Find the first valid block from @chunk_block in @zone.
linux/drivers/md/dm-zoned-metadata.c:2691: * @chunk_block and the total number of valid blocks from @chunk_block
linux/drivers/md/persistent-data/dm-btree.h:146: * Removes a _contiguous_ run of values starting from 'keys' and not
linux/drivers/md/persistent-data/dm-transaction-manager.h:71: * dm_tm_shadow_block() allocates a new block and copies the data from @orig
linux/drivers/md/md-cluster.c:611:		pr_warn("%s:%d Received unknown message from %d\n",
linux/drivers/md/dm-cache-metadata.c:484:		DMERR("changing the data block size (from %u to %llu) is not supported",
linux/drivers/md/dm-thin-metadata.c:698:		DMERR("changing the data block size (from %u to %llu) is not supported",
linux/drivers/md/dm-table.c:526:			/* Everything apart from '\0' can be quoted */
linux/drivers/md/raid5.c:7031:	pr_debug("md/raid: change stripe_size from %lu to %lu\n",
linux/drivers/md/raid5.c:7867:		 * from */
linux/drivers/md/md.c:6907:	pr_debug("md: cannot remove active disk %pg from %s ...\n",
linux/drivers/md/dm-raid1.c:1284:		DMERR("Mirror read failed from %s. Trying alternative device.",
linux/drivers/md/raid10.c:3540:				/* This is where we read from */
linux/drivers/md/raid10.c:5132:	/* reshape IOs share pages from .devs[0].bio */
linux/drivers/md/dm-raid.c:667:/* Return raid_type for @name based derived from @level and @layout */
linux/drivers/md/dm-raid.c:2273:				DMERR("Takeover raid sets from %s to %s not yet supported by metadata. (raid level change)",
linux/drivers/md/dm-raid.c:3360:/* Return enum sync_state for @mddev derived from @recovery flags */
linux/drivers/md/bcache/request.c:113:	pr_debug("invalidating %i sectors from %llu\n",
linux/drivers/md/bcache/btree.c:2512:			from = NULL;
linux/drivers/md/bcache/btree.c:2546:		from = NULL;
linux/drivers/md/md.h:279:	MD_SB_CHANGE_CLEAN,	/* transition to or from 'clean' */
linux/drivers/md/md.h:280:	MD_SB_CHANGE_PENDING,	/* switch from 'clean' to 'active' in progress */
linux/drivers/md/raid1.c:1272:		/* couldn't find anywhere to read from */
linux/drivers/md/md-autodetect.c:114:	printk(KERN_INFO "md: Will configure md%d (%s) from %s, below.\n",
linux/drivers/gpu/drm/rcar-du/rcar_du_plane.c:42: * updates from .atomic_check() up to completion (when swapping the states if
linux/drivers/gpu/drm/panel/panel-sharp-lq101r1sx01.c:82:		dev_err(&sharp->link1->dev, "failed to read from %04x: %zd\n",
linux/drivers/gpu/drm/drm_mm.c:652: * drm_mm_replace_node - move an allocation from @old to @new
linux/drivers/gpu/drm/drm_rect.c:85: * factors from @src to @dst.
linux/drivers/gpu/drm/drm_bufs.c:1347:			struct drm_buf_entry *from = &dma->bufs[i];
linux/drivers/gpu/drm/panfrost/panfrost_gpu.c:342:		dev_info_once(pfdev->dev, "using only 1st core group (%lu cores from %lu)\n",
linux/drivers/gpu/drm/drm_cache.c:282: * __drm_memcpy_from_wc copies @len bytes from @src to @dst using
linux/drivers/gpu/drm/radeon/si.c:5065:	printk("VM fault (0x%02x, vmid %d) at page %u, %s from %s (%d)\n",
linux/drivers/gpu/drm/radeon/radeon_object.c:580:		DRM_DEBUG("stealing surface reg %d from %p\n", steal, old_object);
linux/drivers/gpu/drm/radeon/ni.c:2664:	printk("VM fault (0x%02x, vmid %d) at page %u, %s from %s (%d)\n",
linux/drivers/gpu/drm/radeon/cik.c:5665:	printk("VM fault (0x%02x, vmid %d) at page %u, %s from '%s' (0x%08x) (%d)\n",
linux/drivers/gpu/drm/radeon/radeon_atombios.c:1253:				DRM_INFO("Changing default dispclk from %dMhz to 600Mhz\n",
linux/drivers/gpu/drm/radeon/radeon_encoders.c:238:			DRM_DEBUG_KMS("setting active device to %08x from %08x %08x for encoder %d\n",
linux/drivers/gpu/drm/rockchip/rockchip_drm_drv.h:44: * @crtc: array of enabled CRTCs, used to map from "pipe" to drm_crtc.
linux/drivers/gpu/drm/qxl/qxl_cmd.c:392:	DRM_DEBUG_DRIVER("mem = %llx, from %p\n", create->mem, bo->kptr);
linux/drivers/gpu/drm/drm_context.c:277:	DRM_DEBUG("Context switch from %d to %d\n", old, new);
linux/drivers/gpu/drm/drm_format_helper.c:949:	drm_warn_once(fb->dev, "No conversion helper from %p4cc to %p4cc found.\n",
linux/drivers/gpu/drm/vc4/vc4_validate.c:780:			  "from %d bytes left\n",
linux/drivers/gpu/drm/vc4/vc4_validate.c:790:			  "from %d bytes left\n",
linux/drivers/gpu/drm/vc4/vc4_drv.h:519:	/* Bitmask of channels (FIFOs) of the HVS that the output can source from */
linux/drivers/gpu/drm/amd/amdgpu/gmc_v8_0.c:1015:	dev_err(adev->dev, "VM fault (0x%02x, vmid %d, pasid %d) at page %u, %s from '%s' (0x%08x) (%d)\n",
linux/drivers/gpu/drm/amd/amdgpu/gmc_v6_0.c:616:	dev_err(adev->dev, "VM fault (0x%02x, vmid %d) at page %u, %s from '%s' (0x%08x) (%d)\n",
linux/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c:74:			DRM_DEBUG_KMS("setting active device to %08x from %08x %08x for encoder %d\n",
linux/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c:288: * The function copies @size bytes from {src->mem + src->offset} to
linux/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c:679:			DRM_DEBUG("Changing default dispclk from %dMhz to 600Mhz\n",
linux/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c:683:			DRM_DEBUG("Changing default dispclk from %dMhz to 625Mhz\n",
linux/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c:775:	dev_err(adev->dev, "VM fault (0x%02x, vmid %d, pasid %d) at page %u, %s from '%s' (0x%08x) (%d)\n",
linux/drivers/gpu/drm/amd/amdgpu/amdgpu_sync.c:348: * removes signaled fences from @source while at it.
linux/drivers/gpu/drm/amd/pm/amdgpu_pm.c:1938: * smartshift(SS2.0) bias level. The value ranges from -100 to 100
linux/drivers/gpu/drm/amd/amdkfd/kfd_svm.c:2987:	pr_debug("switching xnack from %d to %d\n", p->xnack_enabled, xnack_enabled);
linux/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_pp_smu.c:338:				DRM_INFO("DM_PPLIB: reducing engine clock level from %d to %d\n",
linux/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_pp_smu.c:347:				DRM_INFO("DM_PPLIB: reducing memory clock level from %d to %d\n",
linux/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_irq.c:604:			DRM_DEBUG("Queued work for handling interrupt from "
linux/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c:412:			DRM_DEBUG_DRIVER("[HDCP_DM] encryption_status change from %x to %x\n",
linux/drivers/gpu/drm/amd/display/dc/dc_types.h:117: * num  from  PIXEL_FORMAT_INDEX8 to PIXEL_FORMAT_444BPP32
linux/drivers/gpu/drm/amd/display/dc/link/protocols/link_dpcd.c:209:	/* size of the next partition to be read from */
linux/drivers/gpu/drm/amd/display/dc/dml/dcn32/display_mode_vba_util_32.c:1147:				dml_print("DML::%s: j=%0d, DETBufferSizeInKByte[%0d] increases from %0d ",
linux/drivers/gpu/drm/meson/meson_vclk.c:702:	/* Cycle from /16 to /2 */
linux/drivers/gpu/drm/arm/display/komeda/komeda_pipeline.h:139:	/** @component: indicate which component the data comes from */
linux/drivers/gpu/drm/drm_mode_object.c:98: * Free @id from @dev's unique identifier pool.
linux/drivers/gpu/drm/drm_gem_atomic_helper.c:122: * This function extracts the exclusive fence from &drm_gem_object.resv and
linux/drivers/gpu/drm/drm_gem_framebuffer_helper.c:333: * is different from @map if the framebuffer's offsets field is non-zero.
linux/drivers/gpu/drm/drm_probe_helper.c:579:		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %s to %s\n",
linux/drivers/gpu/drm/drm_probe_helper.c:797:				      "status updated from %s to %s\n",
linux/drivers/gpu/drm/drm_probe_helper.c:932:	drm_dbg_kms(dev, "[CONNECTOR:%d:%s] status updated from %s to %s\n",
linux/drivers/gpu/drm/vmwgfx/vmwgfx_blit.c:256: * @diff_offs: The offset from @diff->line_offset where the difference was
linux/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c:701: * @data:           Pointer to data copied from / to user-space.
linux/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c:718: * @data:           Pointer to data copied from / to user-space.
linux/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c:983: * @data:           Pointer to data copied from / to user-space.
linux/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c:1325: * @data: Pointer to data copied from / to user-space.
linux/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c:1352: * @data: Pointer to data copied from / to user-space.
linux/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c:1381: * @data: Pointer to data copied from / to user-space.
linux/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c:1400: * @data: Pointer to data copied from / to user-space.
linux/drivers/gpu/drm/vmwgfx/vmwgfx_bo.c:820:				 "%s: Incompatible transition from "
linux/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c:334:		 * the NO_EVICT flag so this is safe from -ENOMEM.
linux/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c:185:	from = !!(ram_rd32(fuc, 0x1373f0) & 0x00000002); /*XXX: ok? */
linux/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c:213:	if (mode == 1 && from == 0) {
linux/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c:246:	if (from == 0) {
linux/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c:263:	if (from == 0) {
linux/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c:286:	if (from == 0) {
linux/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c:165:	if (ram->from == 2) {
linux/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c:343:	if (ram->from == 2 && ram->mode != 2) {
linux/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c:354:	if (ram->from != 2 && ram->mode != 2) {
linux/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c:373:	if (ram->from != 2 && ram->mode == 2) {
linux/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c:384:	if (ram->from == 2 && ram->mode == 2) {
linux/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgk104.c:1053:	ram->from = ram_rd32(fuc, 0x1373f4) & 0x0000000f;
linux/drivers/gpu/drm/nouveau/nvkm/subdev/bios/shadow.c:236:	nvkm_debug(subdev, "using image from %s\n", best->func ?
linux/drivers/gpu/drm/nouveau/dispnv04/crtc.c:948:	 * nv11, from "nv" driver history)
linux/drivers/gpu/drm/nouveau/nouveau_display.c:513:		drm_dbg_kms(dev, "[CONNECTOR:%d:%s] status updated from %s to %s (epoch counter %llu->%llu)\n",
linux/drivers/gpu/drm/omapdrm/dss/base.c:108:	list = from ? &from->list : &omapdss_devices_list;
linux/drivers/gpu/drm/omapdrm/dss/sdi.c:181:			"pixel clock adjusted from %lu Hz to %lu Hz\n",
linux/drivers/gpu/drm/drm_connector.c:2030: * and can be used from &drm_connector_helper_funcs->atomic_check for validation.
linux/drivers/gpu/drm/scheduler/sched_main.c:757: * This adds all fences matching the given usage from @resv to @job.
linux/drivers/gpu/drm/exynos/exynos_drm_ipp.c:511:		DRM_DEBUG_DRIVER("Scale from %d to %d exceeds HW limits (ratio min %d.%05d, max %d.%05d)\n",
linux/drivers/gpu/drm/drm_atomic_helper.c:1230: * called from &drm_mode_config_helper_funcs.atomic_commit_tail can look at the
linux/drivers/gpu/drm/etnaviv/etnaviv_cmdbuf.h:18:	/* suballocator this cmdbuf is allocated from */
linux/drivers/gpu/drm/drm_sysfs.c:182:		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] force updated from %d to %d or reprobing\n",
linux/drivers/gpu/drm/i915/gt/intel_reset.c:1025:		drm_printf(&p, "called from %pS\n", (void *)_RET_IP_);
linux/drivers/gpu/drm/i915/gt/gen6_ppgtt.c:180:	u64 from = start;
linux/drivers/gpu/drm/i915/gt/uc/intel_guc_ads.c:754:		guc_warn(guc, "ADS capture alloc size changed from %d to %d\n",
linux/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.c:809:		gt_info(gt, "Consider updating your linux-firmware pkg or downloading from %s\n",
linux/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.c:840:	gt_info(gt, "%s firmware(s) can be downloaded from %s\n",
linux/drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:207: *  |   |  27:0 | **DATA0** - data (depends on ACTION from `HXG Request`_)     |
linux/drivers/gpu/drm/i915/gt/uc/abi/guc_messages_abi.h:211: *  |...|       | **DATAn** - data (depends on ACTION from `HXG Request`_)     |
linux/drivers/gpu/drm/i915/i915_perf.c:257: * derived from %OA_TAIL_MARGIN_NSEC and the configured sampling frequency.
linux/drivers/gpu/drm/i915/i915_driver.c:959:	/* Catch up with all the deferred frees from "this" client */
linux/drivers/gpu/drm/i915/i915_memcpy.c:102: * i915_memcpy_from_wc copies @len bytes from @src to @dst using
linux/drivers/gpu/drm/i915/gvt/mmio_context.c:566:	gvt_dbg_render("switch ring %s from %s to %s\n", engine->name,
linux/drivers/gpu/drm/i915/gvt/cmd_parser.c:500:	/* next instruction when return from  batch buffer to ring buffer */
linux/drivers/gpu/drm/i915/i915_reg_defs.h:32: * @return: Continuous bitmask from @__high to @__low, inclusive.
linux/drivers/gpu/drm/i915/i915_reg_defs.h:47: * @return: Continuous bitmask from @__high to @__low, inclusive.
linux/drivers/gpu/drm/i915/i915_scheduler.c:240:		struct i915_request *from = container_of(dep->signaler,
linux/drivers/gpu/drm/i915/intel_pcode.c:189:	 * requests. Increase the timeout from @timeout_base_ms to 50ms to
linux/drivers/gpu/drm/i915/i915_ttm_buddy_manager.c:296: * taken from &ttm_resource_manager.size.
linux/drivers/gpu/drm/i915/display/i9xx_wm.c:1061:/* mark all levels starting from 'level' as invalid */
linux/drivers/gpu/drm/i915/display/i9xx_wm.c:1525:/* mark all levels starting from 'level' as invalid */
linux/drivers/gpu/drm/i915/display/i9xx_wm.c:1551: * Starting from 'level' set all higher
linux/drivers/gpu/drm/i915/display/dvo_ns2501.c:425:		    ("Unable to read register 0x%02x from %s:0x%02x.\n", addr,
linux/drivers/gpu/drm/i915/display/dvo_ns2501.c:491:		DRM_DEBUG_KMS("ns2501 not detected got %d: from %s Slave %d.\n",
linux/drivers/gpu/drm/i915/display/dvo_ns2501.c:500:		DRM_DEBUG_KMS("ns2501 not detected got %d: from %s Slave %d.\n",
linux/drivers/gpu/drm/i915/display/vlv_dsi_pll_regs.h:25:/* TX control divider to select actual TX clock output from (8x/var) */
linux/drivers/gpu/drm/i915/display/intel_pps.c:1131:		    "detaching %s from [ENCODER:%d:%s]\n",
linux/drivers/gpu/drm/i915/display/intel_pps.c:1159:			    "stealing PPS %c from [ENCODER:%d:%s]\n",
linux/drivers/gpu/drm/i915/display/intel_fb.c:359:	return md->display_ver.from <= display_ver_until &&
linux/drivers/gpu/drm/i915/display/intel_connector.c:197: * Fetch the EDID information from @connector using the DDC bus.
linux/drivers/gpu/drm/i915/display/dvo_ch7017.c:229:		DRM_DEBUG_KMS("ch701x not detected, got %d: from %s "
linux/drivers/gpu/drm/i915/display/intel_display_power_well.c:706:		    "Resetting DC state tracking from %02x to %02x\n",
linux/drivers/gpu/drm/i915/display/intel_display_power_well.c:749:	drm_dbg_kms(&dev_priv->drm, "Setting DC state from %02x to %02x\n",
linux/drivers/gpu/drm/i915/display/intel_dp.c:703:		drm_dbg_kms(&i915->drm, "Set dsc bpp from %d to VESA %d\n",
linux/drivers/gpu/drm/i915/display/dvo_sil164.c:104:		DRM_DEBUG_KMS("Unable to read register 0x%02x from %s:%02x.\n",
linux/drivers/gpu/drm/i915/display/dvo_sil164.c:156:		DRM_DEBUG_KMS("sil164 not detected got %d: from %s Slave %d.\n",
linux/drivers/gpu/drm/i915/display/dvo_sil164.c:165:		DRM_DEBUG_KMS("sil164 not detected got %d: from %s Slave %d.\n",
linux/drivers/gpu/drm/i915/display/dvo_ivch.c:227:		DRM_DEBUG_KMS("Unable to read register 0x%02x from "
linux/drivers/gpu/drm/i915/display/intel_frontbuffer.c:299: * from @old and setting them in @new. Both @old and @new can be NULL.
linux/drivers/gpu/drm/i915/display/dvo_tfp410.c:125:		DRM_DEBUG_KMS("Unable to read register 0x%02x from %s:%02x.\n",
linux/drivers/gpu/drm/i915/display/dvo_tfp410.c:185:		DRM_DEBUG_KMS("tfp410 not detected got VID %X: from %s "
linux/drivers/gpu/drm/i915/display/dvo_tfp410.c:192:		DRM_DEBUG_KMS("tfp410 not detected got DID %X: from %s "
linux/drivers/gpu/drm/i915/display/intel_dpll.c:437: * divider from @match_clock used for LVDS downclocking.
linux/drivers/gpu/drm/i915/display/intel_dpll.c:495: * divider from @match_clock used for LVDS downclocking.
linux/drivers/gpu/drm/i915/display/intel_dpll.c:551: * divider from @match_clock used for LVDS downclocking.
linux/drivers/gpu/drm/i915/display/intel_fbdev.c:415:				    "found possible fb from [PLANE:%d:%s]\n",
linux/drivers/gpu/drm/i915/display/intel_hotplug.c:280:		drm_dbg_kms(dev, "[CONNECTOR:%d:%s] status updated from %s to %s (epoch counter %llu->%llu)\n",
linux/drivers/gpu/drm/i915/display/skl_watermark_regs.h:128: * The below are numbered starting from "S1" on gen11/gen12, but starting
linux/drivers/gpu/drm/i915/display/dvo_ch7xxx.c:178:		DRM_DEBUG_KMS("Unable to read register 0x%02x from %s:%02x.\n",
linux/drivers/gpu/drm/i915/display/dvo_ch7xxx.c:232:		DRM_DEBUG_KMS("ch7xxx not detected; got VID 0x%02x from %s slave %d.\n",
linux/drivers/gpu/drm/i915/display/dvo_ch7xxx.c:243:		DRM_DEBUG_KMS("ch7xxx not detected; got DID 0x%02x from %s slave %d.\n",
linux/drivers/gpu/drm/i915/display/intel_opregion.c:822:	DRM_DEBUG_KMS("Falling back to manually reading VBT from "
linux/drivers/gpu/drm/i915/gem/i915_gem_object.c:480: * Reads data from @obj at the specified offset. The requested region to read
linux/drivers/gpu/drm/ingenic/ingenic-ipu.c:121: *  @f_x: Absolute distance in pixels from 'pixel 0' sample position
linux/drivers/gpu/drm/lima/lima_sched.c:293:		dev_info(dev->dev, "fail to save task state from %s pid %d: "
linux/drivers/gpu/drm/ttm/ttm_resource.c:588: * @start: Offset that needs to be subtracted from @st to make
linux/drivers/gpu/drm/ttm/ttm_bo_util.c:610:	from = ttm_manager_type(bdev, bo->resource->mem_type);
linux/drivers/gpu/drm/ttm/ttm_bo_util.c:649:	struct ttm_resource_manager *from = ttm_manager_type(bdev, bo->resource->mem_type);
linux/drivers/gpu/drm/gma500/psb_intel_modes.c:50: * Fetch the EDID information from @connector using the DDC bus.
linux/drivers/gpu/drm/gma500/gtt.c:194:	/* The root resource we allocate address space from */
linux/drivers/gpu/drm/bridge/ite-it6505.c:2366:		 * when sink count change from  0->1
linux/drivers/gpu/drm/bridge/panel.c:243: * just calls the appropriate functions from &drm_panel.
linux/drivers/gpu/drm/bridge/panel.c:370: * that just calls the appropriate functions from &drm_panel.
linux/drivers/gpu/drm/bridge/panel.c:438: *                         appropriate functions from &drm_panel.
linux/drivers/gpu/drm/display/drm_dp_mst_topology.c:1793: * Releases a topology reference from @mstb by decrementing
linux/drivers/gpu/drm/display/drm_dp_mst_topology.c:1905: * Releases a topology reference from @port by decrementing
linux/drivers/gpu/drm/drm_vblank.c:678: * (taken from &drm_crtc_state.adjusted mode for atomic modeset drivers) to
linux/drivers/gpu/drm/drm_vblank.c:823: * (taken from &drm_crtc_state.adjusted mode for atomic modeset drivers) to
linux/drivers/hid/usbhid/hid-pidff.c:211:	pr_debug("calculated from %d to %d\n", value, usage->value[0]);
linux/drivers/hid/usbhid/hid-pidff.c:226:	pr_debug("calculated from %d to %d\n", value, usage->value[0]);
linux/drivers/hid/hid-lg4ff.c:1234:	/* Switch from "Driving Force" mode to native mode automatically.
linux/drivers/hid/hid-logitech-hidpp.c:508: * device. It also uses the multiplier from &struct hid_scroll_counter to
linux/drivers/hid/hid-apple.c:373:		if (trans->from == from)
linux/drivers/hid/hid-roccat-kone.c:156: * Writes settings from @buf to mouse
linux/drivers/hid/hid-icade.c:159:	if (from > ICADE_MAX_USAGE)
linux/drivers/hid/hid-multitouch.c:1098:			 * Azimuth is counter-clockwise and ranges from [0, MAX)
linux/drivers/hid/hid-tmff.c:60:/* Changes values from -0x80 to 0x7f into values from minimum to maximum */
linux/drivers/i2c/muxes/i2c-mux-reg.c:138:	/* map address from "reg" if exists */
linux/drivers/i2c/busses/i2c-imx.c:582:			"SoC errata ERR007805 or e7805 applies, bus frequency limited from %d Hz to 384000 Hz.\n",
linux/drivers/i2c/busses/i2c-mlxbf.c:1964: * Receive bytes from 'external' smbus master. This function is executed when
linux/drivers/i2c/algos/i2c-algo-pca.c:215:				printk(KERN_INFO "    [%02d] RD %d bytes from %#02x [%#02x, ...]\n",
linux/drivers/i3c/device.c:154: * process IBIs coming from @dev. When this function returns, the IBI is not
linux/drivers/i3c/master/mipi-i3c-hci/pio.c:397:	u32 *from = xfer->data;
linux/drivers/i3c/master/mipi-i3c-hci/pio.c:408:	from += words_to_keep;
linux/drivers/i3c/master/mipi-i3c-hci/pio.c:444:		from += chunk;
linux/drivers/i3c/master/mipi-i3c-hci/pio.c:826:		dev_err(&hci->master.dev, "IBI error from %#x\n", ibi->addr);
linux/drivers/i3c/master/mipi-i3c-hci/pio.c:923:				"unexp IBI address changed from %d to %d\n",
linux/drivers/i3c/master/mipi-i3c-hci/dma.c:650:		dev_err(&hci->master.dev, "IBI error from %#x\n", ibi_addr);
linux/drivers/s390/crypto/ap_queue.c:496:		/* reset from 'outside' happened or no idea at all */
linux/drivers/s390/crypto/vfio_ap_private.h:44: *		 removed from @mdev_list or the list is iterated.
linux/drivers/s390/crypto/vfio_ap_ops.c:892: * assign_adapter_store - parses the APID from @buf and sets the
linux/drivers/s390/crypto/vfio_ap_ops.c:1043: * unassign_adapter_store - parses the APID from @buf and clears the
linux/drivers/s390/crypto/vfio_ap_ops.c:1101: * assign_domain_store - parses the APQI from @buf and sets the
linux/drivers/s390/crypto/vfio_ap_ops.c:1230: * unassign_domain_store - parses the APQI from @buf and clears the
linux/drivers/s390/crypto/vfio_ap_ops.c:1279: * assign_control_domain_store - parses the domain ID from @buf and sets
linux/drivers/s390/crypto/vfio_ap_ops.c:1333: * unassign_control_domain_store - parses the domain ID from @buf and
linux/drivers/s390/virtio/virtio_ccw.c:1500:			    ((from_ssid == to_ssid) && (from > to)))
linux/drivers/s390/virtio/virtio_ccw.c:1510:		       ((from_ssid == to_ssid) && (from <= to))) {
linux/drivers/s390/virtio/virtio_ccw.c:1513:			if (from > __MAX_SUBCHANNEL) {
linux/drivers/s390/virtio/virtio_ccw.c:1515:				from = 0;
linux/drivers/s390/scsi/zfcp_fsf.c:1631:			 "FC Endpoint Security of connection to remote port 0x%16llx changed: from %s to %s\n",
linux/drivers/s390/scsi/zfcp_def.h:274: * @lun_handle: handle from "open lun" for issuing FSF requests
linux/drivers/s390/block/dasd_eckd.c:3714:	if (from == to)
linux/drivers/s390/block/dasd_eckd.c:3718:	if (from % trks_per_ext != 0) {
linux/drivers/s390/block/dasd_eckd.c:3719:		tmp = from + trks_per_ext - (from % trks_per_ext) - 1;
linux/drivers/s390/block/dasd_eckd.c:3722:		cur_pos = tmp - from + 1;
linux/drivers/s390/block/dasd_eckd.c:3726:	if (to - (from + cur_pos) + 1 >= trks_per_ext) {
linux/drivers/s390/block/dasd_eckd.c:3728:		count += (tmp - (from + cur_pos) + 1) / trks_per_ext;
linux/drivers/s390/block/dasd_eckd.c:5538:	while (from <= to) {
linux/drivers/s390/block/dasd_eckd.c:5664:		from = ++to;
linux/drivers/s390/block/dasd_eckd.c:5666:		if (from <  fail - 2) {
linux/drivers/s390/block/dasd_eckd.c:5667:			from = fail - 2;     /* there is a gap - print header */
linux/drivers/s390/block/dasd_eckd.c:5675:		from = max(from, ++to);
linux/drivers/s390/block/dasd_eckd.c:5676:		if (from < last - 1) {
linux/drivers/s390/block/dasd_eckd.c:5677:			from = last - 1;     /* there is a gap - print header */
linux/drivers/s390/block/dasd_devmap.c:345:		if (from_id0 != to_id0 || from_id1 != to_id1 || from > to) {
linux/drivers/s390/block/dasd_devmap.c:359:	while (from <= to) {
linux/drivers/s390/cio/io_sch.h:70: * @singlepath: if set, use only one path from @lpm per start I/O
linux/drivers/s390/cio/blacklist.c:53:	if ((from_ssid > to_ssid) || ((from_ssid == to_ssid) && (from > to))) {
linux/drivers/s390/cio/blacklist.c:62:	       (from <= to))) {
linux/drivers/s390/cio/blacklist.c:68:		if (from > __MAX_SUBCHANNEL) {
linux/drivers/s390/cio/blacklist.c:70:			from = 0;
linux/drivers/s390/cio/blacklist.c:172:			from = 0;
linux/drivers/s390/cio/blacklist.c:180:				from = ipl_info.data.ccw.dev_id.devno;
linux/drivers/s390/cio/blacklist.c:185:				from = ipl_info.data.fcp.dev_id.devno;
linux/drivers/s390/cio/blacklist.c:198:			from = to = console_devno;
linux/drivers/s390/cio/airq.c:298:	/* Find non-zero bit starting from 'ivs->next'. */
linux/drivers/s390/cio/vfio_ccw_cp.c:27:	/* Number of pages pinned from @pa_iova. */
linux/drivers/s390/cio/vfio_ccw_cp.c:45: * @len: number of pages that should be pinned from @iova
linux/drivers/s390/cio/vfio_ccw_cp.c:695: * the target channel program from @orb->cmd.iova to the new ccwchain(s).
linux/drivers/s390/cio/vfio_ccw_cp.c:936: * @length: the length to check from @iova
linux/drivers/s390/cio/idset.c:77:/* Clear ids starting from @schid up to end of subchannel set. */
linux/drivers/s390/char/sclp_vt220.c:324:		     (from < count) && (to < sclp_vt220_space_left(request));
linux/drivers/s390/char/Kconfig:148:	  by the z/VM recording system services, eg. from *LOGREC, *ACCOUNT or
linux/drivers/s390/char/diag_ftp.c:73: * @param32: 32-bit interruption parameter from &struct diag_ftp_ldfpl
linux/drivers/s390/net/smsgiucv.c:48:	/* Path pending from *MSG. */
linux/drivers/remoteproc/omap_remoteproc.c:511:		dev_info(dev, "received echo reply from %s\n", name);
linux/drivers/remoteproc/qcom_common.c:474: * @ssr_name:	identifier to use for notifications originating from @rproc
linux/drivers/remoteproc/ti_k3_r5_remoteproc.c:203:		dev_info(dev, "received echo reply from %s\n", name);
linux/drivers/remoteproc/xlnx_r5_remoteproc.c:357:	dev_dbg(r5_core->dev, "RPU boot addr 0x%llx from %s.", rproc->bootaddr,
linux/drivers/remoteproc/imx_rproc.c:678:			dev_err(dev, "failed to remap %#x bytes from %#x\n", att->size, att->sa);
linux/drivers/remoteproc/ti_k3_dsp_remoteproc.c:129:		dev_info(dev, "received echo reply from %s\n", name);
linux/drivers/fpga/of-fpga-region.c:42: * Get FPGA Manager from "fpga-mgr" property or from ancestor region.
linux/drivers/fpga/dfl-afu-dma-region.c:237: * - if @size == 0, it finds the dma region which starts from @iova
linux/drivers/pci/search.c:172:	n = from ? from->node.next : pci_root_buses.next;
linux/drivers/pci/pci.c:1227:		pci_err(dev, "Unable to change power state from %s to D0, device inaccessible\n",
linux/drivers/pci/pci.c:1285:		pci_info_ratelimited(dev, "Refused to change power state from %s to D0\n",
linux/drivers/pci/pci.c:1359:		pci_dbg(dev, "Invalid power transition (from %s to %s)\n",
linux/drivers/pci/pci.c:1372:		pci_err(dev, "Unable to change power state from %s to %s, device inaccessible\n",
linux/drivers/pci/pci.c:1394:		pci_info_ratelimited(dev, "Refused to change power state from %s to %s\n",
linux/drivers/pci/pci.c:6430:		pci_info(dev, "Enabling fixed DMA alias for devfn range from %02x.%d to %02x.%d\n",
linux/drivers/pci/quirks.c:1155:		pci_info(dev, "VIA VLink IRQ fixup, from %d to %d\n",
linux/drivers/pci/quirks.c:5972:		pci_info(dev, "ASPM: overriding L1 acceptable latency from %#x to 0x7\n",
linux/drivers/pci/pci-acpi.c:99:		dev_err(dev, "can't get resource from %s\n",
linux/drivers/pci/pci-acpi.c:892: * (Power Resources for Wake) supporting system wakeup from "x"
linux/drivers/pci/vgaarb.c:924:	/* XXX if somebody is going from "doesn't decode" to "decodes" state
linux/drivers/pci/endpoint/pci-epc-core.c:101: * pci_epc_get_next_free_bar() - helper to get unreserved BAR starting from @bar
linux/drivers/pci/endpoint/pci-epc-core.c:105: * Invoke to get the next unreserved BAR starting from @bar that can be used
linux/drivers/pci/endpoint/functions/pci-epf-ntb.c:987: * is obtained from "spad-count" configfs entry.
linux/drivers/pci/endpoint/functions/pci-epf-vntb.c:405: * is obtained from "spad-count" configfs entry.
linux/drivers/pci/of.c:280: *                from 'dma-ranges') will be added after DT parsing
linux/drivers/pci/controller/pci-ixp4xx.c:226:	dev_dbg(p->dev, "%s from %d size %d cmd %08x\n",
linux/drivers/pci/controller/pci-ixp4xx.c:310:	dev_dbg(p->dev, "read_config from %d size %d dev %d:%d:%d address: %08x cmd: %08x\n",
linux/drivers/pci/ecam.c:59:		dev_warn(dev, "ECAM area %pR can only accommodate %pR (reduced from %pR desired)\n",
linux/drivers/pci/setup-bus.c:1880:	 * Calculate the amount of space we can forward from "bus" to any
linux/drivers/message/fusion/mptscsih.c:1532:		printk(MYIOC_s_WARN_FMT "Issuing HardReset from %s!!\n",
linux/drivers/message/fusion/mptscsih.c:1643:		       "Issuing Reset from %s!! doorbell=0x%08x\n",
linux/drivers/message/fusion/mptscsih.c:2978:			       "Issuing Reset from %s!! doorbell=0x%08xh"
linux/drivers/message/fusion/mptsas.c:4946:		       "Issuing Reset from %s!! doorbell=0x%08x\n",
linux/drivers/message/fusion/mptsas.c:5272:		  "Resetting sg_tablesize to %d from %d\n",
linux/drivers/message/fusion/mptsas.c:5287:			"Resetting max sector to %d from %d\n",
linux/drivers/message/fusion/mptfc.c:1280:		  "Resetting sg_tablesize to %d from %d\n",
linux/drivers/message/fusion/mptbase.c:405:		printk(MYIOC_s_WARN_FMT "Issuing HardReset from %s!!\n",
linux/drivers/message/fusion/mptbase.c:3030:		printk(MYIOC_s_INFO_FMT "Recovered from %s\n", ioc->name,
linux/drivers/message/fusion/mptbase.c:5116:			       "Issuing Reset from %s!!, doorbell=0x%08x\n",
linux/drivers/message/fusion/mptbase.c:6529:		       "Issuing Reset from %s!!, doorbell=0x%08x\n",
linux/drivers/message/fusion/mptbase.c:6639: *	Handles read request from /proc/mpt/summary or /proc/mpt/iocN/summary.
linux/drivers/message/fusion/mptspi.c:667:			printk(MYIOC_s_WARN_FMT "Issuing Reset from %s!!\n",
linux/drivers/message/fusion/mptspi.c:1483:		  "Resetting sg_tablesize to %d from %d\n",
linux/drivers/iio/temperature/ltc2983.c:1384:			dev_err(dev, "chan:%d must be from %u to %u\n", sensor.chan,
linux/drivers/iio/cdc/ad7150.c:67: *	from 'average' value.
linux/drivers/iio/light/isl29018.c:313: * proximity count is from -2^(n-1) to 2^(n-1) . The sign bit is extended
linux/drivers/iio/light/si1133.c:882: * The channel configuration for the lux measurement was taken from :
linux/drivers/iio/buffer/industrialio-buffer-dma.c:231: * @list: List of aborted blocks. All blocks in this list must be from @queue.
linux/drivers/iio/adc/dln2-adc.c:90:	if (p && p->from + p->length == in_loc &&
linux/drivers/iio/adc/dln2-adc.c:95:		p->from = in_loc;
linux/drivers/iio/adc/max9611.c:202: * to return values from "reg_addr" and "reg_addr + 1" consecutively.
linux/drivers/iio/adc/twl4030-madc.c:254:/* Conversion table from -3 to 55 degrees Celcius */
linux/drivers/iio/adc/qcom-spmi-adc5.c:651:	/* Value read from "reg" is virtual channel number */
linux/drivers/iio/adc/ltc2471.c:62:			/* Output ranges from -VREF to +VREF */
linux/drivers/iio/adc/ad7280a.c:292:	/* Set register address on the part to be read from */
linux/drivers/iio/adc/stm32-dfsdm-adc.c:1197:				"Sampling rate changed from (%u) to (%u)\n",
linux/drivers/iio/pressure/st_pressure_core.c:40: * Therefore, from (1), "gain" becomes :
linux/drivers/iio/pressure/st_pressure_core.c:76: * Therefore, from (3), "gain2" becomes :
linux/drivers/iio/pressure/st_pressure_core.c:83: * giving from (4):
linux/drivers/iio/industrialio-buffer.c:961:	if (*p && (*p)->from + (*p)->length == in_loc &&
linux/drivers/iio/industrialio-buffer.c:968:		(*p)->from = in_loc;
linux/drivers/iio/dac/ltc2688.c:214:	/* select the correct input register to read from */
linux/drivers/iio/dac/ad3552r.c:154:	/* Range from -5 V to 5 V. Requires Rfb2x connection  */
linux/drivers/iio/dac/ad3552r.c:156:	/* Range from -10 V to 10 V. Requires Rfb4x connection  */
linux/drivers/iio/dac/ad3552r.c:177:	/* Range from -2.5 V to 7.5 V. Requires Rfb2x connection  */
linux/drivers/iio/dac/ad3552r.c:179:	/* Range from -5 V to 5 V. Requires Rfb2x connection  */
linux/drivers/power/supply/max14656_charger_detector.c:96:			"i2c read fail: can't read from %02x: %d\n",
linux/drivers/power/supply/ab8500_fg.c:1306:			dev_dbg(di->dev, "level changed from %d to %d\n",
linux/drivers/power/supply/ab8500_fg.c:1378:				"capacity changed from %d to %d (%d)\n",
linux/drivers/power/supply/ab8500_fg.c:1417:	dev_dbg(di->dev, "Charge state from %d [%s] to %d [%s]\n",
linux/drivers/power/supply/ab8500_fg.c:1429:	dev_dbg(di->dev, "Discharge state from %d [%s] to %d [%s]\n",
linux/drivers/power/supply/ab8500_charger.c:1922:				dev_dbg(di->dev, "get VBAT from %s\n",
linux/drivers/power/supply/charger-manager.c:241:			dev_warn(cm->dev, "Cannot read ONLINE value from %s\n",
linux/drivers/power/supply/charger-manager.c:259:			dev_warn(cm->dev, "Cannot read STATUS value from %s\n",
linux/drivers/thermal/uniphier_thermal.c:22: * addresses are the offset from .block_base
linux/drivers/thermal/uniphier_thermal.c:38: * addresses are the offset from .map_base
linux/drivers/thermal/ti-soc-thermal/ti-bandgap.c:242:			"%s: IRQ from %s sensor: hotevent %d coldevent %d\n",
linux/drivers/thermal/rcar_gen3_thermal.c:121:/* no idea where these constants come from */
linux/drivers/thermal/tegra/soctherm.c:1084: * Looks up the chip data from @data and locks the mutex associated with
linux/drivers/thermal/thermal_of.c:508:		pr_err("Failed to initialize monitoring delays from %pOFn\n", np);
linux/drivers/thermal/thermal_of.c:515:		pr_err("Failed to initialize parameter from %pOFn: %d\n", np, ret);
linux/drivers/base/arch_numa.c:315:	if (from >= numa_distance_cnt || to >= numa_distance_cnt ||
linux/drivers/base/arch_numa.c:316:			from < 0 || to < 0) {
linux/drivers/base/arch_numa.c:323:	    (from == to && distance != LOCAL_DISTANCE)) {
linux/drivers/base/arch_numa.c:329:	numa_distance[from * numa_distance_cnt + to] = distance;
linux/drivers/base/arch_numa.c:337:	if (from >= numa_distance_cnt || to >= numa_distance_cnt)
linux/drivers/base/arch_numa.c:338:		return from == to ? LOCAL_DISTANCE : REMOTE_DISTANCE;
linux/drivers/base/arch_numa.c:339:	return numa_distance[from * numa_distance_cnt + to];
linux/drivers/base/firmware_loader/builtin/Makefile:4:# Create $(fwdir) from $(CONFIG_EXTRA_FIRMWARE_DIR) -- if it doesn't have a
linux/drivers/base/firmware_loader/main.c:564:		dev_dbg(device, "Loading firmware from %s\n", path);
linux/drivers/base/regmap/regcache.c:438:	dev_dbg(map->dev, "Syncing %s cache from %d-%d\n", name, min, max);
linux/drivers/base/regmap/regmap-debugfs.c:165:		if (from >= c->min && from <= c->max) {
linux/drivers/base/regmap/regmap-debugfs.c:166:			fpos_offset = from - c->min;
linux/drivers/base/regmap/trace.h:268:		__entry->from = from;
linux/drivers/base/component.c:509: * &component_master_ops.bind from @ops. Must be unregistered by calling
linux/drivers/base/component.c:555: * disassembled by calling &component_master_ops.unbind from @ops.
linux/drivers/base/devcoredump.c:288: * @offset: start copy from @offset@ bytes from the head of the data
linux/drivers/base/power/domain.c:667: * have been powered down, remove power from @genpd.
linux/drivers/base/power/domain.c:2290:	pr_debug("Added domain provider from %pOF\n", np);
linux/drivers/base/power/main.c:319:	 * The status of a device link can only be changed from "dormant" by a
linux/drivers/base/power/main.c:1863:	 * A positive return value from ->prepare() means "this device appears
linux/drivers/base/platform-msi.c:319: * @nr_irqs:	How many interrupts to free from @virq
linux/drivers/base/platform-msi.c:339: * @nr_irqs:	How many interrupts to allocate from @virq
linux/drivers/base/core.c:193: * __fwnode_links_move_consumers - Move consumer from @from to @to fwnode_handle
linux/drivers/base/core.c:197: * Move all consumer links from @from fwnode to @to fwnode.
linux/drivers/base/property.c:243: * Return: index, starting from %0, if the property was found (success),
linux/drivers/base/property.c:282: * Read an array of u8 properties with @propname from @fwnode and stores them to
linux/drivers/base/property.c:311: * Read an array of u16 properties with @propname from @fwnode and store them to
linux/drivers/base/property.c:340: * Read an array of u32 properties with @propname from @fwnode store them to
linux/drivers/base/property.c:369: * Read an array of u64 properties with @propname from @fwnode and store them to
linux/drivers/base/property.c:464: * Return: index, starting from %0, if the property was found (success),
linux/drivers/atm/lanai.c:1071:	printk(KERN_INFO DEV_LABEL "(itf %d): %s changed from %s\n",
linux/drivers/atm/he.c:2803:	/* Next, we need to send the byte address to read from */
linux/drivers/atm/nicstarmac.c:172:	/* Next, we need to send the byte address to read from */
linux/drivers/fsi/fsi-master-hub.c:32: * [This differs from "cascaded" masters, which expose the entire downstream
linux/drivers/ata/libahci.c:2705:	 * allocated. That is one MSI per port, starting from @irq.
linux/drivers/ata/libata-acpi.c:475: * Determine xfermask for @dev from @gtm.
linux/drivers/ata/pata_of_platform.c:37:		dev_err(&ofdev->dev, "can't get IO address from "
linux/drivers/ata/pata_of_platform.c:44:		dev_err(&ofdev->dev, "can't get CTL address from "
linux/drivers/ata/libata-core.c:294: *	this is different from @dev->link only when @dev is on slave
linux/drivers/ata/libata-core.c:511: *	Determine ATAPI command type from @opcode.
linux/drivers/ata/libata-core.c:627: *	Read block address from @tf.  This function can handle all
linux/drivers/ata/libata-core.c:632: *	Block address read from @tf.
linux/drivers/ata/libata-core.c:5496: *	Allocate ATA host and initialize with info from @ppi.  If NULL
linux/drivers/clk/sunxi/clk-sunxi.c:668:		pr_err("%s: could not read clock-output-names from \"%pOF\"\n",
linux/drivers/clk/sunxi/clk-sunxi.c:792:		pr_err("%s: could not read clock-output-names from \"%pOF\"\n",
linux/drivers/clk/microchip/clk-core.c:332:	 * ie. fout = (fin * 256) / [(512 * rodiv) + rotrim]  ... from (1)
linux/drivers/clk/clk.c:4812:	pr_debug("Added clock from %pOF\n", np);
linux/drivers/clk/clk.c:4854:	pr_debug("Added clk_hw provider from %pOF\n", np);
linux/drivers/clk/clk-fractional-divider.c:20: * for some cases the output may be saturated. Hence, from (1) and (2),
linux/drivers/clk/bcm/clk-bcm2835.c:1012:	 * from ..999.. to ..000.., round up.
linux/drivers/clk/mediatek/clk-mt8183.c:30: * valid, but renamed from "clk13m" (defined as fixed clock in the new
linux/drivers/clk/tegra/clk-tegra-periph.c:983:		 * re-parenting CPU off from "pll_p_out4" the PLLP branching to
linux/drivers/clk/versatile/clk-icst.c:4: * We wrap the custom interface from <asm/hardware/icst.h> into the generic
linux/drivers/clk/sifive/sifive-prci.c:22: * @offs: register offset to read from (in bytes, from PRCI base address)
linux/drivers/clk/nxp/clk-lpc32xx.c:1393:	pr_debug("%s: derived from '%s', clock type %d\n", lpc32xx_clk->name,
linux/drivers/staging/rtl8712/rtl8712_recv.h:52:	 * Range from -64~+63.5.
linux/drivers/staging/rtl8712/rtl871x_security.c:915:/* Builds the first MIC header block from       */
linux/drivers/staging/rtl8712/rtl871x_security.c:941:/* Builds the last MIC header block from        */
linux/drivers/staging/rtl8712/rtl871x_security.c:976:/* Builds the last MIC header block from        */
linux/drivers/staging/rtl8712/usb_intf.c:399:		dev_info(&udev->dev, "r8712u: Boot from %s: Autoload %s\n",
linux/drivers/staging/rtl8712/hal_init.c:72:	dev_info(dev, "r8712u: Loading firmware from \"%s\"\n", firmware_file);
linux/drivers/staging/media/deprecated/atmel/atmel-isc.h:106:			This differs from 'bpp' in the sense that in planar
linux/drivers/staging/media/atomisp/pci/sh_css_internal.h:562:	 * from "stdint.h" are allowed
linux/drivers/staging/media/atomisp/pci/sh_css_internal.h:578:	 * from "stdint.h" are allowed
linux/drivers/staging/media/atomisp/pci/runtime/bufq/interface/ia_css_bufq.h:120: * @brief   Dequeue an item from  SP to host communication event queue.
linux/drivers/staging/media/atomisp/pci/runtime/bufq/interface/ia_css_bufq.h:142:* @brief   Dequeue an item from  SP to host communication EOF event queue.
linux/drivers/staging/media/atomisp/pci/runtime/binary/interface/ia_css_binary.h:53:/* Indicate where binaries can read input from */
linux/drivers/staging/media/atomisp/pci/irq_types_hrt.h:24: * The definitions are taken from <system>_defs.h
linux/drivers/staging/media/atomisp/pci/sh_css_params.c:681:/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/sh_css_params.c:2000:	/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/sh_css_params.c:2064:	/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/sh_css_params.c:2422:		/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/sh_css_params.c:2489:		/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/sh_css_params.c:3019:			IA_CSS_LOG("dequeued param set %x from %d, release ref", cpy, 0);
linux/drivers/staging/media/atomisp/pci/sh_css_params.c:3249:	/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/sh_css_params.c:3368:				/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/sh_css_params.c:3681:		/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/atomisp_gmin_platform.c:646:		dev_err(dev, "Failed to get clk from %s: %d\n", gmin_pmc_clk_name, ret);
linux/drivers/staging/media/atomisp/pci/sh_css_params.h:108:	/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/sh_css_params.h:132:	/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/base/circbuf/interface/ia_css_circbuf.h:81: * @param offset The offset from "start" to the target position.
linux/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/vmem.c:203:	assert((unsigned long)from % ISP_VEC_ALIGN == 0);
linux/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/vmem.c:242:	assert((unsigned long)from % ISP_VEC_ALIGN == 0);
linux/drivers/staging/media/atomisp/pci/hive_isp_css_common/host/vmem.c:253:		from = (const t_vmem_elem *)((const char *)from + stride_from / ISP_NWAY *
linux/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc.host.c:47:/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc.host.h:35:/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc_types.h:42: *------------ deprecated(bz675) : from ---------------------------
linux/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc_types.h:69:	/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/atomisp/pci/isp/kernels/sc/sc_1.0/ia_css_sc_types.h:91:/* ------ deprecated(bz675) : from ------ */
linux/drivers/staging/media/imx/imx-media-dev-common.c:208:			"adding controls to %s from %s\n",
linux/drivers/staging/media/imx/imx-media-csi.c:100:	/* media bus config of the upstream subdevice CSI is receiving from */
linux/drivers/staging/media/ipu3/ipu3-css-params.c:2698: * `old_binary_params', or if the flag is true, copy from `user_setting'
linux/drivers/staging/media/ipu3/include/uapi/intel-ipu3.h:9:/* from /drivers/staging/media/ipu3/include/videodev2.h */
linux/drivers/staging/media/ipu3/ipu3-css-pool.c:14:		dev_warn(&imgu->pci_dev->dev, "dma buf resized from %zu to %zu",
linux/drivers/staging/wlan-ng/prism2fw.c:153:/* PDA, built from [card|newfile]+[addfile1+addfile2...] */
linux/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.c:1652:			       "Rcvd Msg %s(%u) from %c%c%c%c s:%d d:%d len:%d",
linux/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.c:2064:					"Rcvd Msg %s from %c%c%c%c s:%d d:%d len:%d",
linux/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.c:2573:			 * This buffer is still being read from - stop
linux/drivers/staging/vc04_services/bcm2835-camera/controls.c:31:/* The supported V4L2_CID_AUTO_EXPOSURE_BIAS values are from -4.0 to +4.0.
linux/drivers/staging/rtl8192e/rtllib_crypt_ccmp.c:238:			pr_debug("CCMP: received packet without ExtIV flag from %pM\n",
linux/drivers/staging/rtl8192e/rtllib_crypt_ccmp.c:252:			pr_debug("CCMP: received packet from %pM with keyid=%d that does not have a configured key\n",
linux/drivers/staging/rtl8192e/rtllib_crypt_tkip.c:350:				   "Received packet without ExtIV flag from %pM\n",
linux/drivers/staging/rtl8192e/rtllib_crypt_tkip.c:365:				   "Received packet from %pM with keyid=%d that does not have a configured key\n",
linux/drivers/staging/rtl8192e/rtllib_crypt_tkip.c:573:			   "Michael MIC verification failed for MSDU from %pM keyidx=%d\n",
linux/drivers/staging/rtl8192e/rtllib_rx.c:1197:			   "dropped unencrypted RX data frame from %pM (drop_unencrypted=1)\n",
linux/drivers/staging/emxx_udc/TODO:3:* convert VBUS GPIO to use GPIO descriptors from <linux/gpio/consumer.h>
linux/drivers/staging/rtl8192u/r8192U.h:738:	 * Range from -64~+63.5.
linux/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c:120: *           IE mainly from (Beacon/ProbeRsp/AssocReq)
linux/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c:155: *           IE mainly from (Beacon/ProbeRsp)
linux/drivers/staging/rtl8192u/ieee80211/rtl819x_HTProc.c:959:	// Lanhsin: mark for tmp to avoid deauth by ap from  s3
linux/drivers/staging/rtl8192u/ieee80211/rtl819x_BAProc.c:345:	netdev_info(ieee->dev, "====================>rx ADDBAREQ from :%pM\n", dst);
linux/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c:352:			       "received packet from %pM\n",
linux/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c:1234:			"frame from %pM"
linux/drivers/staging/rtl8192u/ieee80211/ieee80211_rx.c:2339:			IEEE80211_DEBUG_SCAN("Expired '%s' (%pM) from "
linux/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_ccmp.c:248:			netdev_dbg(skb->dev, "CCMP: received packet without ExtIV flag from %pM\n",
linux/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_ccmp.c:262:			netdev_dbg(skb->dev, "CCMP: received packet from %pM with keyid=%d that does not have a configured key\n",
linux/drivers/staging/rtl8192u/ieee80211/ieee80211_tx.c:53: * desc | ^-ver-^  |  ^type-^  |  ^-----subtype-----^  | to  |from |more |retry| pwr |more |wep   |
linux/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_tkip.c:360:			       " flag from %pM\n", hdr->addr2);
linux/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_tkip.c:372:			netdev_dbg(skb->dev, "TKIP: received packet from %pM"
linux/drivers/staging/rtl8192u/ieee80211/ieee80211_crypt_tkip.c:583:		       "MSDU from %pM keyidx=%d\n",
linux/drivers/staging/greybus/audio_module.c:60:				     "Modifying jack from %d to %d\n",
linux/drivers/staging/greybus/TODO:1:* Convert all uses of the old GPIO API from <linux/gpio.h> to the
linux/drivers/staging/sm750fb/ddk750_swi2c.c:394:	 * range is only from [0..63]
linux/drivers/staging/nvec/nvec.c:238:	dev_dbg(nvec->dev, "GPIO changed from %u to %u\n",
linux/drivers/staging/rtl8723bs/core/rtw_wlan_util.c:988:			/* modify from  fw by Thomas 2010/11/17 */
linux/drivers/staging/rtl8723bs/core/rtw_mlme.c:1148:/* if join_res > 0, update "cur_network->network" from "pnetwork->network" if (ptarget_wlan != NULL). */
linux/drivers/staging/rtl8723bs/core/rtw_security.c:732:/* Builds the first MIC header block from       */
linux/drivers/staging/rtl8723bs/core/rtw_security.c:767:/* Builds the last MIC header block from        */
linux/drivers/staging/rtl8723bs/core/rtw_security.c:811:/* Builds the last MIC header block from        */
linux/drivers/staging/rtl8723bs/hal/rtl8723b_cmd.c:386:				/*  Keep awake interval to 1 to prevent from */
linux/drivers/rtc/rtc-sun6i.c:487:		 * switch from (data_year->min)-relative offset to
linux/drivers/rtc/lib.c:93:	 * thus, is slightly different from [1].
linux/drivers/rtc/rtc-meson.c:63:	struct device		*dev;		/* device we bound from */
linux/drivers/rtc/rtc-sunxi.c:208:	 * switch from (data_year->min)-relative offset to
linux/drivers/rtc/rtc-sunxi.c:246:	 * switch from (data_year->min)-relative offset to
linux/drivers/char/tpm/tpm_vtpm_proxy.c:259: * Called when core TPM driver reads TPM responses from 'server side'
linux/drivers/char/applicom.c:465:		unsigned char *from = (unsigned char *) &tmpmailbox;
linux/drivers/char/applicom.c:487:	void __iomem *from = apbs[IndexCard].RamIO + RAM_TO_PC;
linux/drivers/char/virtio_console.c:98:	/* Device we got DMA memory from */
linux/drivers/char/mem.c:70:	u64 from = ((u64)pfn) << PAGE_SHIFT;
linux/drivers/char/mem.c:71:	u64 to = from + size;
linux/drivers/char/apm-emulation.c:254: *     - acknowledge a suspend read from /dev/apm_bios.
linux/drivers/char/apm-emulation.c:276:			 * If we read a suspend command from /dev/apm_bios,
linux/drivers/char/ps3flash.c:113:			"%s:%u Truncating count from %zu to %llu\n", __func__,
linux/drivers/char/ps3flash.c:182:			"%s:%u Truncating count from %zu to %llu\n", __func__,
linux/drivers/char/pc8736x_gpio.c:163:	dev_dbg(&pdev->dev, "_gpio_get(%d from %x bit %d) == val %d\n",
linux/drivers/char/random.c:168:		printk_deferred(KERN_NOTICE "random: %s called from %pS with crng_init=%d\n", \
linux/drivers/char/random.c:194: * a read from /dev/urandom. The u8, u16, u32, u64, long family of
linux/drivers/char/random.c:1343: * Reading from /dev/random has the same functionality as calling
linux/drivers/char/random.c:1348: * Reading from /dev/urandom has the same functionality as calling
linux/drivers/leds/flash/leds-rt8515.c:267:		 "current restricted from %u to %u mA, max intensity %d/100\n",
linux/drivers/leds/leds-lm3533.c:175: * Returns linear map of *t from [t_min,t_max] to [v_min,v_max] with a step
linux/drivers/net/phy/phy_device.c:2082: * genphy_setup_forced - configures/forces speed/duplex from @phydev
linux/drivers/net/phy/phy-core.c:545: * @devad: The MMD to read from (0..31)
linux/drivers/net/phy/motorcomm.c:1598: * yt8521_fiber_setup_forced - configures/forces speed from @phydev
linux/drivers/net/phy/motorcomm.c:1851:		/* configures/forces speed/duplex from @phydev */
linux/drivers/net/ipa/ipa_data.h:77: * from (and through) the IPA.  A GSI channel has a ring buffer made
linux/drivers/net/ipa/ipa_resource.c:21: * are separate from "destination" resource types.
linux/drivers/net/ipa/ipa.h:52: * @mem_offset:		Offset from @mem_virt used for access to IPA memory
linux/drivers/net/gtp.c:334:		netdev_dbg(gtp->dev, "no route for echo response from %pI4\n",
linux/drivers/net/gtp.c:516:		netdev_dbg(gtp->dev, "no route for echo response from %pI4\n",
linux/drivers/net/amt.c:232:			   "Delete source %pI4 from %pI4\n",
linux/drivers/net/amt.c:238:			   "Delete source %pI6 from %pI6\n",
linux/drivers/net/amt.c:351:		netdev_dbg(amt->dev, "Source %pI4 from %pI4 Acted %s\n",
linux/drivers/net/amt.c:357:		netdev_dbg(amt->dev, "Source %pI6 from %pI6 Acted %s\n",
linux/drivers/net/amt.c:1374:					   "Add source as OLD %pI4 from %pI4\n",
linux/drivers/net/amt.c:1380:					   "Add source as OLD %pI6 from %pI6\n",
linux/drivers/net/amt.c:1435:					   "Add source as NEW %pI4 from %pI4\n",
linux/drivers/net/amt.c:1441:					   "Add source as NEW %pI6 from %pI6\n",
linux/drivers/net/hamradio/Makefile:6:# 19971130 	Moved the amateur radio related network drivers from 
linux/drivers/net/hamradio/bpqether.c:12: *		- to cure the protocol stack from "feature-ism"
linux/drivers/net/hamradio/scc.c:63:		code (and Hans Alblas' memory buffer pool concept) from 
linux/drivers/net/hamradio/scc.c:697:		 * all over again to be sure not to miss an interrupt from 
linux/drivers/net/geneve.c:288:				net_info_ratelimited("non-ECT from %pI4 "
linux/drivers/net/geneve.c:294:				net_info_ratelimited("non-ECT from %pI6\n",
linux/drivers/net/arcnet/arcnet.c:654:		   "create header from %d to %d; protocol %d (%Xh); size %u.\n",
linux/drivers/net/arcnet/arcnet.c:1149:	arc_printk(D_DURING, dev, "Buffer #%d: received packet from %02Xh to %02Xh (%d+4 bytes)\n",
linux/drivers/net/arcnet/rfc1201.c:154:			arc_printk(D_EXTRA, dev, "short RFC1201 exception packet from %02Xh",
linux/drivers/net/arcnet/rfc1201.c:363:			arc_printk(D_SKB_SIZE, dev, "skb: received %d bytes from %02X (unsplit)\n",
linux/drivers/net/arcnet/rfc1201.c:365:			arc_printk(D_SKB_SIZE, dev, "skb: received %d bytes from %02X (split)\n",
linux/drivers/net/ethernet/netronome/nfp/nfp_main.c:463:			 "Invalid value '%s' from '%s', ignoring\n",
linux/drivers/net/ethernet/netronome/nfp/bpf/jit.c:689:/* wrp_reg_subpart() - load @field_len bytes from @offset of @src, write the
linux/drivers/net/ethernet/netronome/nfp/nfpcore/nfp_nsp.c:44:/* CPP address to retrieve the data from */
linux/drivers/net/ethernet/myricom/myri10ge/myri10ge.c:3033:	netdev_info(dev, "changing mtu from %d to %d\n", dev->mtu, new_mtu);
linux/drivers/net/ethernet/ti/am65-cpts.c:940: * This functions should be called from .xmit().
linux/drivers/net/ethernet/broadcom/bnx2.h:6951:						/* may be different from     */
linux/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:122:	new_max_eth_txqs = (BNX2X_NUM_ETH_QUEUES(bp) - from + to) *
linux/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:124:	if (from == FCOE_IDX(bp)) {
linux/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c:4702:		BNX2X_ERR("Adjusted num of queues from %d to %d\n",
linux/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:2773: * @last:	index to start looking from (including)
linux/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c:2898: * @start_bin:	index in the registry to start from (including)
linux/drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c:1357:	/* address of the NVRAM to read from */
linux/drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c:8327:			      " Port %d from %s part number %s\n",
linux/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.h:282:	/* Object to run the command from */
linux/drivers/net/ethernet/broadcom/bnxt/bnxt.c:3928:			netdev_warn(bp->dev, "RX ring size reduced from %d to %d because the jumbo ring is now enabled\n",
linux/drivers/net/ethernet/broadcom/b44.c:969:		/* Chip can't handle DMA to/from >1GB, use bounce buffer */
linux/drivers/net/ethernet/cavium/liquidio/lio_vf_main.c:361:				 "Max MTU Changed from %d to %d\n",
linux/drivers/net/ethernet/cavium/liquidio/lio_vf_main.c:368:				 "Current MTU is higher than new max MTU; Reducing the current mtu from %d to %d\n",
linux/drivers/net/ethernet/cavium/liquidio/lio_main.c:592:			netif_info(lio, probe, lio->netdev, "Max MTU changed from %d to %d\n",
linux/drivers/net/ethernet/cavium/liquidio/lio_main.c:598:				 "Current MTU is higher than new max MTU; Reducing the current mtu from %d to %d\n",
linux/drivers/net/ethernet/cavium/thunder/nicvf_queues.c:1259: * Taken from 'Tilera network driver' with a minor modification.
linux/drivers/net/ethernet/fungible/funeth/funeth_tx.c:75:/* Write a gather list to the Tx descriptor at @req from @ngle address/length
linux/drivers/net/ethernet/natsemi/natsemi.c:2812:	/* read the three words from (undocumented) RFCR vals 0xa, 0xc, 0xe */
linux/drivers/net/ethernet/natsemi/macsonic.c:239:		printk(KERN_WARNING "macsonic: cannot read MAC address from "
linux/drivers/net/ethernet/natsemi/sonic.c:379:			 * from { tx_skb[entry], td_status } as follows.
linux/drivers/net/ethernet/micrel/ksz884x.c:3203:	bits = len = from = to = 0;
linux/drivers/net/ethernet/micrel/ksz884x.c:3219:				from += 8;
linux/drivers/net/ethernet/micrel/ksz884x.c:3221:	} while (from < (int) frame_size);
linux/drivers/net/ethernet/micrel/ksz884x.c:3224:		val <<= (from % 8);
linux/drivers/net/ethernet/google/gve/gve_desc_dqo.h:127:			 * derived from `skb->hash`.
linux/drivers/net/ethernet/packetengines/hamachi.c:181:  #define IP_MF 0x2000   /* IP more frags from <netinet/ip.h> */
linux/drivers/net/ethernet/rocker/rocker_main.c:1970:	netdev_info(dev, "MTU change from %d to %d\n", dev->mtu, new_mtu);
linux/drivers/net/ethernet/8390/mac8390.c:660:	from <<= 1;	/* word, skip overhead */
linux/drivers/net/ethernet/8390/mac8390.c:663:	if (from & 2) {
linux/drivers/net/ethernet/8390/mac8390.c:829:	const unsigned short *from = fp;
linux/drivers/net/ethernet/8390/mac8390.c:841:	const volatile unsigned short *from = (const void *)fp;
linux/drivers/net/ethernet/intel/igbvf/netdev.c:2436:	netdev_dbg(netdev, "changing MTU from %d to %d\n",
linux/drivers/net/ethernet/intel/ice/ice_txrx_lib.c:326: * @frame: whether this comes from .ndo_xdp_xmit()
linux/drivers/net/ethernet/intel/ice/ice_common.c:4287:	from = src_ctx + ce_info->offset;
linux/drivers/net/ethernet/intel/ice/ice_common.c:4327:	from = src_ctx + ce_info->offset;
linux/drivers/net/ethernet/intel/ice/ice_common.c:4370:	from = src_ctx + ce_info->offset;
linux/drivers/net/ethernet/intel/ice/ice_common.c:4421:	from = src_ctx + ce_info->offset;
linux/drivers/net/ethernet/intel/ice/ice_ethtool.c:3007:	netdev_info(netdev, "Changing Tx descriptor count from %d to %d\n",
linux/drivers/net/ethernet/intel/ice/ice_ethtool.c:3036:	netdev_info(netdev, "Changing XDP descriptor count from %d to %d\n",
linux/drivers/net/ethernet/intel/ice/ice_ethtool.c:3066:	netdev_info(netdev, "Changing Rx descriptor count from %d to %d\n",
linux/drivers/net/ethernet/intel/i40e/i40e_main.c:2166: * __dev_(uc|mc)_sync from .set_rx_mode and guarantee to hold the hash lock.
linux/drivers/net/ethernet/intel/i40e/i40e_main.c:2185: * __dev_(uc|mc)_sync from .set_rx_mode and guarantee to hold the hash lock.
linux/drivers/net/ethernet/intel/i40e/i40e_main.c:2951:	netdev_dbg(netdev, "changing MTU from %d to %d\n",
linux/drivers/net/ethernet/intel/i40e/i40e_ethtool.c:2120:			    "Changing Tx descriptor count from %d to %d.\n",
linux/drivers/net/ethernet/intel/i40e/i40e_ethtool.c:2159:			    "Changing Rx descriptor count from %d to %d\n",
linux/drivers/net/ethernet/intel/i40e/i40e_common.c:4365: * @reg_val0: pointer for data read from 'reg_addr0'
linux/drivers/net/ethernet/intel/i40e/i40e_common.c:4367: * @reg_val1: pointer for data read from 'reg_addr1'
linux/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c:739:	from = src + ce_info->offset;
linux/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c:780:	from = src + ce_info->offset;
linux/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c:824:	from = src + ce_info->offset;
linux/drivers/net/ethernet/intel/i40e/i40e_lan_hmc.c:876:	from = src + ce_info->offset;
linux/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:6818:	netdev_dbg(netdev, "changing MTU from %d to %d\n",
linux/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c:9577:	 * link (e.g. nexthdr/eat parameters from 'tc'). This way we can map
linux/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c:3334:		hw_dbg(hw, "LINKS changed from %08X to %08X\n",
linux/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c:4291:	hw_dbg(hw, "changing MTU from %d to %d\n",
linux/drivers/net/ethernet/intel/e100.c:1708:	/* Software generated interrupt to recover from (rare) Rx
linux/drivers/net/ethernet/intel/igb/igb_main.c:6660:	netdev_dbg(netdev, "changing MTU from %d to %d\n",
linux/drivers/net/ethernet/intel/e1000e/netdev.c:6040:	netdev_dbg(netdev, "changing MTU from %d to %d\n",
linux/drivers/net/ethernet/intel/igc/igc_main.c:5081:	netdev_dbg(netdev, "changing MTU from %d to %d\n", netdev->mtu, new_mtu);
linux/drivers/net/ethernet/intel/iavf/iavf_ethtool.c:662:		netdev_dbg(netdev, "Changing Tx descriptor count from %d to %d\n",
linux/drivers/net/ethernet/intel/iavf/iavf_ethtool.c:668:		netdev_dbg(netdev, "Changing Rx descriptor count from %d to %d\n",
linux/drivers/net/ethernet/intel/iavf/iavf_main.c:1121: * __dev_(uc|mc)_sync from .set_rx_mode and guarantee to hold the hash lock.
linux/drivers/net/ethernet/intel/iavf/iavf_main.c:1139: * __dev_(uc|mc)_sync from .set_rx_mode and guarantee to hold the hash lock.
linux/drivers/net/ethernet/intel/iavf/iavf_main.c:4331:	netdev_dbg(netdev, "changing MTU from %d to %d\n",
linux/drivers/net/ethernet/intel/e1000/e1000_main.c:3572:	netdev_dbg(netdev, "changing MTU from %d to %d\n",
linux/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c:12373:			 "Channels changed, rss_size from %u to %u, tqps from %u to %u",
linux/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_tm.c:705:		dev_info(&hdev->pdev->dev, "rss changes from %u to %u\n",
linux/drivers/net/ethernet/hisilicon/hns3/hns3_ethtool.c:1199:	netdev_dbg(netdev, "Changing tx push from %s to %s\n",
linux/drivers/net/ethernet/hisilicon/hns3/hns3_ethtool.c:1241:		    "Changing Tx/Rx ring depth from %u/%u to %u/%u, Changing rx buffer len from %u to %u\n",
linux/drivers/net/ethernet/hisilicon/hns3/hns3_ethtool.c:1947:		netdev_info(netdev, "request to set tx spare buf size from %u to %u\n",
linux/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c:2748:		  "change mtu from %u to %d\n", netdev->mtu, new_mtu);
linux/drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_main.c:3166:			 "Channels changed, rss_size from %u to %u, tqps from %u to %u",
linux/drivers/net/ethernet/cirrus/cs89x0.c:262:	cs89_dbg(3, info, "EEPROM data from %x for %x:", off, len);
linux/drivers/net/ethernet/sfc/vfdi.h:127: * @op: Operation code or response indicator, taken from &enum vfdi_op.
linux/drivers/net/ethernet/sfc/falcon/filter.h:100: * @match_flags: Match type flags, from &enum ef4_filter_match_flags
linux/drivers/net/ethernet/sfc/falcon/filter.h:101: * @priority: Priority of the filter, from &enum ef4_filter_priority
linux/drivers/net/ethernet/sfc/falcon/filter.h:102: * @flags: Miscellaneous flags, from &enum ef4_filter_flags
linux/drivers/net/ethernet/sfc/falcon/efx.c:1343:			       "Reducing number of rx queues from %u to %u.\n",
linux/drivers/net/ethernet/sfc/falcon/net_driver.h:1035: *	from &enum ef4_init_mode.
linux/drivers/net/ethernet/sfc/falcon/falcon.c:2012:				     /* exclude PHY from "invisible" reset */
linux/drivers/net/ethernet/sfc/falcon/falcon.c:2239:		netif_dbg(efx, probe, efx->net_dev, "Booted from %s\n",
linux/drivers/net/ethernet/sfc/siena/vfdi.h:127: * @op: Operation code or response indicator, taken from &enum vfdi_op.
linux/drivers/net/ethernet/sfc/siena/filter.h:122: * @match_flags: Match type flags, from &enum efx_filter_match_flags
linux/drivers/net/ethernet/sfc/siena/filter.h:123: * @priority: Priority of the filter, from &enum efx_filter_priority
linux/drivers/net/ethernet/sfc/siena/filter.h:124: * @flags: Miscellaneous flags, from &enum efx_filter_flags
linux/drivers/net/ethernet/sfc/siena/filter.h:142: * @encap_type: Encapsulation type to match (from &enum efx_encap_type), if
linux/drivers/net/ethernet/sfc/siena/farch.c:1711:					  "Reducing VF count from from %d to %d\n",
linux/drivers/net/ethernet/sfc/siena/mcdi_pcol.h:7059:/* 32-bit address to read from */
linux/drivers/net/ethernet/sfc/siena/siena_sriov.c:544:				  "ERROR: Invalid INIT_EVQ from %s: evq %d bufs %d\n",
linux/drivers/net/ethernet/sfc/siena/siena_sriov.c:587:				  "ERROR: Invalid INIT_RXQ from %s: rxq %d evq %d "
linux/drivers/net/ethernet/sfc/siena/siena_sriov.c:628:				  "ERROR: Invalid INIT_TXQ from %s: txq %d evq %d "
linux/drivers/net/ethernet/sfc/siena/siena_sriov.c:772:				  "ERROR: Invalid INSERT_FILTER from %s: rxq %d "
linux/drivers/net/ethernet/sfc/siena/siena_sriov.c:819:				  "ERROR: Invalid SET_STATUS_PAGE from %s\n",
linux/drivers/net/ethernet/sfc/siena/siena_sriov.c:892:				  "ERROR: Unable to fetch VFDI request from %s rc %d\n",
linux/drivers/net/ethernet/sfc/siena/siena_sriov.c:902:				  "vfdi request %d from %s ok\n",
linux/drivers/net/ethernet/sfc/siena/siena_sriov.c:1453:			  "ERROR: Screaming VFDI request from %s\n",
linux/drivers/net/ethernet/sfc/siena/net_driver.h:1295: *	from &enum efx_int_mode.
linux/drivers/net/ethernet/sfc/siena/efx_channels.c:100:			       "Reducing number of rx queues from %u to %u.\n",
linux/drivers/net/ethernet/sfc/siena/efx_channels.c:113:				   "Reducing number of RSS channels from %u to %u for "
linux/drivers/net/ethernet/sfc/filter.h:125: * @match_flags: Match type flags, from &enum efx_filter_match_flags
linux/drivers/net/ethernet/sfc/filter.h:126: * @priority: Priority of the filter, from &enum efx_filter_priority
linux/drivers/net/ethernet/sfc/filter.h:127: * @flags: Miscellaneous flags, from &enum efx_filter_flags
linux/drivers/net/ethernet/sfc/filter.h:148: * @encap_type: Encapsulation type to match (from &enum efx_encap_type), if
linux/drivers/net/ethernet/sfc/ef10.c:1152:			  "Reducing channel VIs from %u to %u\n",
linux/drivers/net/ethernet/sfc/mcdi_pcol.h:8784:/* 32-bit address to read from */
linux/drivers/net/ethernet/sfc/mcdi_pcol.h:25310: * returned by MC_CMD_VIRTIO_FINI_QUEUE of the queue being migrated from (or
linux/drivers/net/ethernet/sfc/mcdi_pcol.h:25321: * MC_CMD_VIRTIO_FINI_QUEUE of the queue being migrated from (or equivalent if
linux/drivers/net/ethernet/sfc/ef100_rep.h:36: * @read_index: number of packets consumed from @rx_list
linux/drivers/net/ethernet/sfc/net_driver.h:1390: *	from &enum efx_int_mode.
linux/drivers/net/ethernet/sfc/efx_channels.c:99:			       "Reducing number of rx queues from %u to %u.\n",
linux/drivers/net/ethernet/sfc/efx_channels.c:112:				   "Reducing number of RSS channels from %u to %u for "
linux/drivers/net/ethernet/huawei/hinic/hinic_ethtool.c:604:		   "Change Tx/Rx ring depth from %d/%d to %d/%d\n",
linux/drivers/net/ethernet/huawei/hinic/hinic_ethtool.c:900:	netif_info(nic_dev, drv, netdev, "Set max combined queue number from %d to %d\n",
linux/drivers/net/ethernet/apple/bmac.c:1139:	/* send out the address we want to read from */
linux/drivers/net/ethernet/sun/sunvnet_common.h:54: * port, and the net_device can be found from ->dev. If the
linux/drivers/net/ethernet/sun/sunvnet_common.h:55: * vsw bit is not set, the net_device is available from ->vp->dev.
linux/drivers/net/ethernet/sun/cassini.c:4822:	 * all of the REQ/GNT pairs from [8:3].  Bits 2 to 0 control
linux/drivers/net/ethernet/amd/ariadne.c:216:			netdev_dbg(dev, "RX pkt type 0x%04x from %pM to %pM data %p len %u\n",
linux/drivers/net/ethernet/amd/ariadne.c:569:	netdev_dbg(dev, "TX pkt type 0x%04x from %pM to %pM data %p len %u\n",
linux/drivers/net/ethernet/amd/atarilance.c:802:		printk( "%s: TX pkt type 0x%04x from %pM to %pM"
linux/drivers/net/ethernet/amd/atarilance.c:1015:					printk(KERN_DEBUG "%s: RX pkt type 0x%04x from %pM to %pM "
linux/drivers/net/ethernet/amd/sun3lance.c:595:			" from %s to %s"
linux/drivers/net/ethernet/amd/sun3lance.c:811:					       " from %pM to %pM",
linux/drivers/net/ethernet/mellanox/mlx5/core/en_main.c:5772:			       "MLX5E: Updating max number of channels from %u to %u\n",
linux/drivers/net/ethernet/mellanox/mlx5/core/pci_irq.c:560: * This function is requests nirqs IRQs, starting from @vecidx.
linux/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge_mcast.c:401:	unsigned int from = MLX5_ESW_BRIDGE_MCAST_TABLE_VLAN_GRP_IDX_FROM;
linux/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge_mcast.c:411:	unsigned int from = MLX5_ESW_BRIDGE_MCAST_TABLE_QINQ_GRP_IDX_FROM;
linux/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c:134:	unsigned int from = MLX5_ESW_BRIDGE_INGRESS_TABLE_VLAN_GRP_IDX_FROM;
linux/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c:144:	unsigned int from = MLX5_ESW_BRIDGE_INGRESS_TABLE_QINQ_GRP_IDX_FROM;
linux/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c:193:	unsigned int from = MLX5_ESW_BRIDGE_INGRESS_TABLE_VLAN_FILTER_GRP_IDX_FROM;
linux/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c:204:	unsigned int from = MLX5_ESW_BRIDGE_INGRESS_TABLE_QINQ_FILTER_GRP_IDX_FROM;
linux/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c:286:	unsigned int from = MLX5_ESW_BRIDGE_EGRESS_TABLE_VLAN_GRP_IDX_FROM;
linux/drivers/net/ethernet/mellanox/mlx5/core/esw/bridge.c:296:	unsigned int from = MLX5_ESW_BRIDGE_EGRESS_TABLE_QINQ_GRP_IDX_FROM;
linux/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c:521:	const void *from = page_address(page) + offset_from;
linux/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c:962:	from = shampo->ci;
linux/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c:963:	if (from + len > shampo->hd_per_wq) {
linux/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c:966:		from = 0;
linux/drivers/net/ethernet/mellanox/mlx5/core/cmd.c:1291:	from += copy;
linux/drivers/net/ethernet/mellanox/mlx5/core/cmd.c:1303:		from += copy;
linux/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c:3119:	/* Number of VFs can only change from "0 to x" or "x to 0". */
linux/drivers/net/ethernet/mellanox/mlxsw/reg.h:2842:	/* Move rules. Moves the rules from "tcam_region_info" starting
linux/drivers/net/ethernet/mellanox/mlxsw/reg.h:2847:	/* Copy rules. Copies the rules from "tcam_region_info" starting
linux/drivers/net/ethernet/mellanox/mlxsw/reg.h:10250: * 10^9 HW clocks for 1 HW second. Range is from -50,000,000 to +50,000,000.
linux/drivers/net/ethernet/mellanox/mlxsw/reg.h:10277: * Range is from -32768 to +32767.
linux/drivers/net/ethernet/mellanox/mlx4/cmd.c:2282:		mlx4_warn(dev, "Got command event with bitmask from %d slaves but %d were served\n",
linux/drivers/net/ethernet/mellanox/mlx4/mlx4.h:1455:/* Remove bitmap indicated by <uid> from <zone_alloc> */
linux/drivers/net/ethernet/mellanox/mlx4/mlx4.h:1471:/* Free <count> objects, start from <obj> of the uid <uid> from zone_allocator
linux/drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:1114:	dev_info(&pdev->dev, "loading firmware from %s\n",
linux/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:50:MODULE_PARM_DESC(load_fw_file, "Load firmware from (0=flash, 1=file, 2=POST in fast mode, 3= POST in medium mode, 4=POST in slow mode)");
linux/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:3376:		dev_info(&adapter->pdev->dev, "Detected state change from "
linux/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c:3040:					 "%s: lock to be recovered from %d\n",
linux/drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:982:	dev_info(&pdev->dev, "loading firmware from %s\n",
linux/drivers/net/ethernet/qlogic/qed/qed_mcp.c:1191:		   "Reading Disabled VF information from [offset %08x], path_addr %08x\n",
linux/drivers/net/ethernet/qlogic/qed/qed_cxt.c:1813:	/* Determine the right map to take this CID from */
linux/drivers/net/ethernet/qlogic/qed/qed_main.c:2368:			DP_ERR(cdev, "Failed reading from %08x\n",
linux/drivers/net/ethernet/qlogic/qed/qed_int.c:282:			  "Illegal read by chip from [%08x:%08x] blocked.\n"
linux/drivers/net/ethernet/qlogic/qed/qed_int.c:1933:	/* calculate where to read the status bit from */
linux/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c:660:		netdev_info(netdev, "Changing Tx ring size from %d to %d\n",
linux/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c:664:		netdev_info(netdev, "Changing Rx ring size from %d to %d\n",
linux/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c:736:			netdev_info(netdev, "Changing queue count from %d to %d\n",
linux/drivers/net/ethernet/pensando/ionic/ionic_ethtool.c:752:			netdev_info(netdev, "Changing queue count from %d to %d\n",
linux/drivers/net/ethernet/ibm/ibmvnic.c:681: * @offset: (Output) offset of buffer in the LTB from @ltbp
linux/drivers/net/ethernet/ibm/ibmvnic.c:716: * @offset: (Output) offset of buffer in the LTB from @ltbp
linux/drivers/net/ethernet/ibm/ibmvnic.c:2735:					   "Open changed state from %s, updating.\n",
linux/drivers/net/ethernet/ibm/emac/core.c:697:	   (from "The Switch Book") (100Mbps, without preamble, inter-frame gap):
linux/drivers/net/ethernet/smsc/smc91c92_cs.c:1276:    /* select this as the packet to read from */
linux/drivers/net/ethernet/smsc/smc9194.c:1262:	/* select this as the packet to read from */
linux/drivers/net/ethernet/smsc/smc91x.c:718:	/* select packet to read from */
linux/drivers/net/ethernet/smsc/smc91x.c:1658:	/* set the EEPROM address to get the data from */
linux/drivers/net/ethernet/qualcomm/emac/emac.c:218:		  "changing MTU from %d to %d\n", netdev->mtu,
linux/drivers/net/ethernet/chelsio/cxgb3/sge.c:577:	struct rx_desc *from = &q->desc[idx];
linux/drivers/net/ethernet/chelsio/cxgb3/sge.c:1383:	struct work_request_hdr *from = (struct work_request_hdr *)skb->data;
linux/drivers/net/ethernet/chelsio/cxgb3/sge.c:1647:	from = (struct work_request_hdr *)skb->data;
linux/drivers/net/ethernet/chelsio/cxgb/sge.c:1005:	struct freelQ_e *from = &fl->entries[idx];
linux/drivers/net/ethernet/chelsio/cxgb4/sge.c:900: *	@len: length of data from @start to send out
linux/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:254:		/* Since we can be called while atomic (from "interrupt
linux/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c:4828:		/* Get FW from from /lib/firmware/ */
linux/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c:3460:	string_get_size((u64)to - from + 1, 1, STRING_UNITS_2, buf,
linux/drivers/net/ethernet/chelsio/cxgb4/cxgb4_dcb.c:133:	netdev_dbg(dev, "%s: State change from %d to %d for %s\n",
linux/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c:1180:/* Fetch the @region_name's start and end from @meminfo. */
linux/drivers/net/ethernet/mscc/ocelot.c:1282:	/* Set row and column to read from */
linux/drivers/net/ethernet/mscc/ocelot_stats.c:328:	/* Configure the port to read the stats from */
linux/drivers/net/ethernet/cisco/enic/vnic_devcmd.h:124:	/* add addr from (u48)a0 */
linux/drivers/net/ethernet/cisco/enic/vnic_devcmd.h:128:	/* del addr from (u48)a0 */
linux/drivers/net/ethernet/marvell/mvneta.c:2046:				pr_err("Can't refill queue %d. Done %d from %d\n",
linux/drivers/net/ethernet/marvell/octeontx2/af/rvu.c:300:	/* Check if the 'pcifunc' has a NIX LF from 'BLKADDR_NIX0' or
linux/drivers/net/ethernet/marvell/octeontx2/af/rvu_npc.c:1957:		 * STAT_SEL bitpos incremented from [0:8] to [0:11] and ENA bit moved to 63
linux/drivers/net/ethernet/marvell/octeontx2/nic/otx2_vf.c:447:	netdev_info(netdev, "Changing MTU from %d to %d\n",
linux/drivers/net/ethernet/marvell/octeontx2/nic/otx2_dcbnl.c:19:				 "Increase number of tx queues from %d to %d to support PFC.\n",
linux/drivers/net/ethernet/marvell/octeontx2/nic/otx2_pf.c:66:	netdev_info(netdev, "Changing MTU from %d to %d\n",
linux/drivers/net/ethernet/freescale/dpaa2/dpaa2-eth.c:2381:/* Copy mac unicast addresses from @net_dev to @priv.
linux/drivers/net/ethernet/freescale/dpaa2/dpaa2-eth.c:2400:/* Copy mac multicast addresses from @net_dev to @priv
linux/drivers/net/ethernet/freescale/enetc/enetc_qos.c:749:		struct action_gate_entry *from = &sgi->entries[i];
linux/drivers/net/ethernet/freescale/fman/fman_sp.h:33:	 *  context is copied to (Rx) or taken from (Tx, Op).
linux/drivers/net/ethernet/amazon/ena/ena_netdev.c:613:				   "XDP program is set, changing the max_mtu from %d to %d",
linux/drivers/net/ethernet/amazon/ena/ena_netdev.c:1116:			   "Refilled rx qid %d with only %d buffers (from %d)\n",
linux/drivers/net/ethernet/toshiba/ps3_gelic_wireless.h:15:/* return value from  GELIC_LV1_GET_WLAN_EVENT netcontrol */
linux/drivers/net/ethernet/toshiba/spider_net.c:1035:			int from = (chain->num_desc + off - cnt) % chain->num_desc;
linux/drivers/net/ethernet/toshiba/spider_net.c:1037:			dev_info(dev, "Have %d (from %d to %d) descrs "
linux/drivers/net/usb/pegasus.c:761:				   "intr interval changed from %ums to %ums\n",
linux/drivers/net/usb/Kconfig:225:	  from <http://www.usb.org/>.
linux/drivers/net/usb/Kconfig:252:	  from <http://www.usb.org/>.
linux/drivers/net/usb/Kconfig:267:	  available from <http://www.usb.org/>.
linux/drivers/net/usb/Kconfig:302:	  available from <http://www.usb.org/>.
linux/drivers/net/can/usb/etas_es58x/es581_4.c:81:			netdev_err(netdev, "Echo packet idx jumped from %u to %u\n",
linux/drivers/net/can/usb/etas_es58x/es58x_core.c:1299: * number of bytes consumed from @urb if successful.
linux/drivers/net/can/usb/etas_es58x/es58x_core.c:1349: * number of bytes consumed from @urb if successful.
linux/drivers/net/can/usb/etas_es58x/es58x_fd.c:85:			netdev_err(netdev, "Packet idx jumped from %u to %u\n",
linux/drivers/net/can/dev/dev.c:104:	netdev_dbg(dev, "Controller changed from %s State (%d) into %s State (%d).\n",
linux/drivers/net/can/ctucanfd/ctucanfd_base.c:831:		netdev_info(ndev, "state changes from %s to %s\n",
linux/drivers/net/wireless/ti/wlcore/wlcore.h:408:	/* last wlvif we transmitted from */
linux/drivers/net/wireless/ti/wlcore/main.c:1595:			wl1271_warning("Failed to create an RX filter from "
linux/drivers/net/wireless/broadcom/b43/xmit.h:369:/* Helper functions for converting the key-table index from "firmware-format"
linux/drivers/net/wireless/broadcom/b43/phy_common.h:141: * 			(from @recalc_txpower) to the hardware.
linux/drivers/net/wireless/broadcom/b43/main.c:2680:		b43err(dev->wl, "YOUR FIRMWARE IS TOO OLD. Firmware from "
linux/drivers/net/wireless/broadcom/brcm80211/brcmsmac/main.h:99:#define BOARDREV_PROMOTABLE	0xFF	/* from */
linux/drivers/net/wireless/broadcom/brcm80211/brcmsmac/main.c:3409:/* derive wlc->band->basic_rate[] table from 'rateset' */
linux/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c:2757:	int eprec = -1;		/* precedence to evict from */
linux/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c:236: * a board specific nvram is loaded from /lib/firmware. On most boards the
linux/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c:5534:		/* is for p2p listen response or for p2p GO from     */
linux/drivers/net/wireless/broadcom/b43legacy/xmit.h:227:/* Helper functions for converting the key-table index from "firmware-format"
linux/drivers/net/wireless/ath/ath6kl/hif.h:98: *             from the contexts these operations get called from (a driver's
linux/drivers/net/wireless/ath/ath6kl/hif.h:191:	/* bounce buffer for upper layers to copy to/from */
linux/drivers/net/wireless/ath/ath6kl/txrx.c:1072:	 * We must deque from "idx" to "idx_end", including both.
linux/drivers/net/wireless/ath/ath6kl/htc.h:317:	/* endpoint that this packet was sent/recv'd from */
linux/drivers/net/wireless/ath/ath12k/wmi.h:4200:/* U-APSD configuration of peer station from (re)assoc request and TSPECs */
linux/drivers/net/wireless/ath/ath12k/rx_desc.h:1021: *		for the destination is the same as 'vdev_id' (from 'RX_MPDU_PCU_START')
linux/drivers/net/wireless/ath/ath12k/rx_desc.h:1025: *		If intra_bss is set, copied by RXOLE from 'ADDR_SEARCH_ENTRY'
linux/drivers/net/wireless/ath/ath12k/hal_desc.h:735: *		Passed on from 'RX_MSDU_END' TLV (only the MSB is reported as
linux/drivers/net/wireless/ath/ath12k/hal_desc.h:740: *		Passed on from 'RX_ATTENTION' TLV
linux/drivers/net/wireless/ath/ath12k/hal_desc.h:745: *		Passed on from 'RX_ATTENTION' TLV
linux/drivers/net/wireless/ath/ath12k/hal_desc.h:761: *		If intra_bss is set, copied by RXOLE/RXDMA from 'ADDR_SEARCH_ENTRY'
linux/drivers/net/wireless/ath/ath12k/hal_desc.h:1305: *		from 'TCL_DATA_CMD' that do not change often within one virtual
linux/drivers/net/wireless/ath/ath12k/core.c:311:			   "failed to fetch board data for %s from %s\n",
linux/drivers/net/wireless/ath/ath12k/core.c:358:		ath12k_err(ab, "failed to fetch board-2.bin or board.bin from %s\n",
linux/drivers/net/wireless/ath/wcn36xx/hal.h:1448:	 * This value is derived from "Supported MCS Set field" inside
linux/drivers/net/wireless/ath/wcn36xx/hal.h:1614:	 * This value is derived from "Supported MCS Set field" inside
linux/drivers/net/wireless/ath/wcn36xx/main.c:896:			 * config_sta must be called from  because this is the
linux/drivers/net/wireless/ath/ath5k/base.c:1322:				"fixing mactime from %llx to %llx\n",
linux/drivers/net/wireless/ath/ath9k/common-spectral.c:586:			 * prevent from "fixing" a correct frame.
linux/drivers/net/wireless/ath/wil6210/wmi.h:1612:	/* rf index to read offsets from */
linux/drivers/net/wireless/ath/wil6210/wmi.c:1178:	wil_dbg_wmi(wil, "EAPOL len %d from %pM MID %d\n", eapol_len,
linux/drivers/net/wireless/ath/wil6210/wmi.c:1338:	wil_dbg_wmi(wil, "DELBA MID %d CID %d TID %d from %s reason %d\n",
linux/drivers/net/wireless/ath/wil6210/txrx.c:433:/* reap 1 frame from @swhead
linux/drivers/net/wireless/ath/wil6210/cfg80211.c:815:	if (from == NL80211_IFTYPE_STATION &&
linux/drivers/net/wireless/ath/wil6210/fw.h:30:/* data block. write starting from @addr
linux/drivers/net/wireless/ath/wil6210/fw.h:39:/* fill with constant @value, @size bytes starting from @addr */
linux/drivers/net/wireless/ath/wil6210/wil6210.h:748:	 * tx_latency_res is configured from "tx_latency" debug-fs.
linux/drivers/net/wireless/ath/ath11k/wmi.h:5016:/* U-APSD configuration of peer station from (re)assoc request and TSPECs */
linux/drivers/net/wireless/ath/ath11k/debugfs_htt_stats.h:1959:	 * the desense levels range from -5 to 15 in dB units,
linux/drivers/net/wireless/ath/ath11k/core.c:1223:			   "failed to fetch %s for %s from %s\n",
linux/drivers/net/wireless/ath/ath11k/core.c:1294:		ath11k_err(ab, "failed to fetch board data for %s from %s\n",
linux/drivers/net/wireless/ath/ath11k/core.c:1297:			ath11k_err(ab, "failed to fetch board data for %s from %s\n",
linux/drivers/net/wireless/ath/ath11k/core.c:1300:		ath11k_err(ab, "failed to fetch board.bin from %s\n",
linux/drivers/net/wireless/ath/ath11k/core.c:1331:		ath11k_dbg(ab, ATH11K_DBG_BOOT, "failed to fetch %s from %s\n",
linux/drivers/net/wireless/ath/ath10k/pci.c:1036:		ath10k_warn(ar, "failed to memcpy firmware memory from %d (%d B): %d\n",
linux/drivers/net/wireless/ath/ath10k/wmi.h:6026:/* U-APSD configuration of peer station from (re)assoc request and TSPECs */
linux/drivers/net/wireless/ath/ath10k/core.c:1524:			   "failed to fetch board data for %s from %s/%s\n",
linux/drivers/net/wireless/ath/ath10k/core.c:1657:		ath10k_err(ar, "failed to fetch board-2.bin or board.bin from %s\n",
linux/drivers/net/wireless/ath/ath10k/core.c:2151:		ath10k_warn(ar, "No ATH10K_FW_IE_FW_IMAGE found from '%s/%s', skipping\n",
linux/drivers/net/wireless/ath/ath10k/core.c:2205:	ath10k_err(ar, "Failed to find firmware-N.bin (N between %d and %d) from %s: %d",
linux/drivers/net/wireless/intel/iwlegacy/commands.h:421:	/* calibration values from "initialize" uCode */
linux/drivers/net/wireless/intel/iwlegacy/4965-mac.c:2947:	D_TX_REPLY("N_COMPRESSED_BA [%d] Received from %pM, " "sta_id = %d\n",
linux/drivers/net/wireless/intel/iwlegacy/4965.c:441: * Called after N_ALIVE notification received from "initialize" uCode.
linux/drivers/net/wireless/intel/iwlegacy/4965.c:1414:		D_INFO("Return from !new_assoc RXON.\n");
linux/drivers/net/wireless/intel/iwlegacy/4965.c:1516:		IL_ERR("invalid channel switch from %u to %u\n",
linux/drivers/net/wireless/intel/iwlegacy/4965.c:1672:			D_TEMP("Temperature changed " "from %ldC to %ldC\n",
linux/drivers/net/wireless/intel/iwlegacy/3945-mac.c:858: * The WRITE idx maps to the last position the driver has read from -- the
linux/drivers/net/wireless/intel/iwlegacy/3945-mac.c:2079: * Called after N_ALIVE notification received from "initialize" uCode.
linux/drivers/net/wireless/intel/iwlegacy/common.c:245:		IL_ERR("Bad return from %s (0x%08X)\n",
linux/drivers/net/wireless/intel/iwlegacy/common.c:253:		D_HC_DUMP("back from %s (0x%08X)\n",
linux/drivers/net/wireless/intel/iwlegacy/common.c:257:		D_HC("back from %s (0x%08X)\n", il_get_cmd_string(cmd->hdr.cmd),
linux/drivers/net/wireless/intel/iwlegacy/common.c:2482: * The WRITE idx maps to the last position the driver has read from -- the
linux/drivers/net/wireless/intel/iwlegacy/4965.h:416: *     (from "initialize alive") and factory-measured power supply voltage
linux/drivers/net/wireless/intel/iwlwifi/iwl-fh.h:137:/* Defines the 64bits DRAM start address to read the DMA data block from */
linux/drivers/net/wireless/intel/iwlwifi/fw/error-dump.h:69: * @len: the length starting from %data
linux/drivers/net/wireless/intel/iwlwifi/fw/error-dump.h:93: * @file_len: the length of all the file starting from %barker
linux/drivers/net/wireless/intel/iwlwifi/fw/error-dump.h:255: * @len: the length starting from %data
linux/drivers/net/wireless/intel/iwlwifi/fw/api/rs.h:137: * @max_ch_width: max supported channel width from @enum iwl_tlc_mng_cfg_cw
linux/drivers/net/wireless/intel/iwlwifi/fw/api/rs.h:172: * @max_ch_width: max supported channel width from &enum iwl_tlc_mng_cfg_cw
linux/drivers/net/wireless/intel/iwlwifi/fw/api/datapath.h:524: * @action: the action, from &enum iwl_rx_baid_action
linux/drivers/net/wireless/intel/iwlwifi/fw/api/datapath.h:562: * @u.add.flags: flags from &enum iwl_tx_queue_cfg_actions, except
linux/drivers/net/wireless/intel/iwlwifi/fw/api/datapath.h:627: * @action: action from &enum iwl_ctxt_action
linux/drivers/net/wireless/intel/iwlwifi/fw/api/datapath.h:631: * @u.add.key: key material. WEP keys should start from &IWL_SEC_WEP_KEY_OFFSET.
linux/drivers/net/wireless/intel/iwlwifi/fw/api/d3.h:370: * @wakeup_filter: filter from &enum iwl_wowlan_wakeup_filters
linux/drivers/net/wireless/intel/iwlwifi/fw/api/commands.h:12: * @LEGACY_GROUP: legacy group, uses command IDs from &enum iwl_legacy_cmds
linux/drivers/net/wireless/intel/iwlwifi/fw/api/commands.h:14: *	from &enum iwl_legacy_cmds
linux/drivers/net/wireless/intel/iwlwifi/fw/api/commands.h:25: * @NAN_GROUP: NAN group, uses command IDs from &enum iwl_nan_subcmd_ids
linux/drivers/net/wireless/intel/iwlwifi/fw/api/commands.h:32: * @DEBUG_GROUP: Debug group, uses command IDs from &enum iwl_debug_cmds
linux/drivers/net/wireless/intel/iwlwifi/fw/api/mac.h:311: * @qos_flags: from &enum iwl_mac_qos_flags
linux/drivers/net/wireless/intel/iwlwifi/fw/api/stats.h:406: * @flags: flags from &enum iwl_statistics_cmd_flags
linux/drivers/net/wireless/intel/iwlwifi/fw/api/sta.h:212: * @modify_mask: from &enum iwl_sta_modify_flag, selects what to change
linux/drivers/net/wireless/intel/iwlwifi/fw/api/sta.h:292: * @modify_mask: from &enum iwl_sta_modify_flag, selects what to change
linux/drivers/net/wireless/intel/iwlwifi/fw/api/mac-cfg.h:403: * @modify_mask: from &enum iwl_link_ctx_modify_flags, selects what to change.
linux/drivers/net/wireless/intel/iwlwifi/fw/api/mac-cfg.h:414: * @qos_flags: from &enum iwl_mac_qos_flags
linux/drivers/net/wireless/intel/iwlwifi/fw/api/mac-cfg.h:426: * @flags: a combination from &enum iwl_link_ctx_flags
linux/drivers/net/wireless/intel/iwlwifi/fw/api/power.h:161: * @flags:	Power table command flags from &enum iwl_device_power_flags
linux/drivers/net/wireless/intel/iwlwifi/fw/api/power.h:433: * @ops: operations, value from &enum iwl_geo_per_chain_offset_operation
linux/drivers/net/wireless/intel/iwlwifi/fw/api/power.h:443: * @ops: operations, value from &enum iwl_geo_per_chain_offset_operation
linux/drivers/net/wireless/intel/iwlwifi/fw/api/power.h:455: * @ops: operations, value from &enum iwl_geo_per_chain_offset_operation
linux/drivers/net/wireless/intel/iwlwifi/fw/api/power.h:467: * @ops: operations, value from &enum iwl_geo_per_chain_offset_operation
linux/drivers/net/wireless/intel/iwlwifi/fw/api/power.h:479: * @ops: operations, value from &enum iwl_geo_per_chain_offset_operation
linux/drivers/net/wireless/intel/iwlwifi/fw/api/rx.h:891: * @hash_mask: Type of RSS to use. Values are from %iwl_rss_hash_func_en
linux/drivers/net/wireless/intel/iwlwifi/dvm/devices.c:408:	IWL_DEBUG_11H(priv, "channel switch from %d to %d\n",
linux/drivers/net/wireless/intel/iwlwifi/dvm/devices.c:576:	IWL_DEBUG_11H(priv, "channel switch from %u to %u\n",
linux/drivers/net/wireless/intel/iwlwifi/dvm/scan.c:225:	 * and prevent the background work from "completing"
linux/drivers/net/wireless/intel/iwlwifi/dvm/tx.c:1320:	IWL_DEBUG_TX_REPLY(priv, "REPLY_COMPRESSED_BA [%d] Received from %pM, "
linux/drivers/net/wireless/intel/iwlwifi/iwl-dbg-tlv.c:983:				 "WRT: Override min interval from %u to %u msec\n",
linux/drivers/net/wireless/intel/iwlwifi/mvm/quota.c:120:		IWL_DEBUG_QUOTA(mvm, "quota: adjust for NoA from %d to %d\n",
linux/drivers/net/wireless/intel/iwlwifi/mvm/tdls.c:631:		       "Received TDLS ch switch action %s from %pM status %d\n",
linux/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c:911:			 "reached %d old SN frames from %pM on queue %d, stopping BA session on TID %d\n",
linux/drivers/net/wireless/intel/iwlwifi/mvm/utils.c:744:				"Frame from %pM timed out, tid %d",
linux/drivers/net/wireless/intel/iwlwifi/mvm/sta.h:89: * created and deleted by the %sta_state callback from %ieee80211_ops.
linux/drivers/net/wireless/intel/iwlwifi/mvm/sta.h:103: * callback from %ieee80211_ops which can sleep. The next paragraph explains
linux/drivers/net/wireless/intel/iwlwifi/mvm/sta.h:302: * @type: value from &iwl_mvm_rxq_notif_type
linux/drivers/net/wireless/intel/iwlwifi/mvm/tx.c:2157:			   "BA_NOTIFICATION Received from %pM, sta_id = %d\n",
linux/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c:5991:				"BAR received from %pM, tid %d, ssn %d",
linux/drivers/net/wireless/intel/iwlwifi/pcie/rx.c:40: * The WRITE index maps to the last position the driver has read from -- the
linux/drivers/net/wireless/intel/ipw2x00/ipw2200.c:3922:	IPW_DEBUG_ASSOC("Disassociation attempt from %pM "
linux/drivers/net/wireless/intel/ipw2x00/ipw2200.c:5049: * The WRITE index maps to the last position the driver has read from -- the
linux/drivers/net/wireless/intel/ipw2x00/libipw_rx.c:469:			       "from %pM\n", dev->name, hdr->addr2);
linux/drivers/net/wireless/intel/ipw2x00/libipw_rx.c:654:				     "frame from %pM (drop_unencrypted=1)\n",
linux/drivers/net/wireless/intel/ipw2x00/libipw_rx.c:726:			printk(KERN_DEBUG "%s: dropped frame from "
linux/drivers/net/wireless/quantenna/qtnfmac/qlink.h:151: * @flags: channel flags from &enum qlink_channel_flags
linux/drivers/net/wireless/virtual/mac80211_hwsim.h:302: * @HWSIM_RATE_INFO_ATTR_FLAGS: bitflag of flags from &enum rate_info_flags
linux/drivers/net/wireless/virtual/mac80211_hwsim.h:306: * @HWSIM_RATE_INFO_ATTR_BW: bandwidth (from &enum rate_info_bw)
linux/drivers/net/wireless/virtual/mac80211_hwsim.h:307: * @HWSIM_RATE_INFO_ATTR_HE_GI: HE guard interval (from &enum nl80211_he_gi)
linux/drivers/net/wireless/virtual/mac80211_hwsim.h:309: * @HWSIM_RATE_INFO_ATTR_HE_RU_ALLOC:  HE RU allocation (from &enum nl80211_he_ru_alloc,
linux/drivers/net/wireless/virtual/mac80211_hwsim.h:312: * @HWSIM_RATE_INFO_ATTR_EHT_GI: EHT guard interval (from &enum nl80211_eht_gi)
linux/drivers/net/wireless/virtual/mac80211_hwsim.h:313: * @HWSIM_RATE_INFO_ATTR_EHT_RU_ALLOC: EHT RU allocation (from &enum nl80211_eht_ru_alloc,
linux/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h:146: * from &rxdone_entry_desc to a signal value type.
linux/drivers/net/wireless/st/cw1200/txrx.c:609:			pr_debug("Modified Listen Interval to %d from %d\n",
linux/drivers/net/wireless/intersil/hostap/hostap_80211_rx.c:665:			       "received packet from %pM\n",
linux/drivers/net/wireless/intersil/hostap/hostap_80211_rx.c:826:			       "from %pM\n", dev->name, hdr->addr2);
linux/drivers/net/wireless/intersil/hostap/hostap_80211_rx.c:924:			printk(KERN_DEBUG "%s: Rx cannot get skb from "
linux/drivers/net/wireless/intersil/hostap/hostap_80211_rx.c:999:			       "frame from %pM (drop_unencrypted=1)\n",
linux/drivers/net/wireless/intersil/hostap/hostap_80211_rx.c:1026:			printk(KERN_DEBUG "%s: dropped frame from "
linux/drivers/net/wireless/intersil/hostap/hostap_ap.c:1305:		       "(len=%d) from %pM\n", dev->name, len, hdr->addr2);
linux/drivers/net/wireless/intersil/hostap/hostap_ap.c:1514:		       "(len=%d, reassoc=%d) from %pM\n",
linux/drivers/net/wireless/intersil/hostap/hostap_ap.c:1592:			PDEBUG(DEBUG_AP, "%s: assoc from %pM"
linux/drivers/net/wireless/intersil/hostap/hostap_ap.c:1739:		printk("%s: deauthentication from %pM, "
linux/drivers/net/wireless/intersil/hostap/hostap_ap.c:1781:		printk("%s: disassociation from %pM, "
linux/drivers/net/wireless/intersil/hostap/hostap_ap.c:3015:			printk(KERN_DEBUG "%s: dropped received packet from %pM"
linux/drivers/net/wireless/intersil/p54/fwio.c:99:				printk(KERN_INFO "p54: rx_mtu reduced from %d "
linux/drivers/net/wireless/intersil/orinoco/wext.c:104:	 * the interface to disappear from /proc/net/wireless */
linux/drivers/net/wireless/intersil/orinoco/hermes.c:516:		       "Truncating LTV record from %d to %d bytes. "
linux/drivers/net/wireless/intersil/orinoco/main.c:12: *	With some help from :
linux/drivers/net/wireless/intersil/orinoco/main.c:978:			printk(KERN_WARNING "%s: Received encrypted frame from "
linux/drivers/net/wireless/intersil/orinoco/main.c:994:			       "Invalid Michael MIC in data frame from %pM, "
linux/drivers/net/wireless/cisco/airo.c:3703:			wstats.qual = 0; /* XXX Where do I get that info from ??? */
linux/drivers/net/wireless/marvell/libertas/cmd.c:650:	lbs_deb_cmd("channel switch from %d to %d\n", old_channel,
linux/drivers/net/wireless/marvell/mwifiex/pcie.c:2334:			    "info: dnld wifi firmware from %d bytes\n", offset);
linux/drivers/net/wireless/marvell/mwifiex/sdio.c:1818:			/* Reading data from "start_port + 0" to "start_port +
linux/drivers/net/wireless/marvell/mwifiex/sdio.c:2251:			/* Writing data from "start_port + 0" to "start_port +
linux/drivers/net/wireless/marvell/mwifiex/sta_event.c:221:		    "info: successfully disconnected from %pM: reason code %d\n",
linux/drivers/net/wireless/silabs/wfx/traces.h:475:	TP_printk("got skb from %d/%d, pend. hw/norm/cab: [ %d/%d/%d %d/%d/%d %d/%d/%d %d/%d/%d ] [ %d/%d/%d %d/%d/%d %d/%d/%d %d/%d/%d ]",
linux/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8192e2ant.c:203:			"[BTCoex], BT is from %s to %s!!\n",
linux/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8723b1ant.c:1694:			"[BTCoex], BT is from %s to %s!!\n",
linux/drivers/net/wireless/realtek/rtlwifi/rtl8192cu/hw.c:406:	rtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, "Boot from %s\n",
linux/drivers/net/wireless/realtek/rtlwifi/rtl8723ae/hal_btc.c:1604:			DBG_TRACE, "8723A BT is from %s to %s!!\n",
linux/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/hw.c:1214:		"Initialize MacId media status: from %d to %d\n",
linux/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c:1823:	dev_dbg(dev, "Booting from %s\n",
linux/drivers/net/wireless/realtek/rtw88/main.c:2340:	rtw_dbg(rtwdev, RTW_DBG_STATE, "AP port switch from %d -> %d\n",
linux/drivers/net/wireless/realtek/rtw89/coex.c:5589:	/* raw val is dBm unit, translate from -100~ 0dBm to 0~100%*/
linux/drivers/net/bareudp.c:159:				net_info_ratelimited("non-ECT from %pI4 "
linux/drivers/net/bareudp.c:164:				net_info_ratelimited("non-ECT from %pI6\n",
linux/drivers/net/wireguard/receive.c:105:		net_dbg_skb_ratelimited("%s: Receiving cookie response from %pISpfsc\n",
linux/drivers/net/wireguard/receive.c:129:		net_dbg_skb_ratelimited("%s: Invalid MAC of handshake, dropping packet from %pISpfsc\n",
linux/drivers/net/wireguard/receive.c:146:			net_dbg_skb_ratelimited("%s: Invalid handshake initiation from %pISpfsc\n",
linux/drivers/net/wireguard/receive.c:168:			net_dbg_skb_ratelimited("%s: Invalid handshake response from %pISpfsc\n",
linux/drivers/net/wireguard/receive.c:563:			net_dbg_skb_ratelimited("%s: Dropping handshake packet from %pISpfsc\n",
linux/drivers/net/bonding/bond_main.c:1886:			slave_dbg(bond_dev, slave_dev, "change device type from %d to %d\n",
linux/drivers/net/bonding/bond_alb.c:1113: * address and from @bond's address, then somewhere in the bond there's
linux/drivers/net/bonding/bond_options.c:566: * This function tries to extract the value from @val and check if it's
linux/drivers/net/dsa/ocelot/felix.c:631:	from = old_proto_ops->get_host_fwd_mask(ds);
linux/drivers/net/dsa/sja1105/sja1105_spi.c:30: *		address reg_addr, taking @len bytes from *buf
linux/drivers/net/dsa/sja1105/sja1105_main.c:549:	for (from = 0; from < ds->num_ports; from++) {
linux/drivers/net/dsa/sja1105/sja1105_main.c:569:	for (from = 0; from < ds->num_ports; from++) {
linux/drivers/net/dsa/sja1105/sja1105_main.c:577:			if (from == to)
linux/drivers/net/dsa/sja1105/sja1105_main.c:601:		from = dl->dp->index;
linux/drivers/net/dsa/sja1105/sja1105_main.c:1971:	for (from = 0; from < ds->num_ports; from++) {
linux/drivers/net/dsa/sja1105/sja1105_vl.c:193: *     |    \            /   VLID taken from      VLID taken from
linux/drivers/net/dsa/qca/qca8k-common.c:915:	dev_err(priv->dev, "Failed to del mirror port from %d", port);
linux/drivers/net/dsa/b53/b53_priv.h:138:	/* Master MDIO bus we got probed from */
linux/drivers/net/fddi/skfp/pmf.c:551:	char		*from ;
linux/drivers/net/fddi/skfp/pmf.c:884:	from = mib_addr + pt->p_offset ;
linux/drivers/net/fddi/skfp/pmf.c:991:			from += 8 ;
linux/drivers/net/fddi/skfp/pmf.c:999:			from += 8 ;
linux/drivers/net/fddi/skfp/pmf.c:1007:			from += 32 ;
linux/drivers/net/fddi/skfp/pmf.c:1074:	char		*from ;
linux/drivers/net/fddi/skfp/pmf.c:1094:	from = (char *) (pa + 1 ) ;
linux/drivers/net/fddi/skfp/pmf.c:1108:		from += 4 ;		/* skip index */
linux/drivers/net/fddi/skfp/pmf.c:1117:		from += 4 ;		/* skip index */
linux/drivers/net/fddi/skfp/pmf.c:1126:		from += 4 ;		/* skip index */
linux/drivers/net/fddi/skfp/pmf.c:1197:			from += 4 ;
linux/drivers/net/fddi/skfp/pmf.c:1210:			from += 4 ;
linux/drivers/net/fddi/skfp/pmf.c:1239:			from += 8 ;
linux/drivers/net/fddi/skfp/pmf.c:1248:			from += 4 ;
linux/drivers/net/fddi/skfp/pmf.c:1257:			from += 8 ;
linux/drivers/net/fddi/skfp/pmf.c:1266:			from += 32 ;
linux/drivers/net/fddi/skfp/pcmplc.c:638:		DB_SNMP ("PCM from %d to %d\n", oldstate, mib->fddiPORTPCMState);
linux/drivers/net/fddi/skfp/ess.c:310:		DB_ESSN(2, "ESS: Change Request from %pM",
linux/drivers/net/fddi/skfp/ess.c:341:		DB_ESSN(2, "ESS: Report Request from %pM",
linux/drivers/net/fddi/skfp/smt.c:519:		DB_SMT("SMT : ignoring NSA with A-indicator set from %pM",
linux/drivers/net/fddi/skfp/smt.c:620:			DB_SMT("SMT : received NIF response from %pM",
linux/drivers/net/fddi/skfp/smt.c:681:		DB_SMT("SMT : replying to SIF Config request from %pM",
linux/drivers/net/fddi/skfp/smt.c:688:		DB_SMT("SMT : replying to SIF Operation request from %pM",
linux/drivers/net/fddi/skfp/smt.c:696:			DB_SMT("SMT: received ECF reply from %pM",
linux/drivers/net/vxlan/vxlan_core.c:1398:				    "%pM migrated from %pIS to %pIS\n",
linux/drivers/net/vxlan/vxlan_core.c:1604:			net_info_ratelimited("non-ECT from %pI4 with TOS=%#x\n",
linux/drivers/net/vxlan/vxlan_core.c:1608:			net_info_ratelimited("non-ECT from %pI6\n",
linux/drivers/watchdog/advantech_ec_wdt.c:52:		 "Default Watchdog timer setting (" __MODULE_STRING(DEFAULT_TIME) "s). The range is from " __MODULE_STRING(MIN_TIME) " to " __MODULE_STRING(MAX_TIME) ".");
linux/drivers/watchdog/ie6xx_wdt.c:296:		  "is out of range from %d to %d (dec)\n",
linux/drivers/watchdog/Kconfig:2120:	  The PC watchdog cards can be ordered from <http://www.berkprod.com/>.
linux/drivers/pcmcia/i82365.c:82:/* Bit map or list of interrupts to choose from */
linux/drivers/pcmcia/yenta_socket.c:1139:			 "Raising subordinate bus# of parent bus (#%02x) from #%02x to #%02x\n",
linux/drivers/pcmcia/tcic.c:71:/* Bit map of interrupts to choose from */
linux/drivers/platform/surface/aggregator/ssh_packet_layer.c:1270:	 * has not been updated from "transmitting" to "transmitted" yet.
linux/drivers/platform/goldfish/goldfish_pipe_qemu.h:30:	/* pipe can now be read from */
linux/drivers/platform/chrome/wilco_ec/Kconfig:31:	  userspace daemon from /dev/wilco_event using read() and poll().
linux/drivers/platform/chrome/wilco_ec/event.c:283:		dev_err(&adev->dev, "Nothing returned from %s()\n",
linux/drivers/platform/chrome/wilco_ec/event.c:288:		dev_err(&adev->dev, "Invalid object returned from %s()\n",
linux/drivers/platform/chrome/wilco_ec/event.c:294:		dev_err(&adev->dev, "Invalid buffer length %d from %s()\n",
linux/drivers/platform/x86/apple-gmux.c:489:	pr_debug("Switching DDC from %d to %d\n", old_ddc_owner, id);
linux/drivers/platform/x86/think-lmi.c:929:	/* validate and split from `item,value` -> `value` */
linux/drivers/platform/x86/dell/Kconfig:122:	If you have a Dell computer from >2007 you should say Y here.
linux/drivers/platform/x86/dell/Kconfig:135:	If you have a Dell computer from <=2017 you should say Y here.
linux/drivers/platform/mellanox/mlxreg-io.c:95:		 * bit size is 8 or 16. Compose such attributes from 'regnum'
linux/drivers/hwtracing/coresight/coresight-tmc-etr.c:348: * by the device from @offset upto a @size bytes.
linux/drivers/hwtracing/coresight/coresight-tmc-etr.c:1084: * limited by etr_buf->len) from @pos, with a maximum limit of @len,
linux/drivers/hwtracing/coresight/coresight-tmc-etf.c:156: * Return the available trace data in the buffer from @pos, with
linux/drivers/hwtracing/coresight/coresight-etb10.c:526:	/* finally tell HW where we want to start reading from */
linux/drivers/hwtracing/coresight/coresight-cti.h:57: * - pick up actual number used from .dts parameters if present.
linux/drivers/hwtracing/coresight/coresight-sysfs.c:190: * from @orig device to @target device. See coresight_make_links() for more
linux/drivers/hwtracing/coresight/coresight-etm3x-core.c:112: * @offset: address of a register, starting from @addr.
linux/drivers/accel/habanalabs/include/common/cpucp_if.h:1389: * from "pkt_subidx" field in struct cpucp_packet.
linux/drivers/bus/mhi/host/pm.c:196:		dev_err(dev, "Error moving to state %s from %s\n",
linux/drivers/bus/mhi/host/pm.c:689:			dev_err(dev, "Error moving to state %s from %s\n",
linux/drivers/bus/mhi/ep/sm.c:35:		dev_err(dev, "MHI state change to %s from %s is not allowed!\n",
linux/drivers/sbus/char/envctrl.c:533:/* Function Description: Read a byte from /dev/envctrl. Mapped to user read().
linux/drivers/accessibility/speakup/main.c:824:	while (from < to) {
linux/drivers/accessibility/speakup/main.c:826:		from += 2;
linux/drivers/accessibility/speakup/main.c:851:	start += from * 2;
linux/drivers/accessibility/speakup/main.c:936:	if (from > 0)
linux/drivers/accessibility/speakup/main.c:937:		start += from * vc->vc_size_row;
linux/drivers/accessibility/speakup/main.c:941:	for (from = start; from < end; from = to) {
linux/drivers/accessibility/speakup/main.c:942:		to = from + vc->vc_size_row;
linux/drivers/accessibility/speakup/main.c:963:		from = start + (win_left * 2);
linux/drivers/ipack/devices/ipoctal.c:226:	 * to read from */
linux/drivers/iommu/arm/arm-smmu/arm-smmu.c:358: * no-op and call arm_smmu_tlb_inv_context_s2() from .iotlb_sync as you might
linux/drivers/iommu/iova.c:829: * Caller wants to allocate a new IOVA range from 'rcache'.  If we can
linux/drivers/clocksource/bcm_kona_timer.c:71:	 *      start from #1
linux/drivers/clocksource/arc_timer.c:8: * programmed to go from @count to @limit and optionally interrupt.
linux/drivers/clocksource/timer-digicolor.c:18: * Conexant Digicolor SoCs have 8 configurable timers, named from "Timer A" to
linux/drivers/clocksource/ingenic-ost.c:25: * The TCU_REG_OST_CNT{L,R} from <linux/mfd/ingenic-tcu.h> are only for the
linux/drivers/xen/xen-pciback/pci_stub.c:108:	 * is called from "unbind" which takes a device_lock mutex.
linux/drivers/xen/xen-acpi-processor.c:42:/* Which ACPI ID we have processed from 'struct acpi_processor'. */
linux/drivers/xen/grant-table.c:234:	for (from = find_first_bit(gnttab_free_bitmap, gnttab_size);
linux/drivers/xen/grant-table.c:235:	     from < gnttab_size;
linux/drivers/xen/grant-table.c:236:	     from = find_next_bit(gnttab_free_bitmap, gnttab_size, to + 1)) {
linux/drivers/xen/grant-table.c:238:					from + 1);
linux/drivers/xen/grant-table.c:239:		if (ret < 0 && to - from >= count) {
linux/drivers/xen/grant-table.c:242:			from += count;
linux/drivers/xen/grant-table.c:244:			if (from == to)
linux/drivers/xen/grant-table.c:253:		while (from < to) {
linux/drivers/xen/xen-scsiback.c:78:	struct ids_tuple v;		/* translate from */
linux/drivers/xen/gntdev.c:345:		 * dev_bus_addr output field gets consumed only from ->map_ops,
linux/drivers/xen/xenbus/xenbus_probe.c:155:				 "reading other end details from %s",
linux/drivers/xen/xenbus/xenbus_probe.c:162:				 "unable to read other end from %s.  "
linux/drivers/sh/intc/virq.c:233:		pr_info("Setting up a chained VIRQ from %d -> %d\n",
linux/drivers/sh/maple/maple.c:254:	from = port << 6;
linux/drivers/sh/maple/maple.c:263:	    mq->command | (to << 8) | (from << 16) | (len << 24);
linux/drivers/vhost/vringh.c:1285:		void *from = kaddr + ivec.iov.bvec[0].bv_offset;
linux/drivers/vhost/vhost.c:946:		__typeof__(ptr) from = \
linux/drivers/vhost/vhost.c:950:		if (from != NULL) \
linux/drivers/vhost/vhost.c:2211:			vq_err(vq, "Guest moved used index from %u to %u",
linux/drivers/macintosh/therm_adt746x.c:530:	printk(KERN_INFO "adt746x: Lowering max temperatures from %d, %d, %d"
linux/drivers/macintosh/therm_adt746x.c:576:	printk(KERN_INFO "adt746x: Putting max temperatures back from "
linux/drivers/macintosh/windfarm_pm121.c:492:					 "corrected from %d to %d RPM\n",
linux/drivers/cdrom/gdrom.c:672:	pr_info("%s from %s with firmware %s\n",
linux/drivers/cdrom/cdrom.c:58:  of bytes not copied.  I was returning whatever non-zero stuff came back from 
linux/drivers/cdrom/cdrom.c:3104:	cgc->cmd[2] = (blk.from >> 24) & 0xff;
linux/drivers/cdrom/cdrom.c:3105:	cgc->cmd[3] = (blk.from >> 16) & 0xff;
linux/drivers/cdrom/cdrom.c:3106:	cgc->cmd[4] = (blk.from >>  8) & 0xff;
linux/drivers/cdrom/cdrom.c:3107:	cgc->cmd[5] = blk.from & 0xff;
linux/drivers/soc/ti/smartreflex.c:345:		pr_warn("%s: NULL omap_sr from %pS\n",
linux/drivers/soc/ti/smartreflex.c:412:		pr_warn("%s: NULL omap_sr from %pS\n",
linux/drivers/soc/ti/smartreflex.c:467:		pr_warn("%s: NULL omap_sr from %pS\n",
linux/drivers/soc/ti/smartreflex.c:552:		pr_warn("%s: NULL omap_sr from %pS\n",
linux/drivers/soc/ti/smartreflex.c:608:		pr_warn("%s: NULL omap_sr from %pS\n",
linux/drivers/soc/apple/rtkit-crashlog.c:162:	dev_warn(rtk->dev, "  == Exception taken from %s ==", el);
linux/drivers/soc/qcom/cmd-db.c:28: * @offset: offset from :@data_offset, start of the data
linux/drivers/soc/qcom/ice.c:306:		dev_err(dev, "Cannot get ice instance from %s\n",
linux/drivers/soc/qcom/pdr_interface.c:326:	pr_info("PDR: Indication received from %s, state: 0x%x, trans-id: %d\n",
linux/drivers/bcma/driver_mips.c:233:	/* Determine flash type this SoC boots from */
linux/drivers/bcma/driver_pci_host.c:602:		pr_info("change PCIe max read request size from %i to 128\n", readrq);
linux/drivers/android/binder.c:1416:	BUG_ON(target_thread->transaction_stack->from != target_thread);
linux/drivers/android/binder.c:1419:	t->from = NULL;
linux/drivers/android/binder.c:1491:	from = t->from;
linux/drivers/android/binder.c:1515:	from = binder_get_txn_from(t);
linux/drivers/android/binder.c:1522:		BUG_ON(from != t->from);
linux/drivers/android/binder.c:1559:	from_proc = t->from ? t->from->proc->pid : 0;
linux/drivers/android/binder.c:1560:	from_thread = t->from ? t->from->pid : 0;
linux/drivers/android/binder.c:1747: * @object_offsetp: offset of @object read from @b
linux/drivers/android/binder.c:1757: *		from @start were previously verified to have valid offsets.
linux/drivers/android/binder.c:2365: * Processes all elements of @sgc_head, applying fixups from @pf_head
linux/drivers/android/binder.c:2880:	struct binder_thread *from = binder_get_txn_from_and_acq_inner(t);
linux/drivers/android/binder.c:3119:				from = tmp->from;
linux/drivers/android/binder.c:3120:				if (from && from->proc == target_proc) {
linux/drivers/android/binder.c:3183:		t->from = thread;
linux/drivers/android/binder.c:3185:		t->from = NULL;
linux/drivers/android/binder.c:4977:		} else if (t->from == thread) {
linux/drivers/android/binder.c:4978:			t->from = NULL;
linux/drivers/android/binder.c:5951:		   "%s %d: %pK from %d:%d to %d:%d code %x flags %x pri %ld r%d",
linux/drivers/android/binder.c:5953:		   t->from ? t->from->proc->pid : 0,
linux/drivers/android/binder.c:5954:		   t->from ? t->from->pid : 0,
linux/drivers/android/binder.c:6042:		if (t->from == thread) {
linux/drivers/android/binder.c:6430:		   "%d: %s from %d:%d to %d:%d context %s node %d handle %d size %d:%d ret %d/%d l=%d",
linux/drivers/android/binder_alloc.c:1222:		from += size;
linux/drivers/android/binder_trace.h:121:	TP_printk("transaction=%d from %d:%d to %d:%d flags=0x%x code=0x%x",
linux/drivers/mailbox/platform_mhu.c:5: * Synchronised with arm_mhu.c from :
linux/drivers/spi/spi-intel.c:21:/* Offsets are from @ispi->base */
linux/drivers/spi/spi-intel.c:60:/* Offset is from @ispi->pregs */
linux/drivers/spi/spi-intel.c:68:/* Offsets are from @ispi->sregs */
linux/drivers/spi/spi-pl022.c:2168:	dev_info(&adev->dev, "mapped registers from %pa to %p\n",
linux/drivers/spi/spi-cadence-quadspi.c:1339:	loff_t from = op->addr.val;
linux/drivers/spi/spi-cadence-quadspi.c:1351:	if (cqspi->use_direct_mode && ((from + len) <= cqspi->ahb_size))
linux/drivers/spi/spi-ti-qspi.c:611:	u32 from = 0;
linux/drivers/spi/spi-ti-qspi.c:620:	from = op->addr.val;
linux/drivers/spi/spi-ti-qspi.c:621:	if (from + op->data.nbytes > qspi->mmap_size)
linux/drivers/spi/spi-hisi-sfc-v3xx.c:204:	from = host->regbase + HISI_SFC_V3XX_CMD_DATABUF0;
linux/drivers/spi/spi-hisi-sfc-v3xx.c:216:			from += words * 4;
linux/drivers/spi/spi-hisi-sfc-v3xx.c:224:		for (i = 0; i < DIV_ROUND_UP(len, 4); i++, from += 4) {
linux/drivers/spi/spi-hisi-sfc-v3xx.c:253:			from += words * 4;
linux/drivers/spi/spi-hisi-sfc-v3xx.c:256:				val |= *from << i * 8;
linux/drivers/spi/spi-hisi-sfc-v3xx.c:267:				val |= *from << j * 8;
linux/drivers/spi/spi-armada-3700.c:351:	 * from '0' to '1'. So when we start waiting for a interrupt, we
linux/drivers/spi/spi-bcm-qspi.c:1039:	u32 addr = 0, len, rdlen, len_words, from = 0;
linux/drivers/spi/spi-bcm-qspi.c:1048:	from = op->addr.val;
linux/drivers/spi/spi-bcm-qspi.c:1058:		addr = from & 0xff000000;
linux/drivers/spi/spi-bcm-qspi.c:1066:		addr = from & 0x00ffffff;
linux/drivers/spi/atmel-quadspi.c:233:	dev_vdbg(&aq->pdev->dev, "read 0x%08x from %s\n", value,
linux/drivers/spi/spi-dw-bt1.c:83:	shift = (size_t)from & 0x3;
linux/drivers/spi/spi-dw-bt1.c:86:		data = readl_relaxed(from - shift);
linux/drivers/spi/spi-dw-bt1.c:88:		from += chunk;
linux/drivers/spi/spi-dw-bt1.c:96:		from += 4;
linux/mm/readahead.c:414: * Count contiguously cached pages from @index-1 to @index-@max,
linux/mm/hugetlb.c:414:	nrg->from = from;
linux/mm/hugetlb.c:491:	if (&prg->link != &resv->regions && prg->to == rg->from &&
linux/mm/hugetlb.c:503:	if (&nrg->link != &resv->regions && nrg->from == rg->to &&
linux/mm/hugetlb.c:505:		nrg->from = rg->from;
linux/mm/hugetlb.c:558:		if (iter->from < f) {
linux/mm/hugetlb.c:570:		if (iter->from >= t) {
linux/mm/hugetlb.c:578:		if (iter->from > last_accounted_offset)
linux/mm/hugetlb.c:812:		 * (from, to) with from == to.  Check for placeholder entries
linux/mm/hugetlb.c:815:		if (rg->to <= f && (rg->to != rg->from || rg->to != f))
linux/mm/hugetlb.c:818:		if (rg->from >= t)
linux/mm/hugetlb.c:821:		if (f > rg->from && t < rg->to) { /* Must split region */
linux/mm/hugetlb.c:848:			nrg->from = t;
linux/mm/hugetlb.c:863:		if (f <= rg->from && t >= rg->to) { /* Remove entire region */
linux/mm/hugetlb.c:877:			rg->from = t;
linux/mm/hugetlb.c:939:		if (rg->from >= t)
linux/mm/hugetlb.c:6858:	if (from > to) {
linux/mm/page-writeback.c:2333: * This function scans the page range from @start to @end (inclusive) and tags
linux/mm/page-writeback.c:2366: * @wbc: subtract the number of written pages from *@wbc->nr_to_write
linux/mm/zsmalloc.c:842: * location_to_obj - get obj value encoded from (<page>, <obj_idx>)
linux/mm/percpu-vm.c:304: * from @chunk.
linux/mm/kmsan/kmsan.h:85: * @off_first: Offset (from @address) of the first byte to be reported.
linux/mm/kmsan/kmsan.h:86: * @off_last:  Offset (from @address) of the last byte to be reported.
linux/mm/kmsan/init.c:207:	 *    - pop 3 ranges from @collect;
linux/mm/kmsan/init.c:210:	 *  - split each remaining element from @collect into 2 ranges of
linux/mm/khugepaged.c:2722:			pr_info("raising min_free_kbytes from %d to %lu to help transparent hugepage allocations\n",
linux/mm/memory_hotplug.c:200:	 * Make sure value parsed from 'mem=' only restricts memory adding
linux/mm/memory_hotplug.c:1767:	 * We have accounted the pages from [0..ZONE_NORMAL); ZONE_HIGHMEM
linux/mm/cma.c:237: * reserve in range from @base to @limit.
linux/mm/memblock.c:460:		pr_err("memblock: Failed to double %s array from %ld to %ld entries !\n",
linux/mm/memblock.c:503: * @start_rgn: start scanning from (@start_rgn - 1)
linux/mm/memblock.c:1040: * Find the first area from *@idx which matches @nid, fill the out
linux/mm/slab_common.c:498:	     "%s %s: Slab cache still has objects when called from %pS",
linux/mm/memory-failure.c:1823: * constructing singly linked list from ->_hugetlb_hwpoison field of folio.
linux/mm/memory.c:149:	 * Transitioning a PTE from 'old' to 'young' can be expensive on
linux/mm/memory.c:2172: * pgprot typically only differs from @vma->vm_page_prot when drivers set
linux/mm/shmem.c:2602:			size_t from = offset_in_folio(folio, pos);
linux/mm/shmem.c:2604:					from + copied, folio_size(folio));
linux/mm/shmem.c:3052:	dput(dentry);	/* Undo the count from "create" - this does all the work */
linux/mm/vmscan.c:147:	/* The highest zone to isolate folios for reclaim from */
linux/mm/vmscan.c:1667:		 * Allocate from 'node', or fail quickly and quietly.
linux/mm/truncate.c:801:	if (from >= to || bsize == PAGE_SIZE)
linux/mm/truncate.c:808:	index = from >> PAGE_SHIFT;
linux/mm/mlock.c:361: * called for munlock() and munlockall(), to clear VM_LOCKED from @vma.
linux/mm/page_alloc.c:379:/* movable_zone is the "real" zone pages in ZONE_MOVABLE are taken from */
linux/mm/page_alloc.c:6209:		 * 'direct_map_addr' might be different from 'pos'
linux/mm/page_alloc.c:6823:	 * Pages from [start, end) are within a pageblock_nr_pages
linux/mm/memory-tiers.c:290: * from @node; NUMA_NO_NODE if @node is terminal.  This does not keep
linux/mm/nommu.c:501:	for (; from < to; from += PAGE_SIZE) {
linux/mm/nommu.c:1392:	if (from > vma->vm_start) {
linux/mm/nommu.c:1406:	if (from > region->vm_start) {
linux/mm/mmap.c:668: * expand over @next if it's different from @vma and @end == @next->vm_end.
linux/mm/mmap.c:1084: * from 'old'. The 'a'/'b' vma's are in VM order - one of them will be
linux/mm/mmap.c:1541: * the correct alignment and offset, all from @info. Note: current->mm is used
linux/mm/mmap.c:1594: * address, all from @info. Note: current->mm is used for the search.
linux/mm/mmap.c:2322: * do_vmi_align_munmap() - munmap the aligned region from @start to @end.
linux/mm/Kconfig:1138:	  names can be later retrieved from /proc/pid/maps and /proc/pid/smaps
linux/mm/filemap.c:2093: * find_lock_entries() will return a batch of entries from @mapping.
linux/mm/filemap.c:3839:	 * without clobbering -EIOCBQUEUED from ->direct_IO().
linux/mm/mmu_gather.c:333: * tear-down from @mm.
linux/mm/mmu_gather.c:349: * tear-down from @mm.
linux/mm/rmap.c:171: * can re-use the anon_vma from (very common when the only
linux/mm/util.c:92: * @max: read at most @max chars from @s
linux/mm/memcontrol.c:545:		goto done;		/* Nothing to reclaim from */
linux/mm/memcontrol.c:1477:	from = mc.from;
linux/mm/memcontrol.c:5779: * @to:	mem_cgroup which the page is moved to. @from != @to.
linux/mm/memcontrol.c:5797:	VM_BUG_ON(from == to);
linux/mm/memcontrol.c:6102:	struct mem_cgroup *from = mc.from;
linux/mm/memcontrol.c:6151:	mc.from = NULL;
linux/mm/memcontrol.c:6197:	from = mem_cgroup_from_task(p);
linux/mm/memcontrol.c:6199:	VM_BUG_ON(from == memcg);
linux/mm/memcontrol.c:6214:		mc.from = from;
linux/mm/hugetlb_vmemmap.c:276:	struct page *from = start + NR_RESET_STRUCT_PAGE;
linux/mm/swap.c:1072: * entries.  This function prunes all the non-folio entries from @fbatch
linux/mm/slab.h:623:		  "%s: Wrong slab cache. %s but object is from %s\n",
linux/mm/vmstat.c:1891:	 * which can equally be echo'ed to or cat'ted from (by root),
linux/mm/ksm.c:681:	 * from &migrate_nodes. This will verify that future list.h changes
linux/mm/percpu.c:1540: * Pages in [@page_start,@page_end) have been depopulated from @chunk.
linux/mm/internal.h:466:	unsigned long fast_start_pfn;	/* a pfn to start linear scan from */
linux/mm/vmalloc.c:2842: * Maps @count pages from @pages into contiguous kernel virtual space.
linux/mm/vmalloc.c:2915: * Maps @count PFNs from @pfns into contiguous kernel virtual space and returns
linux/mm/vmalloc.c:3777: * @pgoff:		offset from @kaddr to start at
linux/net/caif/cfpkt_skbuff.c:137:	from = skb_pull(skb, len);
linux/net/caif/cfpkt_skbuff.c:138:	from -= len;
linux/net/caif/cfpkt_skbuff.c:161:	from = skb_tail_pointer(skb) - len;
linux/net/mac80211/ieee80211_i.h:2181: *	flags from &enum ieee80211_conn_flags.
linux/net/mac80211/ht.c:512:	ht_dbg_ratelimited(sdata, "delba from %pM (%s) tid %d reason code %d\n",
linux/net/mac80211/tdls.c:1765:		 "TDLS channel switch response received from %pM status %d\n",
linux/net/mac80211/tdls.c:1926:		 "TDLS ch switch request received from %pM ch %d width %d\n",
linux/net/mac80211/mlme.c:3837:		sdata_info(sdata, "deauthenticated from %pM (Reason: %u=%s)\n",
linux/net/mac80211/mlme.c:3851:			   "deauthenticated from %pM while associating (Reason: %u=%s)\n",
linux/net/mac80211/mlme.c:3885:	sdata_info(sdata, "disassociated from %pM (Reason: %u=%s)\n",
linux/net/mac80211/mlme.c:5231:		   "RX %sssocResp from %pM (capab=0x%x status=%d aid=%d)\n",
linux/net/mac80211/mlme.c:7425:			sdata_info(sdata, "waiting for beacon from %pM\n",
linux/net/mac80211/mlme.c:7499:			   "deauthenticating from %pM by local choice (Reason: %u=%s)\n",
linux/net/mac80211/mlme.c:7525:		   "disassociating from %pM by local choice (Reason: %u=%s)\n",
linux/net/mac80211/mesh_hwmp.c:147:		mhwmp_dbg(sdata, "sending RANN from %pM\n", orig_addr);
linux/net/mac80211/mesh_hwmp.c:597:	mhwmp_dbg(sdata, "received PREQ from %pM\n", orig_addr);
linux/net/mac80211/mesh_hwmp.c:676:		mhwmp_dbg(sdata, "forwarding the PREQ from %pM\n", orig_addr);
linux/net/mac80211/mesh_hwmp.c:720:	mhwmp_dbg(sdata, "received PREP from %pM\n",
linux/net/mac80211/mesh_hwmp.c:851:		  "received RANN from %pM via neighbour %pM (is_gate=%d)\n",
linux/net/mac80211/sta_info.c:1977:		 * on the TIDs we're releasing from - if there are more than
linux/net/mac80211/ibss.c:1556:		ibss_dbg(sdata, "Invalid SSID IE in ProbeReq from %pM\n",
linux/net/mac80211/vht.c:290:			   "Ignoring VHT IE from %pM (link:%pM) due to invalid rx_mcs_map\n",
linux/net/mac80211/vht.c:655:			pr_warn_ratelimited("Ignoring NSS change in VHT Operating Mode Notification from %pM with invalid nss %d",
linux/net/mac80211/agg-rx.c:312:				   "AddBA Req with bad params from %pM on tid %u. policy %d, buffer size %d\n",
linux/net/mac80211/agg-rx.c:336:					   "updated AddBA Req from %pM on tid %u\n",
linux/net/mac80211/agg-rx.c:354:				   "unexpected AddBA Req from %pM on tid %u\n",
linux/net/mac80211/fils_aead.c:289:			 "No (valid) FILS Session element in (Re)Association Response frame from %pM",
linux/net/mac80211/fils_aead.c:319:			 "Not enough room for AES-SIV data after FILS Session element in (Re)Association Response frame from %pM",
linux/net/mac80211/fils_aead.c:327:			 "AES-SIV decryption of (Re)Association Response frame from %pM failed",
linux/net/batman-adv/hard-interface.c:428:	/* 1 neighbor, is the one we received from -> no rebroadcast */
linux/net/batman-adv/network-coding.c:915:	/* accept ogms from 'good' neighbors and single hop neighbors */
linux/net/batman-adv/tp_meter.c:1119:		   "Shutting down for inactivity (more than %dms) from %pM\n",
linux/net/batman-adv/tp_meter.c:1407:				   "Unexpected packet from %pM!\n",
linux/net/batman-adv/translation-table.c:1470: *  from @orig_node
linux/net/batman-adv/translation-table.c:3012:		   "Received TT_REQUEST from %pM for ttvn: %u (%pM) [%c]\n",
linux/net/batman-adv/translation-table.c:3083:					 "Ignoring TT_REQUEST from %pM; Response size exceeds max packet size.\n",
linux/net/batman-adv/translation-table.c:3141:		   "Received TT_REQUEST from %pM for ttvn: %u (me) [%c]\n",
linux/net/batman-adv/translation-table.c:3377:		   "Received TT_RESPONSE from %pM for ttvn %d t_size: %d [%c]\n",
linux/net/batman-adv/translation-table.c:4135:		   "Received ROAMING_ADV from %pM (client %pM)\n",
linux/net/batman-adv/multicast.c:519: * @src: source to read from - a multicast IP address
linux/net/batman-adv/multicast.c:819:		   "Changing multicast flags from '%s' to '[%c%c%c%s%s]'\n",
linux/net/batman-adv/routing.c:290:		pr_debug("Warning - can't forward icmp packet from %pM to %pM: ttl exceeded\n",
linux/net/batman-adv/routing.c:670:		pr_debug("Warning - can't forward unicast packet from %pM to %pM: ttl exceeded\n",
linux/net/batman-adv/bat_v_elp.c:528:		   "Received ELP packet from %pM seqno %u ORIG: %pM\n",
linux/net/batman-adv/send.c:564: * @lock: a key to the store to steal from (e.g. forw_{bat,bcast}_list_lock)
linux/net/batman-adv/bat_v_ogm.c:631:			   "Drop packet: packet within window protection time from %pM\n",
linux/net/batman-adv/bat_v_ogm.c:954:			batadv_dbg(BATADV_DBG_BATMAN, bat_priv, "OGM2 packet from %pM on %s suppressed: %s\n",
linux/net/batman-adv/gateway_client.c:419:		   "Gateway bandwidth of originator %pM changed from %u.%u/%u.%u MBit to %u.%u/%u.%u MBit\n",
linux/net/batman-adv/main.c:604:	from = (unsigned int)(payload_ptr - skb->data);
linux/net/qrtr/ns.c:753:			pr_err("failed while handling packet from %d:%d",
linux/net/sunrpc/addr.c:257: * rpc_sockaddr2uaddr - Construct a universal address string from @sap.
linux/net/sunrpc/xdr.c:1715: * Moves @length bytes from @offset to @target in the xdr_stream, overwriting
linux/net/sunrpc/stats.c:152: * @op_metrics: stat structure for OP that will accumulate stats from @task
linux/net/sunrpc/stats.c:198: * Uses the statidx from @task
linux/net/sunrpc/auth_gss/gss_krb5_wrap.c:121: * them with scratch pages from **pages before writing to them. */
linux/net/sunrpc/auth_gss/auth_gss.c:790:			printk(KERN_CRIT "%s: bad return from "
linux/net/sunrpc/svcsock.c:291: * Read from @rqstp's transport socket. The incoming message fills whole
linux/net/ax25/ax25_addr.c:176:	/* Copy to, from */
linux/net/rxrpc/af_rxrpc.c:677:			    rx->service_upgrade.from != 0)
linux/net/rxrpc/af_rxrpc.c:692:			rx->service_upgrade.from = service_upgrade[0];
linux/net/openvswitch/vport.c:118: * vport_priv().  Some parameters of the vport will be initialized from @parms.
linux/net/openvswitch/vport.c:512:	/* Extract flow from 'skb' into 'key'. */
linux/net/openvswitch/flow_netlink.c:1827:			 * copied from 'key' and set to 0xff.
linux/net/bluetooth/hidp/core.c:630:/* dequeue message from @transmit and send via @sock */
linux/net/bluetooth/l2cap_core.c:3074:		/* Don't send frame to the channel it came from */
linux/net/bluetooth/coredump.c:53:	bt_dev_dbg(hdev, "Updating devcoredump state from %d to %d.",
linux/net/bluetooth/hci_sock.c:218:		/* Don't send frame to the socket it came from */
linux/net/bluetooth/smp.c:3056:	bt_dev_err(hcon->hdev, "unexpected SMP command 0x%02x from %pMR",
linux/net/9p/protocol.c:601:				struct iov_iter *from =
linux/net/netlabel/netlabel_kapi.c:1042: * Remove all the NetLabel labeling from @sk.  The caller is responsible for
linux/net/netlabel/netlabel_kapi.c:1250:* Remove all the NetLabel labeling from @req.
linux/net/can/af_can.c:413: * @dev: pointer to netdevice (NULL => subscribe from 'all' CAN devices list)
linux/net/can/af_can.c:501: * @dev: pointer to netdevice (NULL => unsubscribe from 'all' CAN devices list)
linux/net/can/gw.c:322:	int from = calc_idx(xor->from_idx, cf->len);
linux/net/can/gw.c:328:	if (from < 0 || to < 0 || res < 0)
linux/net/can/gw.c:331:	if (from <= to) {
linux/net/can/gw.c:367:	int from = calc_idx(crc8->from_idx, cf->len);
linux/net/can/gw.c:373:	if (from < 0 || to < 0 || res < 0)
linux/net/can/gw.c:376:	if (from <= to) {
linux/net/ipv4/nexthop.c:2120:	 * tree. Therefore, inherit the flags from 'old' to 'new'.
linux/net/ipv4/ipconfig.c:1312:	pr_info("IP-Config: Got %s answer from %pI4, my address is %pI4\n",
linux/net/ipv4/af_inet.c:1271:		pr_info("%s(): shifting inet->saddr from %pI4 to %pI4\n",
linux/net/ipv4/icmp.c:8: *	module were derived from [icmp.c 1.0.11 06/02/93] by
linux/net/ipv4/fib_trie.c:269: * the bits from (tp->pos + tp->bits) to 31. They are *known* but at this
linux/net/ipv4/fib_trie.c:272: * The bits from (tp->pos) to (tp->pos + tp->bits - 1) - "N", above - are the
linux/net/ipv4/fib_trie.c:276: * The bits from (n->pos + n->bits) to (tp->pos - 1) - "S" - are skipped bits
linux/net/ipv4/fib_trie.c:282: * The bits from (n->pos) to (n->pos + n->bits - 1) - "C" - are the index into
linux/net/ipv4/fib_trie.c:591:		 * we are moving away from - the bit at position
linux/net/ipv4/ip_fragment.c:476:	net_info_ratelimited("Oversized IP packet from %pI4\n", &qp->q.key.v4.saddr);
linux/net/ipv4/ip_output.c:654:	state->ptr = hlen;		/* Where to start from */
linux/net/ipv4/udp_tunnel_nic.c:388:		from = UDP_TUNNEL_NIC_ENTRY_ADD;
linux/net/ipv4/udp_tunnel_nic.c:391:		from = UDP_TUNNEL_NIC_ENTRY_DEL;
linux/net/ipv4/tcp_input.c:6722:		net_dbg_ratelimited("drop open request from %pI4/%u\n",
linux/net/ipv4/tcp_input.c:6726:		net_dbg_ratelimited("drop open request from %pI6/%u\n",
linux/net/ipv4/igmp.c:48: *					from %p with timer not initialized\n"
linux/net/ipv4/netfilter/nf_nat_snmp_basic_main.c:136:		ctx.from = ct->tuplehash[dir].tuple.src.u3.ip;
linux/net/ipv4/netfilter/nf_nat_snmp_basic_main.c:139:		ctx.from = ct->tuplehash[!dir].tuple.src.u3.ip;
linux/net/ipv4/netfilter/nf_nat_snmp_basic_main.c:143:	if (ctx.from == ctx.to)
linux/net/ipv4/route.c:814:		net_info_ratelimited("Redirect from %pI4 on %s about %pI4 ignored\n"
linux/net/ipv4/route.c:1775:		pr_warn("martian source %pI4 from %pI4, on dev %s\n",
linux/net/ipv4/route.c:2416:		net_warn_ratelimited("martian destination %pI4 from %pI4, dev %s\n",
linux/net/ipv4/sysctl_net_ipv4.c:66:/* Validate changes from /proc interface. */
linux/net/ipv4/sysctl_net_ipv4.c:101:/* Validate changes from /proc interface. */
linux/net/ipv4/sysctl_net_ipv4.c:162:/* Validate changes from /proc interface. */
linux/net/ipv4/ip_tunnel.c:412:			net_info_ratelimited("non-ECT from %pI4 with TOS=%#x\n",
linux/net/wireless/lib80211_crypt_ccmp.c:276:		net_dbg_ratelimited("CCMP: received packet without ExtIV flag from %pM\n",
linux/net/wireless/lib80211_crypt_ccmp.c:288:		net_dbg_ratelimited("CCMP: received packet from %pM with keyid=%d that does not have a configured key\n",
linux/net/wireless/lib80211_crypt_tkip.c:391:		net_dbg_ratelimited("TKIP countermeasures: dropped received packet from %pM\n",
linux/net/wireless/lib80211_crypt_tkip.c:402:		net_dbg_ratelimited("TKIP: received packet without ExtIV flag from %pM\n",
linux/net/wireless/lib80211_crypt_tkip.c:413:		net_dbg_ratelimited("TKIP: received packet from %pM with keyid=%d that does not have a configured key\n",
linux/net/wireless/lib80211_crypt_tkip.c:601:		       "MSDU from %pM keyidx=%d\n",
linux/net/8021q/vlan_netlink.c:245:			m.from = i;
linux/net/8021q/vlan_netlink.c:265:				m.from = pm->priority;
linux/net/core/flow_dissector.c:929: * @net: associated network namespace, derived from @skb if NULL
linux/net/core/gro.c:754:			net_warn_ratelimited("%s: dropping impossible skb from %s\n",
linux/net/core/dev.c:1180:		netdev_info(dev, "renamed from %s%s\n", oldname,
linux/net/core/dev.c:2237:		 * they originated from - MvS (miquels@drinkel.ow.org)
linux/net/core/dev.c:7550:		pr_err("Adjacency does not exist for device %s from %s\n",
linux/net/core/dev.c:7571:	pr_debug("adjacency: dev_put for %s, because link removed from %s to %s\n",
linux/net/core/pktgen.c:68: * of if_list, from "add_device" as it invoked from userspace (via proc write).
linux/net/core/pktgen.c:89: * ia64 compilation fix from  Aron Griffis <aron@hp.com> 040604
linux/net/core/skbuff.c:3164:		from += copy;
linux/net/core/skbuff.c:3186:				memcpy(vaddr + p_off, from + copied, p_len);
linux/net/core/skbuff.c:3193:			from += copy;
linux/net/core/skbuff.c:3213:			from += copy;
linux/net/core/skbuff.c:3528: *	Copies up to `len` bytes from `from` to `to` by creating references
linux/net/core/skbuff.c:3914:	from = 0;
linux/net/core/skbuff.c:3956:	while ((todo > 0) && (from < skb_shinfo(skb)->nr_frags)) {
linux/net/core/skbuff.c:3997:	while (from < skb_shinfo(skb)->nr_frags)
linux/net/core/skbuff.c:4201:	return (ret <= to - from ? ret : UINT_MAX);
linux/net/core/gen_estimator.c:124: * will be read from &bstats and the estimated rate will be stored in
linux/net/core/filter.c:1921:		if (unlikely(from != 0))
linux/net/core/filter.c:1972:		if (unlikely(from != 0))
linux/net/core/filter.c:2664:		from = sg_virt(sge);
linux/net/core/filter.c:2780:		from = sg_virt(psge);
linux/net/core/filter.c:2786:			from += front;
linux/net/core/filter.c:2969:				from = sg_virt(sge);
linux/net/core/filter.c:2972:				memcpy(to + a, from + a + pop, b);
linux/net/core/filter.c:4691:			from = (const struct bpf_tunnel_key *) compat;
linux/net/mptcp/protocol.h:480:		remote_key_valid : 1,        /* received the peer key from */
linux/net/rds/ib_cm.c:744:			printk_ratelimited(KERN_NOTICE "RDS: Connection from %pI6c using incompatible protocol version %u.%u\n",
linux/net/rds/ib_cm.c:747:			printk_ratelimited(KERN_NOTICE "RDS: Connection from %pI4 using incompatible protocol version %u.%u\n",
linux/net/rds/tcp_connect.c:64:		 * TCP ports going from <smaller-ip>.<transient> to
linux/net/rds/bind.c:154:	rdsdebug("rs %p unbinding from %pI6c:%d\n",
linux/net/rds/recv.c:339:			rdsdebug("ignore ping with 0 sport from %pI6c\n",
linux/net/rds/recv.c:690:		rdsdebug("copying inc %p from %pI6c:%u to user\n", inc,
linux/net/rds/ib_recv.c:865:		       "from %pI6c didn't include a "
linux/net/rds/ib_recv.c:880:		       "from %pI6c has corrupted header - "
linux/net/socket.c:1028: *	sock_recvmsg - receive a message from @sock
linux/net/socket.c:1033: *	Receives @msg from @sock, passing through LSM. Returns the total number
linux/net/socket.c:1141:	*from = msg.msg_iter;
linux/net/packet/af_packet.c:2345:		pr_err_once("tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\n",
linux/net/ethtool/coalesce.c:348:	 * parameters come from user and which are echoed back from ->get).
linux/net/ethtool/netlink.c:81: * the structure pointed to by @req_info. Extack from @info is used for error
linux/net/ethtool/bitset.c:124: * Set bits in @dst bitmap which are set in @mask to values from @value, leave
linux/net/ethtool/netlink.h:30: * Return: total length of an attribute with null terminated string from @s
linux/net/ethtool/netlink.h:43: * Puts an attribute with null terminated string from @s into the message.
linux/net/tipc/link.c:2525:	u16 from = acked + 1;
linux/net/tipc/name_distr.c:305:		pr_warn_ratelimited("Failed to remove binding %u,%u from %u\n",
linux/net/tipc/trace.h:299:		__entry->from = f;
linux/net/ipv6/sit.c:714:				net_info_ratelimited("non-ECT from %pI4 with TOS=%#x\n",
linux/net/ipv6/exthdrs.c:354:	from = *(__be32 *)hdr;
linux/net/ipv6/ip6_tunnel.c:848:			net_info_ratelimited("non-ECT from %pI6 with DS=%#x\n",
linux/net/ipv6/ip6_fib.c:982:			from = xchg((__force struct fib6_info **)&pcpu_rt->from, NULL);
linux/net/ipv6/ip6_fib.c:1012:			.from = f6i,
linux/net/ipv6/ip6_output.c:759:	state->ptr = hlen;		/* Where to start from */
linux/net/ipv6/ip6_output.c:1114:		from = rt ? rcu_dereference(rt->from) : NULL;
linux/net/ipv6/mcast.c:1272:		net_warn_ratelimited("IPv6: MLD: clamping QRV from %u to %u!\n",
linux/net/ipv6/route.c:15: *		- select from (probably) reachable routers (i.e.
linux/net/ipv6/route.c:370:	from = xchg((__force struct fib6_info **)&rt->from, NULL);
linux/net/ipv6/route.c:402:	from = rcu_dereference(rt->from);
linux/net/ipv6/route.c:1110:/* Caller must already hold reference to @from */
linux/net/ipv6/route.c:1427:		from = xchg((__force struct fib6_info **)&pcpu_rt->from, NULL);
linux/net/ipv6/route.c:1456:	from = xchg((__force struct fib6_info **)&rt6_ex->rt6i->from, NULL);
linux/net/ipv6/route.c:1752:			if (!from ||
linux/net/ipv6/route.c:1756:		WARN_ON_ONCE(!from && bucket->depth);
linux/net/ipv6/route.c:1886:	from = rcu_dereference(rt->from);
linux/net/ipv6/route.c:1887:	if (!from || !(rt->rt6i_flags & RTF_CACHE))
linux/net/ipv6/route.c:1964:	from = rcu_dereference(rt->from);
linux/net/ipv6/route.c:1965:	if (!from || !(rt->rt6i_flags & RTF_CACHE))
linux/net/ipv6/route.c:2706:	if (!from || !fib6_get_cookie_safe(from, &rt_cookie) ||
linux/net/ipv6/route.c:2747:	from = rcu_dereference(rt->from);
linux/net/ipv6/route.c:2749:	if (from && (rt->rt6i_flags & RTF_PCPU ||
linux/net/ipv6/route.c:2796:			from = rcu_dereference(rt->from);
linux/net/ipv6/route.c:2813:		from = rcu_dereference(rt0->from);
linux/net/ipv6/route.c:6127:	from = rcu_dereference(rt->from);
linux/net/netfilter/ipvs/ip_vs_core.c:871:		IP_VS_DBG_BUF(1, "Forward ICMP: failed checksum from %s!\n",
linux/net/netfilter/ipvs/ip_vs_core.c:1723:		IP_VS_DBG(1, "Incoming ICMP: failed checksum from %pI4!\n",
linux/net/netfilter/ipvs/ip_vs_conn.c:183:		pr_err("%s(): request for already hashed, called from %pS\n",
linux/net/netfilter/ipvs/ip_vs_ftp.c:300:		from = cp->daddr;
linux/net/netfilter/ipvs/ip_vs_ftp.c:354:		from = n_cp->vaddr;
linux/net/netfilter/ipvs/ip_vs_ctl.c:351:		pr_err("%s(): request for already hashed, called from %pS\n",
linux/net/netfilter/ipvs/ip_vs_ctl.c:385:		pr_err("%s(): request for unhash flagged, called from %pS\n",
linux/net/netfilter/nf_nat_proto.c:288:	 * to be there.  That's where the magic '8' comes from */
linux/net/netfilter/ipset/ip_set_core.c:1360:	from = find_set_and_id(inst, nla_data(attr[IPSET_ATTR_SETNAME]),
linux/net/netfilter/ipset/ip_set_hash_netportnet.c:179:	if (from == 0 && to == UINT_MAX) {
linux/net/netfilter/ipset/pfxlen.c:178:		if ((from & ip_set_hostmask(i)) != from)
linux/net/netfilter/ipset/pfxlen.c:180:		last = from | ~ip_set_hostmask(i);
linux/net/netfilter/ipset/ip_set_hash_gen.h:669:	pr_debug("attempt to resize set %s from %u to %u, t %p\n",
linux/net/netfilter/ipset/ip_set_hash_gen.h:753:	pr_debug("set %s resized from %u (%p) to %u (%p)\n", set->name,
linux/net/netfilter/nf_conntrack_seqadj.c:191:	pr_debug("Adjusting sequence number from %u->%u\n",
linux/net/netfilter/nf_conntrack_seqadj.c:207:	pr_debug("Adjusting ack number from %u->%u, ack from %u->%u\n",
linux/net/netfilter/nf_conntrack_irc.c:222:				net_warn_ratelimited("Forged DCC command from %pI4: %pI4:%u\n",
linux/net/netfilter/x_tables.c:507:		pr_info_ratelimited("%s_tables: %s match: used from hooks %s, but only valid from %s\n",
linux/net/netfilter/x_tables.c:1022:		pr_info_ratelimited("%s_tables: %s target: used from hooks %s, but only usable from %s\n",
linux/net/netfilter/x_tables.c:1056: * Copies counter meta data from @user and stores it in @info.
linux/net/netfilter/x_tables.c:1059: * from @user to the new memory and returns a pointer to it.
linux/net/netfilter/nf_nat_helper.c:49:			 "%u from %u bytes\n", rep_len - match_len, skb->len);
linux/net/netfilter/nf_nat_helper.c:52:		pr_debug("nf_nat_mangle_packet: Shrinking packet from "
linux/net/netfilter/nf_nat_helper.c:53:			 "%u from %u bytes\n", match_len - rep_len, skb->len);
linux/net/dsa/slave.c:1968:/* Make the hardware datapath to/from @dev limited to a common MTU */
linux/net/dsa/tag_brcm.c:164:	/* Locate which port this is coming from */
linux/net/atm/lec_arpc.h:20:	struct atm_vcc *recv_vcc;	/* Vcc we receive data from */
linux/net/l2tp/l2tp_debugfs.c:148:			seq_printf(m, " from %pI6c to %pI6c\n",
linux/net/l2tp/l2tp_debugfs.c:153:			seq_printf(m, " from %pI4 to %pI4\n",
linux/net/ceph/messenger.c:1348:	dout("===== %p %llu from %s%lld %d=%s len %d+%d+%d (%u %u %u) =====\n",
linux/net/ceph/osd_client.c:2552:		dout("updating epoch_barrier from %u to %u\n",
linux/net/ceph/osdmap.c:2625:			int from = pg->pg_upmap_items.from_to[i][0];
linux/net/ceph/osdmap.c:2639:				if (osd == from && pos < 0 &&
linux/net/ceph/auth.c:47:		pr_err("global_id changed from %llu to %llu\n", ac->global_id,
linux/net/ceph/pagevec.c:148:		dout("zeroing %d %p head from %d\n", i, pages[i],
linux/net/bridge/br_stp_bpdu.c:231:					  "port %u config from %pM"
linux/net/bridge/netfilter/ebtables.c:812:			if (cl_s[chain_nr].from != -1)
linux/net/bridge/netfilter/ebtables.c:853:			cl_s[i].from = chain_nr;
linux/net/llc/af_llc.c:940:	dprintk("%s: sending from %02X to %02X\n", __func__,
linux/net/llc/af_llc.c:1003:		dprintk("%s: failed sending from %02X to %02X: %d\n",
linux/net/sctp/sm_statefuns.c:493: * C) Upon reception of the INIT ACK from "Z", "A" shall stop the T1-init
linux/net/sched/sch_htb.c:692: * borrowing from "level". It accounts bytes to ceil leaky bucket for
linux/net/sched/sch_qfq.c:1208:		pr_debug("qfq: increasing maxpkt from %u to %u for class %u",
linux/net/sched/em_text.c:34:	from = tcf_get_base_ptr(skb, tm->from_layer) - skb->data;
linux/net/sched/em_text.c:35:	from += tm->from_offset;
linux/net/dccp/options.c:431:	from = av->av_buf + av->av_buf_head;
linux/net/dccp/options.c:450:		if (from + copylen > tail) {
linux/net/dccp/options.c:461:		from += copylen;
linux/net/dccp/ccids/ccid3.c:173: *	Update Window Counter using the algorithm from [RFC 4342, 8.1].
linux/net/dccp/ccids/ccid3.h:35:/* Parameter t_mbi from [RFC 3448, 4.3]: backoff interval in seconds */
linux/net/dccp/ccids/lib/loss_interval.c:12:/* Loss Interval weights from [RFC 3448, 5.4], scaled by 10 */
linux/net/dccp/ccids/lib/tfrc_equation.c:21:  equation from [RFC 3448, sec. 3.1]:
linux/net/dccp/feat.c:551:/* generate @to as full clone of @from - @to must not contain any nodes */
linux/net/dccp/feat.c:693: * @feat: an NN feature from %dccp_feature_numbers
linux/net/dccp/feat.c:718: * @feat: an SP feature from %dccp_feature_numbers
linux/net/dccp/feat.c:770: * @feat: NN feature number from %dccp_feature_numbers
linux/net/dccp/feat.c:800: * @feat: NN feature number from %dccp_feature_numbers
linux/samples/vfs/test-statx.c:194:	from /= 8;
linux/samples/bpf/xdp_redirect_cpu_user.c:334:	 * If deepest state take 133 usec to wakeup from (133/10^6). When link
linux/samples/bpf/test_overhead_tp.bpf.c:10:/* from /sys/kernel/tracing/events/task/task_rename/format */
linux/samples/bpf/test_overhead_tp.bpf.c:24:/* from /sys/kernel/tracing/events/fib/fib_table_lookup/format */
linux/samples/bpf/xdp_redirect_user.c:157:	printf("Redirecting from %s (ifindex %d; driver %s) to %s (ifindex %d; driver %s)\n",
linux/samples/bpf/test_lwt_bpf.c:153:		printk("out: rewriting from %x to %x", old_ip, new_ip);
linux/samples/bpf/offwaketime_kern.c:113:/* taken from /sys/kernel/tracing/events/sched/sched_switch/format */
linux/samples/bpf/xdp_adjust_tail_user.c:162:	/* static global var 'max_pcktsz' is accessible from .data section */
linux/samples/bpf/test_lwt_bpf.sh:182:	# be from $IP_LOCAL => $IP_LOCAL
linux/samples/bpf/test_lwt_bpf.sh:219:	# be from $IP_LOCAL => $IP_LOCAL
linux/samples/bpf/test_lwt_bpf.sh:253:	# be from $IP_LOCAL => $IP_LOCAL
linux/samples/bpf/xdp_redirect_map_user.c:213:	printf("Redirecting from %s (ifindex %d; driver %s) to %s (ifindex %d; driver %s)\n",
linux/samples/bpf/Makefile.target:30:# Object (.o) files compiled from .c files
linux/samples/bpf/cpustat_user.c:99: * This function is copied from 'idlestat' tool function
linux/samples/bpf/xdp_sample_pkts_user.c:61:			printf("ERROR: failed to detach prog from %s\n", name);
linux/samples/bpf/xdp_fwd_user.c:97:		printf("ERROR: failed to detach program from %s (%s)\n",
linux/samples/fprobe/fprobe_example.c:78:		trace_printk("Return from <%pS> ip = 0x%p to rip = 0x%p (%pS)\n",
linux/samples/fprobe/fprobe_example.c:81:		pr_info("Return from <%pS> ip = 0x%p to rip = 0x%p (%pS)\n",
linux/samples/hid/Makefile.target:30:# Object (.o) files compiled from .c files
linux/rust/Makefile:263:# Derived from `scripts/Makefile.clang`.
linux/rust/kernel/sync/arc.rs:103:/// Coercion from `Arc<Example>` to `Arc<dyn MyTrait>`:
linux/rust/kernel/sync/arc.rs:140:// This is to allow coercion from `Arc<T>` to `Arc<U>` if `T` can be converted to the
linux/rust/kernel/sync/arc.rs:542:            // SAFETY: The new `Arc` is taking over `ptr` from `self.inner` (which won't be
linux/rust/kernel/print.rs:19:// Called from `vsprintf` with format specifier `%pA`.
linux/rust/kernel/init/macros.rs:15://! `pin_init!` macros from `init.rs`.
linux/rust/kernel/init.rs:830:/// The safety caveats from [`try_pin_init!`] also apply:
linux/rust/alloc/boxed.rs:64://! T` obtained from [`Box::<T>::into_raw`] may be deallocated using the
linux/rust/alloc/vec/is_zero.rs:92:// While the documentation officially makes it UB to transmute from `None`,
linux/rust/alloc/vec/mod.rs:2015:        // - `elems` comes directly from `as_mut_slice` and is therefore valid.
linux/rust/alloc/vec/mod.rs:2118:    /// calling the closure `f`. The return values from `f` will end up
linux/rust/alloc/vec/mod.rs:2441:    /// Copies elements from `src` range to the end of the vector.
linux/rust/alloc/vec/drain.rs:138:            // this can be achieved by manipulating the Vec length instead of moving values out from `iter`.
linux/rust/alloc/lib.rs:209:// Need to conditionally define the mod from `boxed.rs` to avoid
linux/rust/alloc/slice.rs:596:        // first `rem` repetitions from `buf` itself.
linux/rust/alloc/slice.rs:937:    // When dropped, copies from `src` into `dest`.
linux/fs/utimes.c:138: * Else, update from *times, must be owner or super user.
linux/fs/kernfs/dir.c:62:/* kernfs_node_depth - compute depth from @from to @to */
linux/fs/kernfs/dir.c:214: * path (which includes '..'s) as needed to reach from @from to @to is
linux/fs/kernfs/file.c:592: *	kernfs_unlink_open_file - Unlink @of from @kn.
linux/fs/afs/inode.c:935:		loff_t from = min(size, i_size);
linux/fs/afs/dir_edit.c:469:	_debug("Remove %s from %u[%u]", name->name, b, slot);
linux/fs/afs/write.c:92:	from = pos - index * PAGE_SIZE;
linux/fs/afs/write.c:93:	to = from + len;
linux/fs/afs/write.c:115:		    (to < f || from > t))
linux/fs/afs/write.c:160:	unsigned int f, from = offset_in_folio(folio, pos);
linux/fs/afs/write.c:161:	unsigned int t, to = from + copied;
linux/fs/afs/write.c:195:		if (from < f)
linux/fs/afs/security.c:446:			if (!(access & (AFS_ACE_DELETE | /* rmdir, unlink, rename from */
linux/fs/afs/internal.h:934:	from >>= res;
linux/fs/vboxsf/file.c:314:	unsigned int from = pos & ~PAGE_MASK;
linux/fs/vboxsf/file.c:321:		zero_user(page, from + copied, len - copied);
linux/fs/ecryptfs/inode.c:758:		 * that page from (ia->ia_size & ~PAGE_MASK) to
linux/fs/ecryptfs/read_write.c:20: * @size: Number of bytes from @data to write at @offset in the lower
linux/fs/ecryptfs/read_write.c:48: * @size: The amount of data from @page_for_lower to write to the
linux/fs/ecryptfs/read_write.c:80: *          data from @data
linux/fs/ecryptfs/read_write.c:81: * @size: The number of bytes to write from @data
linux/fs/ecryptfs/read_write.c:210: * @size: Number of bytes to read from @offset of the lower file and
linux/fs/ecryptfs/mmap.c:305:					       "inserting the metadata from "
linux/fs/ecryptfs/mmap.c:470:	unsigned from = pos & (PAGE_SIZE - 1);
linux/fs/ecryptfs/mmap.c:471:	unsigned to = from + copied;
linux/fs/ecryptfs/keystore.c:887: *                   from @data
linux/fs/ecryptfs/Kconfig:12:	  obtained from <http://ecryptfs.sf.net>.
linux/fs/ecryptfs/miscdev.c:350: * Returns the number of bytes read from @buf
linux/fs/ecryptfs/main.c:57:		 "sleep while waiting for a message response from "
linux/fs/ntfs/lcnalloc.h:24:	MFT_ZONE	= 0,	/* Allocate from $MFT zone. */
linux/fs/ntfs/lcnalloc.h:25:	DATA_ZONE	= 1,	/* Allocate from $DATA zone. */
linux/fs/ntfs/lcnalloc.h:47: * If @count is -1, all clusters from @start_vcn to the end of the runlist are
linux/fs/ntfs/usnjrnl.c:43:			ntfs_error(vol->sb, "Failed to read from "
linux/fs/ntfs/inode.c:2404:			ntfs_error(vi->i_sb, "Open attribute is missing from "
linux/fs/ntfs/inode.c:2563:				"type 0x%x, because the conversion from "
linux/fs/ntfs/lcnalloc.c:786: * If @count is -1, all clusters from @start_vcn to the end of the runlist are
linux/fs/ntfs/attrib.c:1347: * ntfs volume @vol.  This information is obtained from $AttrDef system file.
linux/fs/ntfs/attrib.c:1383: * be non-resident.  This information is obtained from $AttrDef system file.
linux/fs/ntfs/attrib.c:1795:					"attribute type 0x%x from %i bytes to "
linux/fs/ntfs/super.c:1533:	/* Read the USN_HEADER from $DATA/$Max. */
linux/fs/ntfs/super.c:1536:		ntfs_error(vol->sb, "Failed to read from $UsnJrnl/$DATA/$Max "
linux/fs/ntfs/super.c:1630:	ntfs_debug("Read %llu bytes from $AttrDef.", i_size);
linux/fs/ntfs/super.c:1699:	ntfs_debug("Read %llu bytes from $UpCase (expected %zu bytes).",
linux/fs/ntfs/runlist.c:406:	 * to make space for the runs to be copied from @src, i.e. the first
linux/fs/ntfs/logfile.c:334: *	-EIO	- Failed to reading from $LogFile.
linux/fs/reiserfs/fix_node.c:367: * from - number of items, which are shifted to left neighbor entirely
linux/fs/reiserfs/fix_node.c:384:	/* position of item we start filling node from */
linux/fs/reiserfs/fix_node.c:441:	/* start from 'from'-th item */
linux/fs/reiserfs/fix_node.c:555:		    ((from == split_item_num
linux/fs/reiserfs/fix_node.c:583:		    ((from == split_item_num
linux/fs/reiserfs/file.c:202:		if (block_end <= from || block_start >= to) {
linux/fs/reiserfs/lbalance.c:41:		copy_records_len = (from ? deh_location(&deh[from - 1]) :
linux/fs/reiserfs/lbalance.c:43:		    deh_location(&deh[from + copy_count - 1]);
linux/fs/reiserfs/lbalance.c:46:		    deh_location(&deh[from + copy_count - 1]);
linux/fs/reiserfs/lbalance.c:82:			if (from < ih_entry_count(ih)) {
linux/fs/reiserfs/lbalance.c:325:	       "vs-10100: too few items in source %d, required %d from %d",
linux/fs/reiserfs/lbalance.c:1087:	RFALSE(ih_entry_count(ih) < from + del_count,
linux/fs/reiserfs/lbalance.c:1088:	       "10185: item contains not enough entries: entry_count = %d, from = %d, to delete = %d",
linux/fs/reiserfs/lbalance.c:1105:	    (from ? deh_location(&deh[from - 1]) : ih_item_len(ih));
linux/fs/reiserfs/lbalance.c:1107:	    deh_location(&deh[from + del_count - 1]);
linux/fs/reiserfs/lbalance.c:1111:	for (i = ih_entry_count(ih) - 1; i > from + del_count - 1; i--)
linux/fs/reiserfs/lbalance.c:1125:		deh + from + del_count,
linux/fs/reiserfs/lbalance.c:1126:		prev_record - cut_records_len - (char *)(deh + from +
linux/fs/reiserfs/reiserfs.h:535:	/* Depth of the lock, start from -1 like the bkl */
linux/fs/reiserfs/prints.c:455:		from = 0;
linux/fs/reiserfs/prints.c:458:		from = first;
linux/fs/reiserfs/prints.c:505:		from = 0;
linux/fs/reiserfs/prints.c:507:		from = first;
linux/fs/reiserfs/ibalance.c:281:	i_from = (from == 0) ? from : from - 1;
linux/fs/reiserfs/ibalance.c:284:	 * delete n pointers starting from `from' position in CUR;
linux/fs/reiserfs/ibalance.c:285:	 * delete n keys starting from 'i_from' position in CUR;
linux/fs/reiserfs/item_ops.c:588:		from = 0;
linux/fs/reiserfs/item_ops.c:590:		from = dir_u->entry_count - count;
linux/fs/reiserfs/item_ops.c:591:	to = from + count - 1;
linux/fs/ntfs3/bitmap.c:816:	size_t i, from = 0, len = 0;
linux/fs/ntfs3/bitmap.c:823:				from = bit + i;
linux/fs/ntfs3/xattr.c:414:	 * 2. New attribute size must fit value from $AttrDef
linux/fs/ntfs3/file.c:184:	u32 from = vbo & (PAGE_SIZE - 1);
linux/fs/ntfs3/file.c:192:	for (; idx < idx_end; idx += 1, from = 0) {
linux/fs/ntfs3/file.c:212:			if (bh_next <= from || bh_off >= to)
linux/fs/ntfs3/file.c:259:	u64 from = ((u64)vma->vm_pgoff << PAGE_SHIFT);
linux/fs/ntfs3/file.c:280:			       from + vma->vm_end - vma->vm_start);
linux/fs/ntfs3/file.c:286:			CLST vcn = from >> sbi->cluster_bits;
linux/fs/ntfs3/fsntfs.c:674:		from = sbi->mft.used;
linux/fs/ntfs3/fsntfs.c:675:		if (from < zbit)
linux/fs/ntfs3/fsntfs.c:676:			from = zbit;
linux/fs/ntfs3/fsntfs.c:678:		if (from < to) {
linux/fs/ntfs3/fsntfs.c:777:	if (from >= to)
linux/fs/ntfs3/fsntfs.c:785:	vbo = (u64)from * rs;
linux/fs/ntfs3/fsntfs.c:786:	for (; from < to; from++, vbo += rs) {
linux/fs/ntfs3/index.c:375:	size_t vbo = from >> 3;
linux/fs/ntfs3/index.c:389:	from &= nbits - 1;
linux/fs/ntfs3/index.c:417:	for (; blk < blen; blk++, from = 0) {
linux/fs/ntfs3/index.c:434:		ok = nbits > from ?
linux/fs/ntfs3/index.c:526:	size_t from = *bit;
linux/fs/ntfs3/attrib.c:1080:	/* Stored [vcn : next_svcn) from [vcn : end). */
linux/fs/ntfs3/attrib.c:1346:	for (vcn = from >> cluster_bits; vcn <= vcn_last; vcn += clen) {
linux/fs/ntfs3/attrib.c:1447:			u64 from = vbo[i] & ~(u64)(PAGE_SIZE - 1);
linux/fs/ntfs3/attrib.c:1448:			u64 to = min(from + PAGE_SIZE, wof_size);
linux/fs/ntfs3/attrib.c:1722:	/* Stored [vcn : next_svcn) from [vcn : end). */
linux/fs/ntfs3/attrib.c:2125:		from = vbo;
linux/fs/ntfs3/run.c:916: * run_unpack - Unpack packed runs from @run_buf.
linux/fs/ntfs3/run.c:1044: * run_unpack_ex - Unpack packed runs from "run_buf".
linux/fs/stat.c:668: * @dfd: Base directory to pathwalk from *or* fd to stat.
linux/fs/cachefiles/xattr.c:161:					    "Can't remove xattr from %lu"
linux/fs/open.c:1019: * @dentry: dentry or NULL (as returned from ->lookup())
linux/fs/open.c:1506: * from @fd up to and including @max_fd are closed.
linux/fs/hfs/super.c:211:	if (arg->to - arg->from != 4)
linux/fs/configfs/file.c:180:/* Fill @buffer with data coming from @from. */
linux/fs/udf/symlink.c:43:		pc = (struct pathComponent *)(from + elen);
linux/fs/crypto/keyring.c:391: * Remove the current user's "key" from ->mk_users.
linux/fs/crypto/keysetup.c:352:		 * IV_INO_LBLK_64: encryption keys are derived from (master_key,
linux/fs/crypto/crypto.c:225: * and @lblk_num must be specified, as they can't be determined from @page.
linux/fs/crypto/crypto.c:296: * and @lblk_num must be specified, as they can't be determined from @page.
linux/fs/sysv/itree.c:75:	while (from <= to && from->key == *from->p)
linux/fs/sysv/itree.c:77:	return (from > to);
linux/fs/inode.c:2491: * In all other cases, strip the S_ISGID bit from @mode.
linux/fs/lockd/svc.c:172:		dprintk("lockd: request from %s\n",
linux/fs/lockd/svc4proc.c:475:		printk(KERN_WARNING "lockd: rejected NSM callback from %s\n",
linux/fs/lockd/svcproc.c:510:		printk(KERN_WARNING "lockd: rejected NSM callback from %s\n",
linux/fs/gfs2/file.c:50: * @whence: Where to seek from (SEEK_SET, SEEK_CUR, or SEEK_END)
linux/fs/gfs2/aops.c:46:	unsigned int to = from + len;
linux/fs/ext4/resize.c:1847:			 "extending last group from %llu to %llu blocks",
linux/fs/ext4/resize.c:2037:	ext4_msg(sb, KERN_INFO, "resizing filesystem from %llu "
linux/fs/ext4/move_extent.c:96:	ext4_lblk_t last = from + count;
linux/fs/ext4/move_extent.c:97:	while (from < last) {
linux/fs/ext4/move_extent.c:104:		from += ext4_ext_get_actual_len(ext);
linux/fs/ext4/move_extent.c:195:		if (block_end <= from || block_start >= to) {
linux/fs/ext4/move_extent.c:266:	int from = data_offset_in_page << orig_inode->i_blkbits;
linux/fs/ext4/move_extent.c:359:	*err = mext_page_mkuptodate(folio[0], from, from + replaced_size);
linux/fs/ext4/move_extent.c:399:		*err = block_commit_write(&folio[0]->page, from, from + replaced_size);
linux/fs/ext4/mballoc.c:769: * Divide blocks started from @first with length @len into
linux/fs/ext4/fast_commit.c:1814:		ext4_debug("Converting from %ld to %d %lld",
linux/fs/ext4/inode.c:967:		if (block_end <= from || block_start >= to) {
linux/fs/ext4/inode.c:1021:	unsigned from = pos & (PAGE_SIZE - 1);
linux/fs/ext4/inode.c:1022:	unsigned to = from + len;
linux/fs/ext4/inode.c:1034:	BUG_ON(from > PAGE_SIZE);
linux/fs/ext4/inode.c:1036:	BUG_ON(from > to);
linux/fs/ext4/inode.c:1049:		if (block_end <= from || block_start >= to) {
linux/fs/ext4/inode.c:1082:		    (block_start < from || block_end > to)) {
linux/fs/ext4/inode.c:1143:	from = pos & (PAGE_SIZE - 1);
linux/fs/ext4/inode.c:1144:	to = from + len;
linux/fs/ext4/inode.c:1358:			if (block_end > from && block_start < to) {
linux/fs/ext4/inode.c:1392:	from = pos & (PAGE_SIZE - 1);
linux/fs/ext4/inode.c:1393:	to = from + len;
linux/fs/ext4/inode.c:1407:							 from + copied, to);
linux/fs/ext4/inode.c:1410:					     from, from + copied, &partial,
linux/fs/ext4/inode.c:1965: * Walk through page buffers from @bh upto @head (exclusive) and either submit
linux/fs/ext4/inode.c:3614:	ext4_fsblk_t index = from >> PAGE_SHIFT;
linux/fs/ext4/inode.c:3615:	unsigned offset = from & (PAGE_SIZE-1);
linux/fs/ext4/inode.c:3623:	folio = __filemap_get_folio(mapping, from >> PAGE_SHIFT,
linux/fs/ext4/inode.c:3717:	unsigned offset = from & (PAGE_SIZE-1);
linux/fs/ext4/inode.c:3744:	unsigned offset = from & (PAGE_SIZE-1);
linux/fs/ext4/inline.c:592:	from = 0;
linux/fs/ext4/ext4_extents.h:75:	__le32	ei_block;	/* index covers logical blocks from 'block' */
linux/fs/ext4/migrate.c:463:	 * Use the correct seed for checksum (i.e. the seed from 'inode').  This
linux/fs/ext4/extents.c:2019:				  "(from %llu)\n",
linux/fs/ext4/extents.c:2043:				  "(from %llu)\n",
linux/fs/ext4/extents.c:2466:	if (from < le32_to_cpu(ex->ee_block) ||
linux/fs/ext4/extents.c:2469:			   "strange request: removal(2) %u-%u from %u:%u",
linux/fs/ext4/extents.c:3486:		 * A transfer of blocks from 'ex' to 'abut_ex' is allowed
linux/fs/ext4/extents.c:3532:		 * A transfer of blocks from 'ex' to 'abut_ex' is allowed
linux/fs/ext4/extents.c:5124: * All the extents which lies in the range from @start to the last allocated
linux/fs/ext4/extents.c:5411: * The data blocks starting from @offset to the EOF are shifted by @len
linux/fs/ext4/indirect.c:130: *	numbers of the chain, addresses they were taken from (and where we can
linux/fs/ext4/indirect.c:790: *		a) free the subtree starting from *@top
linux/fs/ext4/namei.c:1919:						(from + (map->offs<<2));
linux/fs/proc/proc_tty.c:70:	dev_t from = MKDEV(p->major, p->minor_start);
linux/fs/proc/proc_tty.c:71:	dev_t to = from + p->num;
linux/fs/proc/proc_tty.c:96:		from = next;
linux/fs/proc/proc_tty.c:98:	if (from != to)
linux/fs/proc/task_mmu.c:771: * Gather mem stats from @vma with the indicated beginning
linux/fs/proc/proc_sysctl.c:995: * the reference is moved from @dir to the returned subdirectory.
linux/fs/proc/vmcore.c:523:				if (remap_oldmem_pfn_range(vma, from + len,
linux/fs/proc/vmcore.c:530:			if (remap_oldmem_pfn_range(vma, from + len,
linux/fs/proc/vmcore.c:541:		if (remap_oldmem_pfn_range(vma, from + len, pos_start,
linux/fs/nfs/nfs42xdr.c:1077:		seg->data.from = xdr_stream_pos(xdr);
linux/fs/nfs/callback_proc.c:43:	dprintk_rcu("NFS: GETATTR callback request from %s\n",
linux/fs/nfs/callback_proc.c:89:	dprintk_rcu("NFS: RECALL callback request from %s\n",
linux/fs/nfs/callback_proc.c:604:	dprintk_rcu("NFS: RECALL_ANY callback request from %s\n",
linux/fs/nfs/callback_proc.c:650:	dprintk_rcu("NFS: CB_RECALL_SLOT request from %s target highest slotid %u\n",
linux/fs/nfs/callback_proc.c:673:	dprintk_rcu("NFS: CB_NOTIFY_LOCK request from %s\n",
linux/fs/nfs/write.c:1419:/* If a nfs_flush_* function fails, it should remove reqs from @head and
linux/fs/nfs/pagelist.c:1471: * Try to move each request (nfs_page) from @hdr to @desc then attempt
linux/fs/nfs/flexfilelayout/flexfilelayout.c:329:	/* Mergeable: copy info from 'old' to 'new' */
linux/fs/direct-io.c:187:		sdio->from = 0;
linux/fs/direct-io.c:909:		from = sdio->head ? 0 : sdio->from;
linux/fs/direct-io.c:913:		while (from < to) {
linux/fs/direct-io.c:990:				from += 1 << blkbits;
linux/fs/direct-io.c:1031:			from += this_chunk_bytes;
linux/fs/jfs/jfs_unicode.c:76:		for (i = 0; len && *from; i++, from += charlen, len -= charlen)
linux/fs/dlm/requestqueue.c:86:		log_limit(ls, "dlm_process_requestqueue msg %d from %d "
linux/fs/dlm/dir.c:249:			log_error(ls, "copy_master_names from %d start %d %s",
linux/fs/dlm/ast.c:36:	*from = to;
linux/fs/dlm/lowcomms.c:1064:	log_print("got connection from %d", nodeid);
linux/fs/dlm/lock.c:1009:		log_error(ls, "dlm_master_lookup from %d dir %d our %d h %x %d",
linux/fs/dlm/lock.c:3784:	int from = le32_to_cpu(ms->m_header.h_nodeid);
linux/fs/dlm/lock.c:3827:			  "ignore invalid message %d from %d %x %x %x %d",
linux/fs/dlm/lock.c:3904:		log_limit(ls, "receive_request %x from %d %d",
linux/fs/dlm/lock.c:4148:		log_error(ls, "receive_remove from %d bad len %d",
linux/fs/dlm/lock.c:4155:		log_error(ls, "receive_remove from %d bad nodeid %d",
linux/fs/dlm/lock.c:4183:			log_error(ls, "receive_remove from %d not found %s",
linux/fs/dlm/lock.c:4190:			log_error(ls, "receive_remove keep from %d master %d",
linux/fs/dlm/lock.c:4197:		log_debug(ls, "receive_remove from %d master %d first %x %s",
linux/fs/dlm/lock.c:4205:		log_error(ls, "receive_remove toss from %d master %d",
linux/fs/dlm/lock.c:4217:		log_error(ls, "receive_remove from %d rsb ref error",
linux/fs/dlm/lock.c:4296:		log_limit(ls, "receive_request_reply %x from %d %d "
linux/fs/dlm/lock.c:4570:		log_error(ls, "receive_lookup_reply %x from %d ret %d "
linux/fs/dlm/lock.c:4584:		log_error(ls, "receive_lookup_reply %x from %d bad ret_nodeid",
linux/fs/dlm/lock.c:4733:		log_error(ls, "receive %d inval from %d lkid %x remid %x "
linux/fs/dlm/lock.c:4758:			log_limit(ls, "receive %d from %d ignore old gen",
linux/fs/dlm/lock.c:4798:		log_print("invalid h_cmd %d from %u", hd->h_cmd, nodeid);
linux/fs/dlm/lock.c:4803:		log_print("invalid h_nodeid %d from %d lockspace %x",
linux/fs/dlm/lock.c:4813:				"%u from %d cmd %d type %d\n",
linux/fs/dlm/lock.c:4832:		log_error(ls, "invalid h_cmd %d from %d lockspace %x",
linux/fs/dlm/rcom.c:289:		log_debug(ls, "reject reply %d from %d seq %llx expect %llx",
linux/fs/dlm/rcom.c:385:		log_error(ls, "receive_rcom_lookup dump from %d", nodeid);
linux/fs/dlm/rcom.c:666:		  "from %d %llu %llu recover seq %llu sts %x gen %u",
linux/fs/dlm/rcom.c:675:	log_error(ls, "recovery message %d from %d is too short",
linux/fs/jbd2/journal.c:1126:		  "Cleaning journal tail from %u to %u (offset %lu), "
linux/fs/ocfs2/stackglue.h:138:	 * be freed.  Thus, a stack must not return from ->disconnect()
linux/fs/ocfs2/journal.h:49:					       * from (recovery,
linux/fs/ocfs2/alloc.c:3218:	 * Now we can loop, remembering the path we get from -EAGAIN
linux/fs/ocfs2/alloc.c:6697:		mlog(0, "Reusing block(%llu) from "
linux/fs/ocfs2/alloc.c:6860:		from = start & (PAGE_SIZE - 1);
linux/fs/ocfs2/alloc.c:6864:		BUG_ON(from > PAGE_SIZE);
linux/fs/ocfs2/dlm/dlmrecovery.c:105:		mlog(0, "%s: changing dead_node from %u to %u\n",
linux/fs/ocfs2/dlm/dlmrecovery.c:114:	mlog(0, "%s: changing new_master from %u to %u\n",
linux/fs/ocfs2/dlm/dlmrecovery.c:614:				mlog(0, "now receiving recovery data from "
linux/fs/ocfs2/dlm/dlmrecovery.c:619:				mlog(0, "already receiving recovery data from "
linux/fs/ocfs2/dlm/dlmrecovery.c:1799:	u8 from = O2NM_MAX_NODES;
linux/fs/ocfs2/dlm/dlmrecovery.c:2139:			mlog(0, "%s: res %.*s, Changing owner from %u to %u\n",
linux/fs/ocfs2/dlm/dlmrecovery.c:2184:			mlog(0, "%s: res %.*s, Changing owner from %u to %u\n",
linux/fs/ocfs2/dlm/dlmrecovery.c:2924:				mlog(ML_ERROR, "%s: received finalize1 from "
linux/fs/ocfs2/dlm/dlmrecovery.c:2936:				mlog(ML_ERROR, "%s: received finalize2 from "
linux/fs/ocfs2/dlm/dlmmaster.c:1794:		mlog(0, "just got an assert_master from %u, but no "
linux/fs/ocfs2/dlm/dlmmaster.c:1824:				     " from %u for migration\n",
linux/fs/ocfs2/dlm/dlmmaster.c:1829:				     " from %u for migration, ignoring\n",
linux/fs/ocfs2/dlm/dlmmaster.c:1854:				mlog(ML_ERROR, "DIE! Mastery assert from %u, "
linux/fs/ocfs2/dlm/dlmmaster.c:1870:				mlog(ML_ERROR, "got assert_master from "
linux/fs/ocfs2/dlm/dlmmaster.c:1877:				mlog(ML_ERROR, "got assert from %u, but lock "
linux/fs/ocfs2/dlm/dlmmaster.c:1887:				mlog(ML_ERROR, "got assert from %u, but "
linux/fs/ocfs2/dlm/dlmmaster.c:1932:			     		"from %u to %u\n",
linux/fs/ocfs2/dlm/dlmmaster.c:1966:			mlog(ML_ERROR, "%s:%.*s: got assert master from %u "
linux/fs/ocfs2/dlm/dlmmaster.c:1985:			mlog(0, "assert_master from %u, but current "
linux/fs/ocfs2/dlm/dlmmaster.c:2006:			mlog(ML_ERROR, "strange, got assert from %u, MASTER "
linux/fs/ocfs2/dlm/dlmmaster.c:2014:		mlog(0, "%s:%.*s: got assert from %u, need a ref\n",
linux/fs/ocfs2/dlm/dlmmaster.c:2836:	mlog(0, "dlm_mark_lockres_migrating: %.*s, from %u to %u\n",
linux/fs/ocfs2/dlm/dlmmaster.c:3379:						"migration from %u, the MLE is "
linux/fs/ocfs2/dlm/dlmmaster.c:3390:			mlog(0, "%s: node %u died during migration from "
linux/fs/ocfs2/dlm/dlmcommon.h:529: * from ../cluster/tcp.h
linux/fs/ocfs2/dlm/dlmconvert.c:210:		mlog(0, "failed to convert NOQUEUE lock %.*s from "
linux/fs/ocfs2/refcounttree.c:2936:		from = offset & (PAGE_SIZE - 1);
linux/fs/ocfs2/buffer_head_io.c:267:		 *    uptodate cache. The re-check from #2 catches the
linux/fs/ocfs2/dlmglue.c:64: * Return value from ->downconvert_worker functions.
linux/fs/ocfs2/dlmglue.c:118:	mlog(level, "LVB information for %s (called from %s:%u):\n",
linux/fs/ocfs2/dlmglue.c:1577:		mlog(ML_BASTS, "lockres %s, convert from %d to %d\n",
linux/fs/ocfs2/ocfs2_lockid.h:96:	/* Need to differntiate from [R]ename.. serializing writes is the
linux/fs/ocfs2/cluster/masklog.h:16: * maintained with help from /proc.  If any of the bits match the message is
linux/fs/ocfs2/cluster/tcp.c:1829:					"seen at node '%s' (%u, %pI4:%d) from "
linux/fs/ocfs2/aops.c:433:		if (block_end <= from || block_start >= to) {
linux/fs/ocfs2/aops.c:539: * from == to == 0 is code for "zero the entire cluster region"
linux/fs/ocfs2/aops.c:552:	if (from || to) {
linux/fs/ocfs2/aops.c:553:		if (from > cluster_start)
linux/fs/ocfs2/aops.c:554:			memset(kaddr + cluster_start, 0, from - cluster_start);
linux/fs/ocfs2/aops.c:638:			   (block_start < from || block_end > to)) {
linux/fs/ocfs2/aops.c:890:			if (block_end > from && block_start < to) {
linux/fs/ocfs2/aops.c:920:	unsigned from = user_pos & (PAGE_SIZE - 1),
linux/fs/ocfs2/aops.c:2012:			from = wc->w_target_from;
linux/fs/ocfs2/aops.c:2015:			BUG_ON(from > PAGE_SIZE ||
linux/fs/ocfs2/aops.c:2024:			from = 0;
linux/fs/ocfs2/namei.c:1625:			     "%llu from %d to %d but bh is NULL!\n",
linux/fs/mnt_idmapping.c:81: * Take a @kuid and remap it from @fs_userns into @idmap. Use this
linux/fs/mnt_idmapping.c:121: * Take a @kgid and remap it from @fs_userns into @idmap. Use this
linux/fs/splice.c:452: * Send 'sd->len' bytes to socket from 'sd->file' at position 'sd->pos'
linux/fs/splice.c:936:	 * 'out' and transfer the wanted data from 'in' to 'out' through that
linux/fs/file.c:728: * from @fd up to and including @max_fd are closed.
linux/fs/file.c:1289:	if (from >= nofile)
linux/fs/read_write.c:1701: * from @file_in to @file_out.
linux/fs/affs/file.c:700:	from = pos & (PAGE_SIZE - 1);
linux/fs/affs/file.c:701:	to = from + len;
linux/fs/affs/file.c:731:		from += tmp;
linux/fs/affs/file.c:740:	while (from + bsize <= to) {
linux/fs/affs/file.c:769:		from += bsize;
linux/fs/affs/file.c:772:	if (from < to) {
linux/fs/affs/file.c:804:		from += tmp;
linux/fs/userfaultfd.c:814:	ewq.msg.arg.remap.from = from;
linux/fs/devpts/inode.c:542: * The created inode is returned. Remove it from /dev/pts/ by devpts_pty_kill.
linux/fs/mpage.c:662: * @wbc: subtract the number of written pages from *@wbc->nr_to_write
linux/fs/namespace.c:526:	 * decremented from -- we would see more decrements than we should.
linux/fs/namespace.c:2754:	from = real_mount(from_path->mnt);
linux/fs/seq_file.c:97:	m->count = m->from = 0;
linux/fs/seq_file.c:122:			m->from = offset - pos;
linux/fs/seq_file.c:218:		m->from += n;
linux/fs/seq_file.c:224:	m->from = 0;
linux/fs/seq_file.c:284:	m->from = n;
linux/fs/seq_file.c:435: *      Copy the path from @p to @s, replacing each occurrence of character from
linux/fs/hpfs/dnode.c:430: * Return the dnode we moved from (to be checked later if it's empty)
linux/fs/hpfs/dnode.c:451:				hpfs_error(i->i_sb, "move_to_top: up pointer from %08x should be %08x, is %08x",
linux/fs/hpfs/dnode.c:477:			hpfs_error(i->i_sb, "move_to_top: got to root_dnode while moving from %08x to %08x", from, to);
linux/fs/hpfs/dnode.c:766:			hpfs_error(s, "hpfs_count_dnodes: pointer to dnode %08x not found in dnode %08x, got here from %08x",
linux/fs/freevxfs/vxfs_lookup.c:184: *   vxfs_readdir fills @retp with directory entries from @fp
linux/fs/buffer.c:1949:			if (block_end > from && block_start < to) {
linux/fs/buffer.c:2029:	unsigned from = pos & (PAGE_SIZE - 1);
linux/fs/buffer.c:2030:	unsigned to = from + len;
linux/fs/buffer.c:2039:	BUG_ON(from > PAGE_SIZE);
linux/fs/buffer.c:2041:	BUG_ON(from > to);
linux/fs/buffer.c:2052:		if (block_end <= from || block_start >= to) {
linux/fs/buffer.c:2093:		     (block_start < from || block_end > to)) {
linux/fs/buffer.c:2133:		if (block_end <= from || block_start >= to) {
linux/fs/buffer.c:2281:	to = from + to;
linux/fs/buffer.c:2282:	if (from < blocksize && to > folio_size(folio) - blocksize)
linux/fs/buffer.c:2289:		if (block_end > from && block_start < to) {
linux/fs/buffer.c:2606:	pgoff_t index = from >> PAGE_SHIFT;
linux/fs/buffer.c:2607:	unsigned offset = from & (PAGE_SIZE-1);
linux/fs/overlayfs/inode.c:902: * For example, here is a snip from /proc/lockdep_chains after
linux/fs/overlayfs/export.c:615:			 * overlay rename of child away from 'connected' parent.
linux/fs/overlayfs/namei.c:78:	/* Check if directory belongs to the layer we are decoding from */
linux/fs/char_dev.c:203:	dev_t to = from + count;
linux/fs/char_dev.c:313:	dev_t to = from + count;
linux/fs/ext2/inode.c:128:	while (from <= to && from->key == *from->p)
linux/fs/ext2/inode.c:130:	return (from > to);
linux/fs/ext2/inode.c:221: *	numbers of the chain, addresses they were taken from (and where we can
linux/fs/ext2/inode.c:1002: *		a) free the subtree starting from *@top
linux/fs/ext2/dir.c:597:	unsigned from = ((char*)dir - kaddr) & ~(ext2_chunk_size(inode)-1);
linux/fs/ext2/dir.c:616:		from = (char *)pde - kaddr;
linux/fs/ext2/balloc.c:1383:			    "blocks from "E2FSBLK", length %lu",
linux/fs/orangefs/orangefs-kernel.h:260:/* ino_t descends from "unsigned long", 8 bytes, 64 bits. */
linux/fs/orangefs/inode.c:389:		unsigned from = pos & (PAGE_SIZE - 1);
linux/fs/orangefs/inode.c:391:			zero_user(page, from + copied, len - copied);
linux/fs/orangefs/inode.c:396:			zero_user_segment(page, from + copied, PAGE_SIZE);
linux/fs/orangefs/orangefs-bufmap.c:519:	from = &__orangefs_bufmap->desc_array[buffer_index];
linux/fs/orangefs/orangefs-bufmap.c:545:	from = &__orangefs_bufmap->desc_array[buffer_index];
linux/fs/dax.c:678: *       pages from 'start' till the end of file are included.
linux/fs/dax.c:812: * Delete DAX entry at @index from @mapping.  Wait for it
linux/fs/hostfs/hostfs_kern.c:485:	unsigned from = pos & (PAGE_SIZE - 1);
linux/fs/binfmt_misc.c:208: * parses and copies one argument enclosed in del from *sp to *dp,
linux/fs/f2fs/compress.c:1143:	pgoff_t start_idx = from >> (PAGE_SHIFT + log_cluster_size) <<
linux/fs/f2fs/compress.c:1173:			if (from <= start) {
linux/fs/f2fs/compress.c:1176:				zero_user_segment(rpages[i], from - start,
linux/fs/f2fs/dir.c:45:/* If @dir is casefolded, initialize @fname->cf_name from @fname->usr_fname. */
linux/fs/f2fs/file.c:638:	loff_t offset = from & (PAGE_SIZE - 1);
linux/fs/f2fs/file.c:639:	pgoff_t index = from >> PAGE_SHIFT;
linux/fs/f2fs/file.c:762:	if (from != free_from) {
linux/fs/f2fs/inline.c:87:	if (from >= MAX_INLINE_DATA(inode))
linux/fs/f2fs/inline.c:96:	if (from == 0)
linux/fs/f2fs/super.c:503:		.string = arg->from ? arg->from : "",
linux/fs/f2fs/super.c:679:		args[0].to = args[0].from = NULL;
linux/fs/f2fs/super.c:743:			if (args->from && match_int(args, &arg))
linux/fs/f2fs/super.c:778:			if (args->from && match_int(args, &arg))
linux/fs/f2fs/super.c:825:			if (args->from && match_int(args, &arg))
linux/fs/f2fs/super.c:836:			if (args->from && match_int(args, &arg))
linux/fs/f2fs/super.c:846:			if (args->from && match_int(args, &arg))
linux/fs/f2fs/super.c:880:			if (args->from && match_int(args, &arg))
linux/fs/f2fs/super.c:891:			if (args->from && match_int(args, &arg))
linux/fs/f2fs/super.c:898:			if (args->from && match_int(args, &arg))
linux/fs/f2fs/super.c:1038:			if (args->from && match_int(args, &arg))
linux/fs/f2fs/super.c:1046:			if (args->from && match_int(args, &arg))
linux/fs/f2fs/super.c:1123:			if (args->from && match_int(args, &arg))
linux/fs/hfsplus/options.c:66:	if (arg->to - arg->from != 4)
linux/fs/minix/itree_common.c:20:	while (from <= to && from->key == *from->p)
linux/fs/minix/itree_common.c:22:	return (from > to);
linux/fs/isofs/compress.c:36: * Read data of @inode from @block_start to @block_end and uncompress
linux/fs/isofs/Kconfig:12:	  available from <http://www.tldp.org/docs.html#howto>), thereby
linux/fs/xfs/xfs_inode.c:645: * Lookups up an inode from "name". If ci_name is not NULL, then a CI match
linux/fs/xfs/xfs_iwalk.h:17:/* Walk all inodes in the filesystem starting from @startino. */
linux/fs/xfs/xfs_iwalk.h:33:/* Walk all inode btree records in the filesystem starting from @startino. */
linux/fs/xfs/xfs_iwalk.c:31: * order from @startino until there are no more inodes.  For each allocated
linux/fs/xfs/xfs_iwalk.c:401:/* Walk all inodes in a single AG, from @iwag->startino to the end of the AG. */
linux/fs/xfs/xfs_iwalk.c:544: * Walk all inodes in the filesystem starting from @startino.  The @iwalk_fn
linux/fs/xfs/xfs_iwalk.c:730: * Walk all inode btree records in the filesystem starting from @startino.  The
linux/fs/xfs/xfs_buf_item.c:135:	/* Count the first bit we jumped out of the above loop from */
linux/fs/xfs/libxfs/xfs_dir2_node.c:453:	from = xfs_dir2_leaf_bests_p(ltp);
linux/fs/xfs/libxfs/xfs_alloc.c:3386: * Iterate all AGs trying to allocate an extent starting from @start_ag.
linux/fs/xfs/libxfs/xfs_dir2_leaf.c:938:	for (from = to = 0, loglow = -1; from < leafhdr->count; from++) {
linux/fs/xfs/libxfs/xfs_dir2_leaf.c:945:		if (from > to) {
linux/fs/xfs/libxfs/xfs_dir2_leaf.c:955:	ASSERT(leafhdr->stale == from - to);
linux/fs/xfs/libxfs/xfs_dir2_leaf.c:1009:	for (from = to = 0; from < leafhdr->count; from++) {
linux/fs/xfs/libxfs/xfs_dir2_leaf.c:1015:		if (from != keepstale &&
linux/fs/xfs/libxfs/xfs_dir2_leaf.c:1017:			if (from == to)
linux/fs/xfs/libxfs/xfs_dir2_leaf.c:1024:		if (from == keepstale)
linux/fs/xfs/libxfs/xfs_dir2_leaf.c:1029:		if (from > to)
linux/fs/xfs/libxfs/xfs_dir2_leaf.c:1033:	ASSERT(from > to);
linux/fs/xfs/libxfs/xfs_dir2_leaf.c:1044:	leafhdr->count -= from - to;
linux/fs/xfs/libxfs/xfs_dir2_block.c:1032:	for (from = to = 0; from < leafhdr.count; from++) {
linux/fs/xfs/libxfs/xfs_dir2_sf.c:77:	uint8_t				*from = sfep->name + sfep->namelen;
linux/fs/xfs/libxfs/xfs_btree.c:3724:	int			level,		/* level removing record from */
linux/fs/xfs/libxfs/xfs_ag.c:60: * search from @first to find the next perag with the given tag set.
linux/fs/xfs/libxfs/xfs_ag.c:131: * search from @first to find the next perag with the given tag set.
linux/fs/befs/ChangeLog:178:* Added functions to get the private superblock and inode structures from 
linux/fs/befs/datastream.c:143:				   "starting from %llu", bytes_read);
linux/fs/btrfs/ctree.h:399:	/* Start offset of the range to drop extents from */
linux/fs/btrfs/ctree.h:401:	/* End (exclusive, last byte + 1) of the range to drop extents from */
linux/fs/btrfs/inode.c:2562:	/* First, replace the em with a new extent_map starting from * em->start */
linux/fs/btrfs/inode.c:4684: * @from - the offset to start zeroing
linux/fs/btrfs/inode.c:4703:	pgoff_t index = from >> PAGE_SHIFT;
linux/fs/btrfs/inode.c:4704:	unsigned offset = from & (blocksize - 1);
linux/fs/btrfs/tests/extent-map-tests.c:300: * read from [0, 4K) or [8K, 12K) or [12K, 16K).
linux/fs/btrfs/tests/extent-map-tests.c:413: * read from [0, 4K) or [4K, 8K).
linux/fs/btrfs/bio.c:408:	/* Pass on control to the original bio this one was cloned from */
linux/fs/btrfs/file.c:589: * This changes extent type from 'pre-allocated' to 'regular'. If only
linux/fs/btrfs/block-rsv.c:41: *     successful we subtract fs_info->nodesize from ->reserved.
linux/fs/btrfs/block-rsv.c:47: *     from ->size, and then subtract ->size from ->reserved and free up the
linux/fs/btrfs/block-rsv.c:85: *   count from ->size and free up reservations as necessary.  Since this is
linux/fs/btrfs/volumes.c:885:		 *    from 'path' that means either
linux/fs/btrfs/raid56.c:337:	/* Also inherit the bitmaps from @victim. */
linux/fs/btrfs/ctree.c:91: * Copy item data from @src into @dst at the given @offset.
linux/fs/btrfs/ctree.c:133: * Copy items from @src into @dst at the given @offset.
linux/fs/btrfs/send.c:3732: * Here we can not rename 258 from 'b' to 'a' without the rename of inode 257
linux/fs/btrfs/send.c:3733: * from 'a' to 'x/y' happening first, which in turn depends on the rename of
linux/fs/btrfs/send.c:3734: * inode 259 from 'c' to 'x'. So the order of rename commands the send stream
linux/fs/btrfs/send.c:3737: * 1 - rename 259 from 'c' to 'x'
linux/fs/btrfs/send.c:3738: * 2 - rename 257 from 'a' to 'x/y'
linux/fs/btrfs/send.c:3739: * 3 - rename 258 from 'b' to 'a'
linux/fs/btrfs/dev-replace.c:665:		      "dev_replace from %s (devid %llu) to %s started",
linux/fs/btrfs/dev-replace.c:942:			  "dev_replace from %s (devid %llu) to %s finished",
linux/fs/btrfs/dev-replace.c:1090:				"dev_replace from %s (devid %llu) to %s canceled",
linux/fs/btrfs/dev-replace.c:1124:		"suspended dev_replace from %s (devid %llu) to %s canceled",
linux/fs/btrfs/dev-replace.c:1228:		"continuing dev_replace from %s (devid %llu) to target %s @%u%%",
linux/fs/btrfs/tree-log.c:2473:				from = ALIGN(i_size_read(inode),
linux/fs/btrfs/super.c:423:							args[0].from + 4);
linux/fs/btrfs/super.c:443:							 args[0].from + 4);
linux/fs/btrfs/qgroup.c:2009: * 1) Tree search from @src_eb
linux/fs/btrfs/qgroup.c:2011: *    The key for search can be extracted from @dst_path->nodes[dst_level]
linux/fs/btrfs/qgroup.c:4380:	/* Found one, remove it from @blocks first and update blocks->swapped */
linux/fs/btrfs/extent-tree.c:4413: *			from @num_bytes only in the case of compressed extents.
linux/fs/btrfs/extent_map.c:489: * Remove @em from @tree.  No reference counts are dropped, and no checks
linux/fs/btrfs/extent_map.c:593: * Note that @em_in's range may be different from [start, start+len),
linux/fs/btrfs/check-integrity.c:1627:		" %c @%llu (%pg/%llu/%d) is ref %u* from %c @%llu (%pg/%llu/%d)\n",
linux/fs/btrfs/check-integrity.c:2346:	"rl=%d, %c @%llu (%pg/%llu/%d) is ref %u* from %c @%llu (%pg/%llu/%d)\n",
linux/fs/btrfs/check-integrity.c:2376:	pr_info("add %u* link from %c @%llu (%pg/%llu/%d) to %c @%llu (%pg/%llu/%d)\n",
linux/fs/btrfs/check-integrity.c:2391:	pr_info("rem %u* link from %c @%llu (%pg/%llu/%d) to %c @%llu (%pg/%llu/%d)\n",
linux/fs/btrfs/ioctl.c:1232:			"resize device %s (devid %llu) from %llu to %llu",
linux/fs/btrfs/extent_io.c:2362: * @wbc:       subtract the number of written pages from *@wbc->nr_to_write
linux/fs/kernel_read_file.c:12: * @offset	where to start reading from (see below).
linux/fs/ufs/inode.c:884:	ctx->to = from + count;
linux/fs/ufs/dir.c:507:	unsigned from = ((char*)dir - kaddr) & ~(UFS_SB(sb)->s_uspi->s_dirblksize - 1);
linux/fs/ufs/dir.c:532:		from = (char*)pde - (char*)page_address(page);
linux/fs/ufs/balloc.c:304:			UFSD(" change from %llu to %llu, pos %u\n",
linux/fs/ufs/super.c:514:	 * Read cs structures from (usually) first data block
linux/fs/ceph/file.c:122: * Attempt to get up to @maxsize bytes worth of pages from @iter.
linux/fs/ceph/mds_client.h:259:	struct dentry *r_old_dentry;        /* arg2: rename from or link from */
linux/fs/ceph/caps.c:1121:	dout("__ceph_remove_cap %p from %p\n", cap, &ci->netfs.inode);
linux/fs/libfs.c:563:		unsigned from = pos & (PAGE_SIZE - 1);
linux/fs/libfs.c:565:		zero_user_segments(page, 0, from, from + len, PAGE_SIZE);
linux/fs/libfs.c:603:			unsigned from = pos & (PAGE_SIZE - 1);
linux/fs/libfs.c:605:			zero_user(page, from + copied, len - copied);
linux/fs/libfs.c:764:	ret = copy_to_user(to, from + pos, count);
linux/fs/libfs.c:833:	memcpy(to, from + pos, count);
linux/fs/nilfs2/dir.c:420:	unsigned int from = (char *)de - (char *)page_address(page);
linux/fs/nilfs2/dir.c:421:	unsigned int to = from + nilfs_rec_len_from_disk(de->rec_len);
linux/fs/nilfs2/dir.c:504:	from = (char *)de - (char *)page_address(page);
linux/fs/nilfs2/dir.c:505:	to = from + rec_len;
linux/fs/nilfs2/dir.c:547:	from = ((char *)dir - kaddr) & ~(nilfs_chunk_size(inode) - 1);
linux/fs/nilfs2/dir.c:562:		from = (char *)pde - (char *)page_address(page);
linux/fs/nilfs2/bmap.c:194: * starting from @start, and stores it to @keyp if found.
linux/fs/nilfs2/bmap.c:237: * @key from @bmap.
linux/fs/nilfs2/bmap.c:291: * greater than or equal to @key from @bmap.
linux/fs/nilfs2/cpfile.c:299: * the period from @start to @end, excluding @end itself. The checkpoints
linux/fs/nilfs2/page.c:434:		if (block_end > from && block_start < to && !buffer_dirty(bh))
linux/fs/fs-writeback.c:424:	 * ->b_dirty which is always correct including from ->b_dirty_time.
linux/fs/fs-writeback.c:814:		 * history from @max_time.
linux/fs/fs-writeback.c:855: * @bytes from @page are about to written out during the writeback
linux/fs/fs-writeback.c:985:		 * continuing iteration from @wb after dropping and
linux/fs/fs-writeback.c:1404:	 * Although inode's i_io_list is moved from 'tmp' to 'dispatch_queue',
linux/fs/ubifs/budget.c:508: * from @c->bi.idx_growth to @c->bi.uncommitted_idx. The latter will be zeroed
linux/fs/ubifs/master.c:399:		dbg_mnt("Auto resizing (master) from %d LEBs to %d LEBs",
linux/fs/ubifs/tnc.c:2063: * slot, zbranches starting from @n have to be moved right.
linux/fs/ubifs/tnc.c:2536: * This function deletes a leaf node from @n-th slot of @znode. Returns zero in
linux/fs/ubifs/xattr.c:187: * data from @value. Returns zero in case of success and a negative error code
linux/fs/ubifs/sb.c:765:		dbg_mnt("Auto resizing from %d LEBs to %d LEBs",
linux/fs/ubifs/lpt_commit.c:144: * This function finds the next empty LEB in the ltab starting from @lnum. If a
linux/fs/ubifs/lpt_commit.c:329: * function starting from @lnum. If a LEB is found it is returned in @lnum and
linux/fs/ubifs/lpt_commit.c:371:	from = offs;
linux/fs/ubifs/lpt_commit.c:415:			offs = from = 0;
linux/fs/ubifs/lpt_commit.c:472:			offs = from = 0;
linux/fs/ubifs/lpt_commit.c:498:			offs = from = 0;
linux/fs/ubifs/debug.c:1054:		ubifs_err(c, "free space changed from %lld to %lld",
linux/fs/ubifs/debug.c:2574:	from = get_random_u32_below(len);
linux/fs/ubifs/debug.c:2576:	to = min(len, ALIGN(from + 1, c->max_write_size));
linux/fs/ubifs/tnc_misc.c:89:		/* Walk back down to the level we came from ('level') */
linux/fs/ubifs/lpt.c:1884: * and @wr is false. For mounting from 'ro' to 'rw', @rd is false and @wr is
linux/fs/iomap/buffered-io.c:450:	first = from >> inode->i_blkbits;
linux/fs/iomap/buffered-io.c:451:	last = (from + count - 1) >> inode->i_blkbits;
linux/fs/iomap/buffered-io.c:555:	size_t from = offset_in_folio(folio, pos), to = from + len;
linux/fs/iomap/buffered-io.c:573:		    (from <= poff || from >= poff + plen) &&
linux/fs/namei.c:989: * Helper to directly jump to a known parsed path from ->get_link,
linux/fs/smb/client/inode.c:2618:	pgoff_t index = from >> PAGE_SHIFT;
linux/fs/smb/client/inode.c:2619:	unsigned offset = from & (PAGE_SIZE - 1);
linux/fs/smb/client/connect.c:2167: * cifs_get_smb_ses - get a session matching @ctx data from @server
linux/fs/smb/client/connect.c:2419: * cifs_get_tcon - get a tcon matching @ctx data from @ses
linux/fs/smb/client/file.c:2577:	if ((to > PAGE_SIZE) || (from > to)) {
linux/fs/smb/client/file.c:4771:	cifs_dbg(FYI, "write_begin from %lld len %d\n", (long long)pos, len);
linux/fs/smb/client/smb2misc.c:476:		start_of_path = from + 1;
linux/fs/smb/client/smb2misc.c:482:		start_of_path = from + 1;
linux/fs/smb/client/ntlmssp.h:68:/* to more closely match the standards document for NTLMSSP from     */
linux/fs/smb/client/cifs_unicode.c:158: * @from - source buffer
linux/fs/smb/client/cifs_unicode.c:277:	for (i = 0; len && *from; i++, from += charlen, len -= charlen) {
linux/fs/smb/client/cifs_unicode.c:577: * @from - pointer to input string
linux/fs/smb/client/cifs_unicode.c:594:	for (i = 0; len && *from; i++, from += charlen, len -= charlen) {
linux/fs/smb/client/cifspdu.h:199:#define FILE_EXECUTE          0x00000020  /*Data can be read into memory from */
linux/fs/smb/client/cifs_debug.c:684:				seq_printf(m, "  %d slow responses from %s for command %d\n",
linux/fs/smb/server/unicode.c:222:	for (i = 0; len > 0 && *from; i++, from += charlen, len -= charlen) {
linux/fs/smb/server/ntlmssp.h:85:/* to more closely match the standards document for NTLMSSP from     */
linux/fs/smb/server/smb_common.h:92:#define FILE_EXECUTE          0x00000020  /*Data can be read into memory from */
linux/fs/jffs2/nodemgmt.c:698:			jffs2_dbg(1, "Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\n",
linux/fs/jffs2/read.c:53:	jffs2_dbg(1, "Node read from %08x: node_crc %08x, calculated CRC %08x. dsize %x, csize %x, offset %x, buf %p\n",
linux/fs/jffs2/read.c:72:			pr_warn("jffs2_read_dnode() asked for %d bytes at %d from %d-byte node\n",
linux/fs/jffs2/read.c:132:		jffs2_dbg(2, "Decompress %d bytes from %p to %d bytes at %p\n",
linux/fs/jffs2/read.c:185:			jffs2_dbg(1, "Filling non-frag hole from %d-%d\n",
linux/fs/jffs2/read.c:193:			jffs2_dbg(1, "Filling frag hole from %d-%d (frag 0x%x 0x%x)\n",
linux/fs/jffs2/xattr.c:128:	JFFS2_NOTICE("xdatum_mem_usage from %u byte to %u byte (%u byte reclaimed)\n",
linux/fs/jffs2/xattr.c:1245:		dbg_xattr("xdatum (xid=%u, version=%u) GC'ed from %#08x to %08x\n",
linux/fs/jffs2/xattr.c:1279:		dbg_xattr("xref (ino=%u, xid=%u) GC'ed from %#08x to %08x\n",
linux/fs/jffs2/readinode.c:61:	dbg_readinode("check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\n",
linux/fs/jffs2/gc.c:1312:		jffs2_dbg(1, "Expanded dnode to write from (0x%x-0x%x) to (0x%x-0x%x)\n",
linux/fs/jffs2/malloc.c:220:			dbg_memalloc("Allocating new refblock linked from %p\n", p);
linux/fs/pstore/zone.c:354:				pr_err("move zone from %lu to %d failed\n",
linux/fs/pstore/inode.c:343: * Load it up with "size" bytes of data from "buf".
linux/fs/pstore/Kconfig:133:	  data can be retrieved from /sys/fs/pstore/pmsg-ramoops-[ID].
linux/fs/pstore/platform.c:799:		pr_warn("failed to create %d record(s) from '%s'\n",
linux/fs/pstore/platform.c:802:		pr_err("looping? Too many records seen from '%s'\n",
linux/ipc/util.c:551: * @flag will most probably be 0 or ``S_...UGO`` from <linux/stat.h>
linux/arch/um/include/asm/archrandom.h:7:/* This is from <os.h>, but better not to #include that in a global header here. */
linux/arch/um/include/asm/common.lds.S:75:     from .altinstructions and .eh_frame */
linux/arch/um/kernel/load_file.c:22:		printk(KERN_ERR "Read of %d bytes from '%s' failed, "
linux/arch/um/kernel/skas/uaccess.c:155:	unsigned long *from_ptr = arg, from = *from_ptr;
linux/arch/um/os-Linux/mem.c:21: * kasan_map_memory - maps memory from @start with a size of @len.
linux/arch/um/os-Linux/execvp.c:38:   no slashes, with arguments ARGV and environment from `environ'.  */
linux/arch/um/Kconfig:127:	  might otherwise unexpected use libraries from /lib or /lib64
linux/arch/um/drivers/line.c:147:			 * We have flushed from ->head to buffer end, now we
linux/arch/parisc/include/asm/io.h:243: * These get provided from <asm-generic/iomap.h> since parisc does not
linux/arch/parisc/include/asm/alternative.h:48:	.word (from - .)		!	\
linux/arch/parisc/include/asm/alternative.h:56:	.word (from - .)		!	\
linux/arch/parisc/include/asm/pdcpat.h:118:#define PDC_PAT_IO_GET_LOC_FROM_HARDWARE 6L /* Get Physical Location from */
linux/arch/parisc/include/asm/pdcpat.h:120:#define PDC_PAT_IO_GET_HARDWARE_FROM_LOC 7L /* Get Hardware Path from 
linux/arch/parisc/include/asm/kexec.h:5:/* Maximum physical address we can use pages from */
linux/arch/parisc/include/uapi/asm/ioctl.h:5: *    portions from "linux/ioctl.h for Linux" by H.H. Bergman.
linux/arch/parisc/kernel/alternative.c:52:		from = (u32 *)((ulong)&entry->orig_offset + entry->orig_offset);
linux/arch/parisc/kernel/alternative.c:94:			*from = replacement;
linux/arch/parisc/kernel/firmware.c:1691: * pdc_pat_mem_read_cell_pdt - Read PDT entries from (old) PAT firmware
linux/arch/parisc/kernel/firmware.c:1722: * pdc_pat_mem_read_pd_pdt - Read PDT entries from (newer) PAT firmware
linux/arch/arm64/include/asm/tlbflush.h:154: * Generate 'num' values from -1 to 30 with -1 rejected by the
linux/arch/arm64/include/asm/tlbflush.h:321:	 *    ((num+1)*2^(5*scale+1) starting from 'addr'), then increase it
linux/arch/arm64/include/asm/kvm_asm.h:246:	"	.long		(" #from " - .), (" #to " - .)\n"	\
linux/arch/arm64/include/asm/kvm_asm.h:305:	.long		(\from - .), (\to - .)
linux/arch/arm64/include/asm/ptrace.h:264: * regs_get_register returns the value of a register whose offset from @regs.
linux/arch/arm64/include/asm/asm-prototypes.h:10: * ... kbuild will automatically pick these up from <asm/asm-prototypes.h> and
linux/arch/arm64/include/asm/kexec.h:12:/* Maximum physical address we can use pages from */
linux/arch/arm64/include/asm/pgtable.h:575: * and merging of writes.  This is different from "Device-nGnR[nE]" memory which
linux/arch/arm64/kernel/patch-scs.c:153:	 * Starting from 'loc', apply the CFA opcodes that advance the location
linux/arch/arm64/kernel/io.c:26:		from += 8;
linux/arch/arm64/kernel/io.c:41: * Copy data from "real" memory space to IO memory space.
linux/arch/arm64/kernel/io.c:54:		from += 8;
linux/arch/arm64/kvm/mmu.c:505:		phys_addr = kvm_kaddr_to_phys(from + virt_addr - start);
linux/arch/arm64/kvm/hyp/nvhe/gen-hyprel.c:324: * the beginning of the relocated section + the offset from `rela`.
linux/arch/arm64/kvm/arm.c:1565:/* unlocks vcpus from @vcpu_lock_idx and smaller */
linux/arch/arm64/lib/copy_template.S:102:	* bytes from (src-16) to (dst-16) and to backward the src to aligned
linux/arch/arm64/lib/strlen.S:189:	/* Load 16 bytes from [srcin & ~15] and force the bytes that precede
linux/arch/arm64/boot/dts/rockchip/rk3399-sapphire.dtsi:42:	 * from  R90030 DNP R0805 pin2  to  C90002 10uF C0805 pin1 (vcc_sys).
linux/arch/arm64/boot/dts/hisilicon/hi3670-hikey970.dts:68: * Line names are taken from "hikey970-schematics.pdf" from HiSilicon.
linux/arch/arm64/boot/dts/hisilicon/hi3660-hikey960.dts:212: * Line names are taken from "HiKey 960 Board ver A" schematics
linux/arch/arm64/mm/fault.c:419:	 * not caused by memory type" from "alignment fault caused by memory
linux/arch/arm64/net/bpf_jit_comp.c:211:	int from = ctx->idx;
linux/arch/arm64/net/bpf_jit_comp.c:2043:/* Replace the branch instruction from @ip to @old_addr in a bpf prog or a bpf
linux/arch/arm64/net/bpf_jit_comp.c:2044: * trampoline with the branch instruction from @ip to @new_addr. If @old_addr
linux/arch/alpha/include/asm/io.h:661: * These get provided from <asm-generic/iomap.h> since alpha does not
linux/arch/alpha/include/asm/xor.h:73:	xor $0,$1,$0		# 7 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:130:	xor $0,$1,$1		# 8 cycles from $0 load		\n\
linux/arch/alpha/include/asm/xor.h:131:	xor $3,$4,$4		# 6 cycles from $4 load		\n\
linux/arch/alpha/include/asm/xor.h:132:	xor $6,$7,$7		# 6 cycles from $7 load		\n\
linux/arch/alpha/include/asm/xor.h:133:	xor $21,$22,$22		# 5 cycles from $22 load	\n\
linux/arch/alpha/include/asm/xor.h:135:	xor $1,$2,$2		# 9 cycles from $2 load		\n\
linux/arch/alpha/include/asm/xor.h:136:	xor $24,$25,$25		# 5 cycles from $25 load	\n\
linux/arch/alpha/include/asm/xor.h:138:	xor $4,$5,$5		# 6 cycles from $5 load		\n\
linux/arch/alpha/include/asm/xor.h:141:	xor $7,$20,$20		# 7 cycles from $20 load	\n\
linux/arch/alpha/include/asm/xor.h:143:	xor $22,$23,$23		# 7 cycles from $23 load	\n\
linux/arch/alpha/include/asm/xor.h:146:	xor $25,$27,$27		# 7 cycles from $27 load	\n\
linux/arch/alpha/include/asm/xor.h:161:	xor $0,$1,$1		# 4 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:162:	xor $3,$4,$4		# 5 cycles from $4 load		\n\
linux/arch/alpha/include/asm/xor.h:163:	xor $6,$7,$7		# 5 cycles from $7 load		\n\
linux/arch/alpha/include/asm/xor.h:165:	xor $1,$2,$2		# 4 cycles from $2 load		\n\
linux/arch/alpha/include/asm/xor.h:166:	xor $4,$5,$5		# 5 cycles from $5 load		\n\
linux/arch/alpha/include/asm/xor.h:168:	xor $7,$20,$20		# 4 cycles from $20 load	\n\
linux/arch/alpha/include/asm/xor.h:204:	xor $0,$1,$1		# 6 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:206:	xor $2,$3,$3		# 6 cycles from $3 load		\n\
linux/arch/alpha/include/asm/xor.h:211:	xor $4,$5,$5		# 7 cycles from $5 load		\n\
linux/arch/alpha/include/asm/xor.h:215:	xor $21,$22,$22		# 7 cycles from $22 load	\n\
linux/arch/alpha/include/asm/xor.h:219:	xor $23,$24,$24		# 7 cycles from $24 load	\n\
linux/arch/alpha/include/asm/xor.h:226:	xor $25,$27,$27		# 8 cycles from $27 load	\n\
linux/arch/alpha/include/asm/xor.h:234:	xor $0,$1,$1		# 9 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:235:	xor $2,$3,$3		# 5 cycles from $3 load		\n\
linux/arch/alpha/include/asm/xor.h:239:	xor $4,$5,$5		# 5 cycles from $5 load		\n\
linux/arch/alpha/include/asm/xor.h:250:	xor $6,$7,$7		# 8 cycles from $6 load		\n\
linux/arch/alpha/include/asm/xor.h:254:	xor $21,$22,$22		# 8 cycles from $22 load	\n\
linux/arch/alpha/include/asm/xor.h:256:	xor $23,$24,$24		# 5 cycles from $24 load	\n\
linux/arch/alpha/include/asm/xor.h:259:	xor $25,$27,$27		# 5 cycles from $27 load	\n\
linux/arch/alpha/include/asm/xor.h:261:	xor $0,$1,$1		# 5 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:264:	xor $2,$3,$3		# 4 cycles from $3 load		\n\
linux/arch/alpha/include/asm/xor.h:301:	xor $0,$1,$1		# 6 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:303:	xor $2,$3,$3		# 6 cycles from $3 load		\n\
linux/arch/alpha/include/asm/xor.h:308:	xor $3,$4,$4		# 7 cycles from $4 load		\n\
linux/arch/alpha/include/asm/xor.h:311:	xor $5,$6,$6		# 7 cycles from $6 load		\n\
linux/arch/alpha/include/asm/xor.h:312:	xor $7,$22,$22		# 7 cycles from $22 load	\n\
linux/arch/alpha/include/asm/xor.h:313:	xor $6,$23,$23		# 7 cycles from $23 load	\n\
linux/arch/alpha/include/asm/xor.h:318:	xor $24,$25,$25		# 8 cycles from $25 load	\n\
linux/arch/alpha/include/asm/xor.h:321:	xor $25,$27,$27		# 8 cycles from $27 load	\n\
linux/arch/alpha/include/asm/xor.h:323:	xor $28,$0,$0		# 7 cycles from $0 load		\n\
linux/arch/alpha/include/asm/xor.h:331:	xor $1,$2,$2		# 6 cycles from $2 load		\n\
linux/arch/alpha/include/asm/xor.h:333:	xor $3,$4,$4		# 4 cycles from $4 load		\n\
linux/arch/alpha/include/asm/xor.h:343:	xor $4,$5,$5		# 7 cycles from $5 load		\n\
linux/arch/alpha/include/asm/xor.h:346:	xor $6,$7,$7		# 7 cycles from $7 load		\n\
linux/arch/alpha/include/asm/xor.h:351:	xor $7,$22,$22		# 7 cycles from $22 load	\n\
linux/arch/alpha/include/asm/xor.h:353:	xor $23,$24,$24		# 6 cycles from $24 load	\n\
linux/arch/alpha/include/asm/xor.h:358:	xor $25,$27,$27		# 7 cycles from $27 load	\n\
linux/arch/alpha/include/asm/xor.h:361:	xor $27,$28,$28		# 8 cycles from $28 load	\n\
linux/arch/alpha/include/asm/xor.h:363:	xor $0,$1,$1		# 6 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:371:	xor $2,$3,$3		# 9 cycles from $3 load		\n\
linux/arch/alpha/include/asm/xor.h:372:	xor $3,$4,$4		# 9 cycles from $4 load		\n\
linux/arch/alpha/include/asm/xor.h:373:	xor $5,$6,$6		# 8 cycles from $6 load		\n\
linux/arch/alpha/include/asm/xor.h:377:	xor $7,$22,$22		# 7 cycles from $22 load	\n\
linux/arch/alpha/include/asm/xor.h:378:	xor $23,$24,$24		# 6 cycles from $24 load	\n\
linux/arch/alpha/include/asm/xor.h:383:	xor $24,$25,$25		# 8 cycles from $25 load	\n\
linux/arch/alpha/include/asm/xor.h:436:	xor $0,$1,$0		# 8 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:508:	xor $0,$1,$1		# 8 cycles from $0 load		\n\
linux/arch/alpha/include/asm/xor.h:509:	xor $3,$4,$4		# 7 cycles from $4 load		\n\
linux/arch/alpha/include/asm/xor.h:510:	xor $6,$7,$7		# 6 cycles from $7 load		\n\
linux/arch/alpha/include/asm/xor.h:511:	xor $21,$22,$22		# 5 cycles from $22 load	\n\
linux/arch/alpha/include/asm/xor.h:513:	xor $1,$2,$2		# 9 cycles from $2 load		\n\
linux/arch/alpha/include/asm/xor.h:514:	xor $24,$25,$25		# 5 cycles from $25 load	\n\
linux/arch/alpha/include/asm/xor.h:516:	xor $4,$5,$5		# 6 cycles from $5 load		\n\
linux/arch/alpha/include/asm/xor.h:519:	xor $7,$20,$20		# 7 cycles from $20 load	\n\
linux/arch/alpha/include/asm/xor.h:521:	xor $22,$23,$23		# 7 cycles from $23 load	\n\
linux/arch/alpha/include/asm/xor.h:524:	xor $25,$27,$27		# 7 cycles from $27 load	\n\
linux/arch/alpha/include/asm/xor.h:543:	xor $0,$1,$1		# 6 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:544:	xor $3,$4,$4		# 5 cycles from $4 load		\n\
linux/arch/alpha/include/asm/xor.h:545:	xor $6,$7,$7		# 5 cycles from $7 load		\n\
linux/arch/alpha/include/asm/xor.h:546:	xor $1,$2,$2		# 4 cycles from $2 load		\n\
linux/arch/alpha/include/asm/xor.h:548:	xor $4,$5,$5		# 5 cycles from $5 load		\n\
linux/arch/alpha/include/asm/xor.h:549:	xor $7,$20,$20		# 4 cycles from $20 load	\n\
linux/arch/alpha/include/asm/xor.h:606:	xor $0,$1,$1		# 6 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:608:	xor $2,$3,$3		# 6 cycles from $3 load		\n\
linux/arch/alpha/include/asm/xor.h:613:	xor $4,$5,$5		# 7 cycles from $5 load		\n\
linux/arch/alpha/include/asm/xor.h:617:	xor $21,$22,$22		# 7 cycles from $22 load	\n\
linux/arch/alpha/include/asm/xor.h:621:	xor $23,$24,$24		# 7 cycles from $24 load	\n\
linux/arch/alpha/include/asm/xor.h:628:	xor $25,$27,$27		# 8 cycles from $27 load	\n\
linux/arch/alpha/include/asm/xor.h:636:	xor $0,$1,$1		# 9 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:637:	xor $2,$3,$3		# 5 cycles from $3 load		\n\
linux/arch/alpha/include/asm/xor.h:641:	xor $4,$5,$5		# 5 cycles from $5 load		\n\
linux/arch/alpha/include/asm/xor.h:653:	xor $6,$7,$7		# 8 cycles from $6 load		\n\
linux/arch/alpha/include/asm/xor.h:656:	xor $21,$22,$22		# 8 cycles from $22 load	\n\
linux/arch/alpha/include/asm/xor.h:661:	xor $23,$24,$24		# 6 cycles from $24 load	\n\
linux/arch/alpha/include/asm/xor.h:663:	xor $25,$27,$27		# 6 cycles from $27 load	\n\
linux/arch/alpha/include/asm/xor.h:667:	xor $0,$1,$1		# 7 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:668:	xor $2,$3,$3		# 6 cycles from $3 load		\n\
linux/arch/alpha/include/asm/xor.h:732:	xor $0,$1,$1		# 6 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:734:	xor $2,$3,$3		# 6 cycles from $3 load		\n\
linux/arch/alpha/include/asm/xor.h:739:	xor $3,$4,$4		# 7 cycles from $4 load		\n\
linux/arch/alpha/include/asm/xor.h:742:	xor $5,$6,$6		# 7 cycles from $6 load		\n\
linux/arch/alpha/include/asm/xor.h:743:	xor $7,$22,$22		# 7 cycles from $22 load	\n\
linux/arch/alpha/include/asm/xor.h:744:	xor $6,$23,$23		# 7 cycles from $23 load	\n\
linux/arch/alpha/include/asm/xor.h:749:	xor $24,$25,$25		# 8 cycles from $25 load	\n\
linux/arch/alpha/include/asm/xor.h:752:	xor $25,$27,$27		# 8 cycles from $27 load	\n\
linux/arch/alpha/include/asm/xor.h:754:	xor $28,$0,$0		# 7 cycles from $0 load		\n\
linux/arch/alpha/include/asm/xor.h:762:	xor $1,$2,$2		# 6 cycles from $2 load		\n\
linux/arch/alpha/include/asm/xor.h:764:	xor $3,$4,$4		# 4 cycles from $4 load		\n\
linux/arch/alpha/include/asm/xor.h:774:	xor $4,$5,$5		# 7 cycles from $5 load		\n\
linux/arch/alpha/include/asm/xor.h:777:	xor $6,$7,$7		# 7 cycles from $7 load		\n\
linux/arch/alpha/include/asm/xor.h:782:	xor $7,$22,$22		# 7 cycles from $22 load	\n\
linux/arch/alpha/include/asm/xor.h:784:	xor $23,$24,$24		# 6 cycles from $24 load	\n\
linux/arch/alpha/include/asm/xor.h:789:	xor $25,$27,$27		# 7 cycles from $27 load	\n\
linux/arch/alpha/include/asm/xor.h:792:	xor $27,$28,$28		# 8 cycles from $28 load	\n\
linux/arch/alpha/include/asm/xor.h:794:	xor $0,$1,$1		# 6 cycles from $1 load		\n\
linux/arch/alpha/include/asm/xor.h:804:	xor $2,$3,$3		# 9 cycles from $3 load		\n\
linux/arch/alpha/include/asm/xor.h:807:	xor $3,$4,$4		# 9 cycles from $4 load		\n\
linux/arch/alpha/include/asm/xor.h:809:	xor $5,$6,$6		# 8 cycles from $6 load		\n\
linux/arch/alpha/include/asm/xor.h:813:	xor $7,$22,$22		# 7 cycles from $22 load	\n\
linux/arch/alpha/include/asm/xor.h:814:	xor $23,$24,$24		# 6 cycles from $24 load	\n\
linux/arch/alpha/include/asm/xor.h:819:	xor $24,$25,$25		# 8 cycles from $25 load	\n\
linux/arch/alpha/kernel/sys_marvel.c:357:		printk("  reporting on %d IRQ(s) from %d (0x%x)\n", 
linux/arch/alpha/kernel/err_ev6.c:158:		printk("%s    %s-STREAM %s-BIT ECC error from %s\n",
linux/arch/alpha/kernel/smp.c:258: 		DBGS(("recv_secondary_console_msg: on %d from %d"
linux/arch/alpha/kernel/io.c:489:	if (count >= 8 && ((u64)to & 7) == ((u64)from & 7)) {
linux/arch/alpha/kernel/io.c:495:			from += 8;
linux/arch/alpha/kernel/io.c:500:	if (count >= 4 && ((u64)to & 3) == ((u64)from & 3)) {
linux/arch/alpha/kernel/io.c:506:			from += 4;
linux/arch/alpha/kernel/io.c:511:	if (count >= 2 && ((u64)to & 1) == ((u64)from & 1)) {
linux/arch/alpha/kernel/io.c:517:			from += 2;
linux/arch/alpha/kernel/io.c:535: * Copy data from "real" memory space to IO memory space.
linux/arch/alpha/kernel/io.c:544:	if (count >= 8 && ((u64)to & 7) == ((u64)from & 7)) {
linux/arch/alpha/kernel/io.c:550:			from += 8;
linux/arch/alpha/kernel/io.c:555:	if (count >= 4 && ((u64)to & 3) == ((u64)from & 3)) {
linux/arch/alpha/kernel/io.c:561:			from += 4;
linux/arch/alpha/kernel/io.c:566:	if (count >= 2 && ((u64)to & 1) == ((u64)from & 1)) {
linux/arch/alpha/kernel/io.c:572:			from += 2;
linux/arch/alpha/kernel/pci_iommu.c:220:	DBGA("pci_dac_dma_supported %s from %ps\n",
linux/arch/alpha/kernel/pci_iommu.c:252:		DBGA2("pci_map_single: [%p,%zx] -> direct %llx from %ps\n",
linux/arch/alpha/kernel/pci_iommu.c:263:		DBGA2("pci_map_single: [%p,%zx] -> DAC %llx from %ps\n",
linux/arch/alpha/kernel/pci_iommu.c:300:	DBGA2("pci_map_single: [%p,%zx] np %ld -> sg %llx from %ps\n",
linux/arch/alpha/kernel/pci_iommu.c:367:		DBGA2("pci_unmap_single: direct [%llx,%zx] from %ps\n",
linux/arch/alpha/kernel/pci_iommu.c:374:		DBGA2("pci64_unmap_single: DAC [%llx,%zx] from %ps\n",
linux/arch/alpha/kernel/pci_iommu.c:406:	DBGA2("pci_unmap_single: sg [%llx,%zx] np %ld from %ps\n",
linux/arch/alpha/kernel/pci_iommu.c:429:		       "get_free_pages failed from %ps\n",
linux/arch/alpha/kernel/pci_iommu.c:448:	DBGA2("pci_alloc_consistent: %zx -> [%p,%llx] from %ps\n",
linux/arch/alpha/kernel/pci_iommu.c:468:	DBGA2("pci_free_consistent: [%llx,%zx] from %ps\n",
linux/arch/alpha/kernel/setup.c:266:        char *from = s;
linux/arch/alpha/kernel/setup.c:269:        if ( *from == 'K' || *from == 'k' ) {
linux/arch/alpha/kernel/setup.c:272:        } else if ( *from == 'M' || *from == 'm' ) {
linux/arch/alpha/kernel/setup.c:275:        } else if ( *from == 'G' || *from == 'g' ) {
linux/arch/alpha/kernel/setup.c:357:		printk("setup: forcing memory size to %ldK (from %ldK).\n",
linux/arch/alpha/kernel/setup.c:591:	       "on %s%s%s using machine vector %s from %s\n",
linux/arch/alpha/boot/tools/objstrip.c:234:	fprintf(stderr, "%s: copying %lu byte from %s\n",
linux/arch/x86/um/shared/sysdep/tls.h:7:/* Change name to avoid conflicts with the original one from <asm/ldt.h>, which
linux/arch/x86/um/ptrace_64.c:208:			printk("is_syscall : failed to read instruction from "
linux/arch/x86/um/signal.c:103:	from = (struct _fpxreg *) &fxsave->st_space[0];
linux/arch/x86/um/signal.c:137:	from = &buf->_st[0];
linux/arch/x86/include/asm/atomic64_32.h:195: * Atomically subtracts @i from @v.
linux/arch/x86/include/asm/io.h:383:	const u8 *from = src;
linux/arch/x86/include/asm/io.h:384:	const u8 *end = from + count * 64;
linux/arch/x86/include/asm/io.h:386:	while (from < end) {
linux/arch/x86/include/asm/io.h:388:		from += 64;
linux/arch/x86/include/asm/string_32.h:71:		*((char *)to + 2) = *((char *)from + 2);
linux/arch/x86/include/asm/string_32.h:75:		*((char *)to + 4) = *((char *)from + 4);
linux/arch/x86/include/asm/string_32.h:79:		*((short *)to + 2) = *((short *)from + 2);
linux/arch/x86/include/asm/string_32.h:83:		*((int *)to + 1) = *((int *)from + 1);
linux/arch/x86/include/asm/processor.h:217: * Note that while the legacy 'TSS' name comes from 'Task State Segment',
linux/arch/x86/include/asm/atomic.h:63: * Atomically subtracts @i from @v.
linux/arch/x86/include/asm/atomic.h:77: * Atomically subtracts @i from @v and returns
linux/arch/x86/include/asm/atomic.h:174: * Atomically subtracts @i from @v and returns @v - @i
linux/arch/x86/include/asm/atomic64_64.h:56: * Atomically subtracts @i from @v.
linux/arch/x86/include/asm/atomic64_64.h:70: * Atomically subtracts @i from @v and returns
linux/arch/x86/include/asm/asm.h:185:	" .long (" #from ") - .\n"				\
linux/arch/x86/include/asm/asm.h:193:	" .long (" #from ") - .\n"						\
linux/arch/x86/include/asm/user_32.h:27:   backtrace.  We need to write the data from (esp) to
linux/arch/x86/include/asm/kexec.h:40:/* Maximum physical address we can use pages from */
linux/arch/x86/include/asm/kexec.h:55:/* Maximum physical address we can use pages from */
linux/arch/x86/include/asm/efi.h:20: * with preserved alignment on virtual addresses starting from -4G down
linux/arch/x86/include/asm/user_64.h:29:   backtrace.  We need to write the data from (esp) to
linux/arch/x86/include/asm/local.h:50: * Atomically subtracts @i from @l and returns
linux/arch/x86/kernel/tsc.c:876:	pr_warn("PIT calibration deviates from %s: %lu %lu\n",
linux/arch/x86/kernel/e820.c:951:		enum e820_type from = 0, to = 0;
linux/arch/x86/kernel/e820.c:955:			from = simple_strtoull(p + 1, &p, 0);
linux/arch/x86/kernel/e820.c:960:		if (from && to)
linux/arch/x86/kernel/vmlinux.lds.S:351:	 *  references from .altinstructions
linux/arch/x86/kernel/acpi/boot.c:684:	pr_warn("setting ELCR to %04x (from %04x)\n", new, old);
linux/arch/x86/kernel/vm86_32.c:228:		pr_info_once("Denied a call to vm86(old) from %s[%d] (uid: %d).  Set the vm.mmap_min_addr sysctl to 0 and/or adjust LSM mmap_min_addr policy to enable vm86 if you are using a vm86-based DOS emulator.\n",
linux/arch/x86/kernel/cpu/resctrl/rdtgroup.c:2670:		if (!from || is_closid_match(t, from) ||
linux/arch/x86/kernel/cpu/hypervisor.c:87:	const void * const *from = (const void * const *)src;
linux/arch/x86/kernel/kprobes/opt.c:132:			/* And pop flags register from 'regs->ss'. */
linux/arch/x86/kernel/kprobes/opt.c:156:			/* And pop flags register from 'regs->ss'. */
linux/arch/x86/kernel/setup.c:278:	printk(KERN_INFO "Move RAMDISK from [mem %#010llx-%#010llx] to"
linux/arch/x86/kernel/bootflag.c:88:		printk(KERN_WARNING "Simple Boot Flag value 0x%x read from "
linux/arch/x86/kernel/uprobes.c:449:	 * Change modrm from "00 reg 101" to "10 reg reg2". Example:
linux/arch/x86/kernel/mpparse.c:911:			/* steal 16 bytes from [0, 1k) */
linux/arch/x86/kernel/fpu/regset.c:254:	struct _fpxreg *from = (struct _fpxreg *) &fxsave->st_space[0];
linux/arch/x86/kernel/fpu/regset.c:296:	struct _fpreg *from = (struct _fpreg *) &env->st_space[0];
linux/arch/x86/kernel/fpu/xstate.c:1131:	 * remove them from 'mask' to zero those features in the user
linux/arch/x86/kernel/fpu/core.c:158:		 * allocation of the larger FPU buffer lazy from #NM or if
linux/arch/x86/kernel/ioport.c:71:	if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
linux/arch/x86/kvm/vmx/vmenter.S:164:	/* Check EFLAGS.ZF from 'test VMX_RUN_VMRESUME' above */
linux/arch/x86/kvm/vmx/nested.c:5302:	 * nothing KVM has to do to transition it from 'active' to 'non-active'
linux/arch/x86/kvm/vmx/pmu_intel.c:184:		(index >= records->from && index < records->from + records->nr) ||
linux/arch/x86/kvm/vmx/pmu_intel.c:719:		vmx_set_intercept_for_msr(vcpu, lbr->from + i, MSR_TYPE_RW, set);
linux/arch/x86/kvm/vmx/posted_intr.c:173:	 * try_to_wake_up() from ->sched_out() isn't allowed (IRQs are not
linux/arch/x86/kvm/hyperv.c:1821:	 * either offset in bytes from 'ingpa' for regular hypercalls or the
linux/arch/x86/kvm/mmu/spte.h:386: * To differentiate #1 and #4 from #2 and #3, KVM uses two software-only bits
linux/arch/x86/kvm/mmu/paging_tmpl.h:483:	 * [7:8] - Derived from [7:8] of real exit_qualification
linux/arch/x86/crypto/sha1_avx2_x86_64_asm.S:65: *Updates 20-byte SHA-1 record at start of 'state', from 'input', for
linux/arch/x86/events/intel/p4.c:894:	 * but completely nonsense from "meaning" of such action.
linux/arch/x86/events/intel/pt.c:1642:	unsigned long from = 0, to;
linux/arch/x86/events/intel/pt.c:1666:		from = buf->nr_pages << PAGE_SHIFT;
linux/arch/x86/events/intel/pt.c:1667:	from += to - size;
linux/arch/x86/events/intel/ds.c:1441:	unsigned long from = cpuc->lbr_entries[0].from;
linux/arch/x86/events/intel/ds.c:1457:	if (!cpuc->lbr_stack.nr || !from || !to)
linux/arch/x86/events/intel/lbr.c:345:	u64 from = rdlbr_from(idx, NULL);
linux/arch/x86/events/intel/lbr.c:351:	lbr->from = from;
linux/arch/x86/events/intel/lbr.c:487:		entries[x86_pmu.lbr_nr - 1].from = 0;
linux/arch/x86/events/intel/lbr.c:764:		from = rdlbr_from(lbr_idx, NULL);
linux/arch/x86/events/intel/lbr.c:791:				mis = !!(from & LBR_FROM_FLAG_MISPRED);
linux/arch/x86/events/intel/lbr.c:796:				in_tx = !!(from & LBR_FROM_FLAG_IN_TX);
linux/arch/x86/events/intel/lbr.c:797:				abort = !!(from & LBR_FROM_FLAG_ABORT);
linux/arch/x86/events/intel/lbr.c:800:			from = (u64)((((s64)from) << skip) >> skip);
linux/arch/x86/events/intel/lbr.c:881:		from = rdlbr_from(i, lbr);
linux/arch/x86/events/intel/lbr.c:1137:		from = cpuc->lbr_entries[i].from;
linux/arch/x86/events/intel/lbr.c:1161:			cpuc->lbr_entries[i].from = 0;
linux/arch/x86/events/intel/lbr.c:1610:	lbr->from = x86_pmu.lbr_from;
linux/arch/x86/events/amd/lbr.c:111:		from = cpuc->lbr_entries[i].from;
linux/arch/x86/events/amd/lbr.c:121:			cpuc->lbr_entries[i].from += offset;
linux/arch/x86/events/amd/lbr.c:128:			cpuc->lbr_entries[i].from = 0;	/* mark invalid */
linux/arch/x86/events/amd/brs.c:348:		br[nr].from = from;
linux/arch/x86/events/utils.c:108:	if (from == 0 || to == 0)
linux/arch/x86/mm/numa.c:156: * Remove @idx'th numa_memblk from @mi by shifting @mi->blk[] and
linux/arch/x86/mm/numa.c:425:	if (from >= numa_distance_cnt || to >= numa_distance_cnt ||
linux/arch/x86/mm/numa.c:426:			from < 0 || to < 0) {
linux/arch/x86/mm/numa.c:433:	    (from == to && distance != LOCAL_DISTANCE)) {
linux/arch/x86/mm/numa.c:439:	numa_distance[from * numa_distance_cnt + to] = distance;
linux/arch/x86/mm/numa.c:444:	if (from >= numa_distance_cnt || to >= numa_distance_cnt)
linux/arch/x86/mm/numa.c:445:		return from == to ? LOCAL_DISTANCE : REMOTE_DISTANCE;
linux/arch/x86/mm/numa.c:446:	return numa_distance[from * numa_distance_cnt + to];
linux/arch/x86/mm/numa_emulation.c:43: * Sets up nid to range from @start to @end.  The return value is -errno if
linux/arch/x86/mm/init.c:571: * create direct mappings for all pfns from [0 to max_low_pfn) and
linux/arch/x86/mm/fault.c:1154: * space.  Might get called for faults that originate from *code* that
linux/arch/x86/mm/pat/memtype.c:804:	u64 from = ((u64)pfn) << PAGE_SHIFT;
linux/arch/x86/mm/pat/memtype.c:805:	u64 to = from + size;
linux/arch/x86/platform/efi/efi_64.c:53: * We allocate runtime services regions top-down, starting from -4G, i.e.
linux/arch/x86/entry/vdso/extable.h:23:	".long (" #from ") - __ex_table\n"      \
linux/arch/x86/entry/entry_64.S:1266:	 * | iret SS          } Copied from "outermost" frame        |
linux/arch/x86/entry/entry_64.S:1334:	/* Compare the NMI stack (rdx) with the stack we came from (4*8(%rsp)) */
linux/arch/x86/xen/apic.c:194:	pr_info("Switched APIC routing from %s to %s.\n", apic->name,
linux/arch/x86/xen/platform-pci-unplug.c:168:					"from /dev/hd[a-d] to /dev/xvd[a-d]\n"
linux/arch/x86/xen/setup.c:688:		from = early_memremap(src - src_off, src_len + src_off);
linux/arch/x86/xen/setup.c:883:		pr_info("initrd moved from [mem %#010llx-%#010llx] to [mem %#010llx-%#010llx]\n",
linux/arch/m68k/include/asm/user.h:26:   backtrace.  We need to write the data from (esp) to
linux/arch/m68k/include/asm/math-emu.h:194: * (derived from <asm/uaccess.h>)
linux/arch/m68k/include/asm/kexec.h:7:/* Maximum physical address we can use pages from */
linux/arch/m68k/include/asm/mac_via.h:129: *      The below info is from 'Macintosh Family Hardware.'
linux/arch/m68k/ifpsp060/src/isp.S:1977:#	(1) save 'Z' bit from (Rn - lo)
linux/arch/m68k/ifpsp060/src/isp.S:1978:#	(2) save 'Z' and 'N' bits from ((hi - lo) - (Rn - hi))
linux/arch/m68k/ifpsp060/src/isp.S:2437:	bsr.l		_dmem_read_long		# fetch divisor from <ea>
linux/arch/m68k/ifpsp060/src/pfpsp.S:3848:#	_dcalc_ea(): calc correct <ea> from <ea> stacked on exception	#
linux/arch/m68k/ifpsp060/src/fplsp.S:7121:	fmov.x		(%a0),%fp0		# load input from (a0)
linux/arch/m68k/ifpsp060/src/fplsp.S:7218:	fmov.x		(%a0),%fp0		# load input from (a0)
linux/arch/m68k/ifpsp060/src/fplsp.S:7286:	fmov.x		(%a0),%fp0		# load input from (a0)
linux/arch/m68k/ifpsp060/src/ilsp.S:905:#	(1) save 'Z' bit from (Rn - lo)
linux/arch/m68k/ifpsp060/src/ilsp.S:906:#	(2) save 'Z' and 'N' bits from ((hi - lo) - (Rn - hi))
linux/arch/m68k/ifpsp060/src/fpsp.S:7227:	fmov.x		(%a0),%fp0		# load input from (a0)
linux/arch/m68k/ifpsp060/src/fpsp.S:7324:	fmov.x		(%a0),%fp0		# load input from (a0)
linux/arch/m68k/ifpsp060/src/fpsp.S:7392:	fmov.x		(%a0),%fp0		# load input from (a0)
linux/arch/m68k/ifpsp060/src/fpsp.S:19335:#	_dcalc_ea(): calc correct <ea> from <ea> stacked on exception	#
linux/arch/m68k/kernel/ints.c:168:	pr_warn("unexpected interrupt from %u\n", regs->vector);
linux/arch/m68k/kernel/traps.c:947:	printk("%sStack from %08lx:", loglvl, (unsigned long)stack);
linux/arch/m68k/sun3/sun3dvma.c:298:	pr_debug("dvma_map request %08x bytes from %08lx\n", len, kaddr);
linux/arch/m68k/mvme147/config.c:5: *  Cloned from        Richard Hirst [richard@sleepie.demon.co.uk]
linux/arch/m68k/lib/memcpy.c:22:		from = cfrom;
linux/arch/m68k/lib/memcpy.c:26:	if ((long)from & 1) {
linux/arch/m68k/lib/memcpy.c:39:		from = sfrom;
linux/arch/m68k/lib/memcpy.c:73:		from = lfrom;
linux/arch/m68k/lib/memcpy.c:80:		from = sfrom;
linux/arch/m68k/fpsp040/setox.S:481:	fmovex		(%a0),%fp0	| ...load input from (a0)
linux/arch/m68k/fpsp040/setox.S:582:	fmovex		(%a0),%fp0	| ...load input from (a0)
linux/arch/m68k/fpsp040/setox.S:648:	fmovex		(%a0),%fp0	| ...load input from (a0)
linux/arch/ia64/include/asm/kexec.h:7:/* Maximum physical address we can use pages from */
linux/arch/ia64/kernel/palinfo.c:848:		printk(KERN_ERR "palinfo: remote CPU call from %d to %d on function %d: "
linux/arch/ia64/kernel/iosapic.c:606:			       "%s: changing vector %d from %s to %s\n",
linux/arch/ia64/kernel/mca.c:1925:			printk(KERN_INFO "Increasing MCA rendezvous timeout from "
linux/arch/ia64/kernel/ptrace.c:1494:		from = dst->pos;
linux/arch/ia64/kernel/ptrace.c:1495:		to = from + sizeof(tmp);
linux/arch/ia64/kernel/ptrace.c:1505:		for (n = 0; from < dst->pos; from += sizeof(elf_greg_t), n++)
linux/arch/ia64/kernel/kprobes.c:71:	brl = (bundle_t *) ((u64) from & ~0xf);
linux/arch/ia64/kernel/mca_drv.c:256:	 * (arranged from "int ia64_log_platform_info_print()")
linux/arch/ia64/pci/pci.c:480: * Simply reads @size bytes from @port and puts the result in @val.
linux/arch/ia64/pci/pci.c:513: * @size: number of bytes to write from @val
linux/arch/ia64/lib/copy_user.S:387:	// No matter where we come from (loop or test) the src1 pointer
linux/arch/ia64/lib/copy_user.S:550:.failure_in1bis:		// from (.failure_in3)
linux/arch/ia64/lib/io.c:23: * Copy data from "real" memory space to IO memory space.
linux/arch/loongarch/include/asm/kexec.h:14:/* Maximum physical address we can use pages from */
linux/arch/loongarch/include/asm/percpu.h:12: * The "address" (in fact, offset from $r21) of a per-CPU variable is close to
linux/arch/loongarch/include/asm/local.h:99: * Atomically subtracts @i from @l and returns
linux/arch/loongarch/kernel/io.c:23:		from += 8;
linux/arch/loongarch/kernel/io.c:38: * Copy data from "real" memory space to IO memory space.
linux/arch/loongarch/kernel/io.c:51:		from += 8;
linux/arch/loongarch/kernel/acpi.c:203:	if ((u8)distance != distance || (from == to && distance != LOCAL_DISTANCE)) {
linux/arch/loongarch/mm/init.c:140:	/* With altmap the first mapped page is offset from @start */
linux/arch/loongarch/net/bpf_jit.h:61:	int from = ctx->idx;
linux/arch/arc/include/asm/ptrace.h:33:	unsigned long sp;	/* User/Kernel depending on where we came from */
linux/arch/arc/include/asm/ptrace.h:86:	unsigned long sp;	/* user/kernel sp depending on where we came from  */
linux/arch/arc/include/asm/uaccess.h:150:	if (((unsigned long)to & 0x3) || ((unsigned long)from & 0x3)) {
linux/arch/arc/include/asm/uaccess.h:377:	if (((unsigned long)to & 0x3) || ((unsigned long)from & 0x3)) {
linux/arch/arc/kernel/vmlinux.lds.S:50:	 * errors because of calls from .init.text to .text
linux/arch/arc/kernel/smp.c:201: * Essential requirements being where to run from (PC) and stack (SP)
linux/arch/arc/kernel/unaligned.c:6: *  -Adapted (from .26 to .35)
linux/arch/arc/mm/tlbex.S:204:	; (1) x = addr >> PAGE_SHIFT 	-> masks page-off bits from @fault-addr
linux/arch/arm/include/asm/user.h:28:   backtrace.  We need to write the data from (esp) to
linux/arch/arm/include/asm/ptrace.h:139: * regs_get_register returns the value of a register whose offset from @regs.
linux/arch/arm/include/asm/kexec.h:7:/* Maximum physical address we can use pages from */
linux/arch/arm/include/asm/kexec.h:33: * Function copies machine registers from @oldregs to @newregs. If @oldregs is
linux/arch/arm/include/asm/kasan.h:22: * for kernel really starts from 'compiler's shadow offset' +
linux/arch/arm/include/debug/tegra.S:188: * Code below is swiped from <asm/hardware/debug-8250.S>, but add an extra
linux/arch/arm/mach-mxs/mach-mxs.c:163:	struct device_node *np, *from = NULL;
linux/arch/arm/mach-mxs/mach-mxs.c:175:		from = np;
linux/arch/arm/kernel/tcm.c:329:		pr_debug("CPU DTCM: copied data from %p - %p\n",
linux/arch/arm/kernel/tcm.c:367:		pr_debug("CPU ITCM: copied code from %p - %p\n",
linux/arch/arm/kernel/atags_parse.c:181:	char *from = default_command_line;
linux/arch/arm/kernel/traps.c:84:	printk("%sFunction entered at [<%08lx>] from [<%08lx>]\n",
linux/arch/arm/kernel/traps.c:87:	printk("%s[<%08lx>] (%ps) from [<%08lx>] (%pS)\n",
linux/arch/arm/kernel/traps.c:90:	printk("%s %ps from %pS\n", loglvl, (void *)where, (void *)from);
linux/arch/arm/kernel/io.c:58: * Copy data from "real" memory space to IO memory space.
linux/arch/arm/kernel/head.S:408:	 * Use the page tables supplied from  __cpu_up.
linux/arch/arm/mach-sa1100/assabet.c:615: * (taken from "Intel StrongARM SA-1110 Microprocessor Development Board
linux/arch/arm/mach-s3c/gpio-cfg.h:100: * @nr: The number of pins to configure from @start.
linux/arch/arm/mach-s3c/gpio-cfg.h:139: * @nr: The number of gpio to configure from @start.
linux/arch/arm/mach-omap1/ams-delta-fiq.c:137:	pr_info("Installing fiq handler from %p, length 0x%x\n",
linux/arch/arm/tools/gen-mach-types:27:	  printf(" * This was automagically generated from %s!\n", FILENAME);
linux/arch/arm/mach-omap2/prm3xxx.c:203: * Restore the PRM_IRQENABLE_MPU register from @saved_mask.  Intended
linux/arch/arm/mach-omap2/clockdomain.c:297:		pr_debug("clockdomain: hardware cannot set/clear sleep dependency affecting %s from %s\n",
linux/arch/arm/mach-omap2/clockdomain.c:342:		pr_debug("clockdomain: hardware cannot set/clear sleep dependency affecting %s from %s\n",
linux/arch/arm/mach-omap2/clockdomain.c:795:		pr_debug("clockdomain: hardware cannot set/clear sleep dependency affecting %s from %s\n",
linux/arch/arm/mach-omap2/omap_hwmod.c:2360:		pr_warn("omap_hwmod: %s using broken dt data from %pOFn\n",
linux/arch/arm/mach-omap2/omap_hwmod.c:2665:	pr_debug("omap_hwmod: registering link from %s to %s\n",
linux/arch/arm/mach-omap2/omap_hwmod.c:3857: * if @classname or @fn are NULL, or passes back the error code from @fn.
linux/arch/arm/mach-omap2/pm44xx.c:173:	{.from = "mpuss_clkdm", .to = "l3_emif_clkdm"},
linux/arch/arm/mach-omap2/pm44xx.c:174:	{.from = "mpuss_clkdm", .to = "l3_1_clkdm"},
linux/arch/arm/mach-omap2/pm44xx.c:175:	{.from = "mpuss_clkdm", .to = "l3_2_clkdm"},
linux/arch/arm/mach-omap2/pm44xx.c:176:	{.from = "ducati_clkdm", .to = "l3_1_clkdm"},
linux/arch/arm/mach-omap2/pm44xx.c:177:	{.from = "ducati_clkdm", .to = "l3_2_clkdm"},
linux/arch/arm/mach-omap2/pm44xx.c:178:	{.from  = NULL} /* TERMINATION */
linux/arch/arm/mach-omap2/pm44xx.c:182:	{.from = "mpu_clkdm", .to = "emif_clkdm"},
linux/arch/arm/mach-omap2/pm44xx.c:183:	{.from  = NULL} /* TERMINATION */
linux/arch/arm/mach-omap2/pm44xx.c:199:		from = clkdm_lookup(map->from);
linux/arch/arm/mach-omap2/pm44xx.c:201:		if (!from || !to) {
linux/arch/arm/mach-omap2/clockdomain.h:82: * Statically defined.  @clkdm is resolved from @clkdm_name at runtime and
linux/arch/arm/mach-omap2/omap_device.h:44: * @_driver_status: one of BUS_NOTIFY_*_DRIVER from <linux/device.h>
linux/arch/arm/mach-rpc/io-acorn.S:17:		.ascii	KERN_WARNING "insl/outsl not implemented, called from %08lX\0"
linux/arch/arm/lib/backtrace-clang.S:165: * Print the function (sv_pc) and where it was called from (sv_lr).
linux/arch/arm/lib/copy_from_user.S:26: *	from = user memory
linux/arch/arm/lib/copy_to_user.S:26: *	from = kernel memory
linux/arch/arm/lib/copy_template.S:24: *	This loads one word from 'ptr', stores it in 'reg' and increments
linux/arch/arm/lib/copy_template.S:30: *	This loads four or eight words starting from 'ptr', stores them
linux/arch/arm/lib/uaccess_with_memcpy.c:122:		from += tocopy;
linux/arch/arm/boot/dts/imx6dl-b1x5pv2.dtsi:379:	 * from &usbh1. This means, that we cannot easily detect and handle
linux/arch/arm/mm/pmsa-v7.c:306:		pr_warn("Truncating memory from %pa to %pa (MPU region constraints)",
linux/arch/arm/mm/dma-mapping.c:1707:	pr_debug("Detached IOMMU controller from %s device.\n", dev_name(dev));
linux/arch/arm/mach-bcm/platsmp-brcmstb.c:264:		pr_err("failed to read 1st entry from %s property (%d)\n", name,
linux/arch/arm/mach-bcm/platsmp-brcmstb.c:273:		pr_err("failed to read 2nd entry from %s property (%d)\n", name,
linux/arch/arm/net/bpf_jit_32.c:86:	/* Stack layout - these are offsets from (top of stack - 4) */
linux/arch/arm/net/bpf_jit_32.c:418:	from = ctx->offsets[bpf_from];
linux/arch/arm/net/bpf_jit_32.c:420:	return to - from - 1;
linux/arch/arm/net/bpf_jit_32.c:472:	from = ctx->idx;
linux/arch/arm/net/bpf_jit_32.c:474:	return to - from - 2;
linux/arch/arm/nwfpe/fpmodule.c:138:		       "NWFPE: %s[%d] takes exception %08x at %ps from %08lx\n",
linux/arch/csky/abiv1/alignment.c:90: * Get half-word from [rx + imm]
linux/arch/csky/abiv1/alignment.c:137: * Get word from [rx + imm]
linux/arch/csky/include/asm/ptrace.h:86: * regs_get_register returns the value of a register whose offset from @regs.
linux/arch/csky/kernel/io.c:21:		from += 4;
linux/arch/csky/kernel/io.c:36: * Copy data from "real" memory space to IO memory space.
linux/arch/csky/kernel/io.c:49:		from += 4;
linux/arch/sparc/include/asm/cmpxchg_32.h:36: * Cribbed from <asm-parisc/atomic.h>
linux/arch/sparc/include/asm/ptrace.h:97: * offset from @regs. The @offset is the offset of the register
linux/arch/sparc/include/asm/current.h:8: *  Derived from "include/asm-s390/current.h" by
linux/arch/sparc/include/asm/current.h:10: *  Derived from "include/asm-i386/current.h"
linux/arch/sparc/kernel/time_64.c:133:	 * read back from %tick_cmpr right after writing to it. -DaveM
linux/arch/sparc/kernel/sun4d_irq.c:92: * 2) For each bus showing interrupt pending from #1, read the
linux/arch/sparc/kernel/prom_64.c:617:		prom_printf("Cannot resolve stdout node from "
linux/arch/sparc/kernel/head_32.S:356: * short jumps, as branching to .init.text section from .text is usually
linux/arch/sparc/kernel/prom_32.c:268:			prom_printf("Cannot resolve stdout node from "
linux/arch/sparc/kernel/ds.c:333:	printk(KERN_ALERT "ds-%llu: Shutdown request from "
linux/arch/sparc/kernel/ds.c:373:	printk(KERN_ALERT "ds-%llu: Panic request from "
linux/arch/sparc/kernel/ds.c:880:	printk(KERN_ERR "ds-%llu: ds_conn_reset() from %ps\n",
linux/arch/sparc/kernel/mdesc.c:710:	if (from == MDESC_NODE_NULL || from >= last_node)
linux/arch/sparc/kernel/pcic.c:600: * Normally called from {do_}pci_scan_bus...
linux/arch/sparc/lib/U1memcpy.S:273:	 * subtract this from 'len'.
linux/arch/sparc/lib/U3memcpy.S:204:	 * subtract this from 'len'.
linux/arch/sparc/boot/piggyback.c:194:		fprintf(stderr, "Could not determine start and end from %s\n",
linux/arch/sparc/mm/init_64.c:127:		prom_printf("Couldn't get %s property from /memory.\n",
linux/arch/sparc/mm/init_64.c:1345:	if ((from >= MAX_NUMNODES) || (to >= MAX_NUMNODES)) {
linux/arch/sparc/mm/init_64.c:1348:		return (from == to) ? LOCAL_DISTANCE : REMOTE_DISTANCE;
linux/arch/sparc/mm/leon_mm.c:222:	/* Get Cache regs from "Cache ASI" address 0x0, 0x8 and 0xC */
linux/arch/powerpc/include/asm/rtas-types.h:50: * from "buffer" field of struct rtas_error_log defined above.
linux/arch/powerpc/include/asm/user.h:9: * Adapted from <asm-alpha/user.h>
linux/arch/powerpc/include/asm/ptrace.h:352: * regs_get_register returns the value of a register whose offset from @regs.
linux/arch/powerpc/include/asm/fsl_hcalls.h:342:	uint64_t source;   /**< guest physical address to copy from */
linux/arch/powerpc/include/asm/book3s/64/mmu.h:71:/* Base PID to allocate from */
linux/arch/powerpc/kernel/process.c:3: *  Derived from "arch/i386/kernel/process.c"
linux/arch/powerpc/kernel/pci-hotplug.c:3: * Derived from "arch/powerpc/platforms/pseries/pci_dlpar.c"
linux/arch/powerpc/kernel/trace/ftrace.c:330:			pr_err("No ftrace trampolines reachable from %ps\n",
linux/arch/powerpc/kernel/trace/ftrace.c:499:		pr_err("No ftrace trampolines reachable from %ps\n", ip);
linux/arch/powerpc/kernel/nvram_64.c:913:	/* Adjust or remove the partition we stole the space from */
linux/arch/powerpc/kernel/vmlinux.lds.S:353:	 * to deal with references from .exit.text
linux/arch/powerpc/kernel/head_44x.S:1057:	/* Find the entry we are running from */
linux/arch/powerpc/kernel/signal_32.c:11: *  Derived from "arch/i386/kernel/signal.c"
linux/arch/powerpc/kernel/signal_32.c:71: * registers from *regs.  This is what we need
linux/arch/powerpc/kernel/signal_32.c:1046:		 * from &old_ctx->uc_mcontext to a 16-byte boundary.
linux/arch/powerpc/kernel/pci_dn.c:373:		pci_dbg(pdev, "marked pdn (from %pOF) as dead\n", dn);
linux/arch/powerpc/kernel/exceptions-64e.S:250:	mfspr	r11,SPRN_##type##_SRR1;/* what are we coming from */	    \
linux/arch/powerpc/kernel/mce.c:315:				pr_warn("Failed to identify bad address from "
linux/arch/powerpc/kernel/syscalls.c:7: * Derived from "arch/i386/kernel/sys_i386.c"
linux/arch/powerpc/kernel/ptrace/ptrace.c:5: *  Derived from "arch/m68k/kernel/ptrace.c"
linux/arch/powerpc/kernel/ptrace/ptrace32.c:7: *  Derived from "arch/m68k/kernel/ptrace.c"
linux/arch/powerpc/kernel/signal_64.c:6: *  Derived from "arch/i386/kernel/signal.c"
linux/arch/powerpc/kvm/book3s_hv.c:925:	from_memslot = gfn_to_memslot(kvm, from >> PAGE_SHIFT);
linux/arch/powerpc/kvm/book3s_hv.c:928:	if ((from + len) >= ((from_memslot->base_gfn + from_memslot->npages)
linux/arch/powerpc/kvm/book3s_hv.c:931:	from_addr = gfn_to_hva_memslot(from_memslot, from >> PAGE_SHIFT);
linux/arch/powerpc/kvm/book3s_hv.c:934:	from_addr |= (from & (PAGE_SIZE - 1));
linux/arch/powerpc/kvm/book3s_hv_uvmem.c:355: * starting from *gfn search for the next available GFN that is not yet
linux/arch/powerpc/kvm/book3s_64_mmu_radix.c:46:					  (from != NULL) ? __pa(from): 0, n);
linux/arch/powerpc/kvm/book3s_64_mmu_radix.c:55:		from = (void *) (eaddr | (quadrant << 62));
linux/arch/powerpc/crypto/sha1.c:10: * Derived from "crypto/sha1.c"
linux/arch/powerpc/xmon/xmon.c:1901:			printf("*** Error reading registers from "REG"\n",
linux/arch/powerpc/xmon/ppc.h:308:   16, it takes any value from -0x8000 to 0xffff.  In 64 bit mode,
linux/arch/powerpc/platforms/powernv/pci-ioda.c:475:		pr_warn("%s: Limiting M64 range to 63 (from %d) on PHB#%x\n",
linux/arch/powerpc/platforms/chrp/pegasos_eth.c:128:	printk("Pegasos II/Marvell MV64361: register remapped from %p to %p\n",
linux/arch/powerpc/platforms/chrp/setup.c:4: *  Adapted from 'alpha' version by Gary Thomas
linux/arch/powerpc/platforms/chrp/setup.c:265:	/* find the boot console from /chosen/stdout */
linux/arch/powerpc/platforms/pseries/firmware.c:7: *   Adapted from 'alpha' version by Gary Thomas
linux/arch/powerpc/platforms/pseries/papr_scm.c:1317:		dev_err(dev, "Error registering region %pR from %pOF\n",
linux/arch/powerpc/platforms/pseries/setup.c:6: *  Adapted from 'alpha' version by Gary Thomas
linux/arch/powerpc/platforms/8xx/m8xx_setup.c:4: *  Adapted from 'alpha' version by Gary Thomas
linux/arch/powerpc/platforms/cell/spufs/Makefile:53:		echo " * Hex-dump auto generated from $*.c." ; \
linux/arch/powerpc/platforms/cell/spu_manage.c:479:				 * skipping the one we came from (last_spu_dn)
linux/arch/powerpc/platforms/cell/setup.c:6: *  Adapted from 'alpha' version by Gary Thomas
linux/arch/powerpc/platforms/powermac/setup.c:11: *  Derived from "arch/alpha/kernel/setup.c"
linux/arch/powerpc/perf/core-book3s.c:559:				cpuhw->bhrb_entries[u_index].from = addr;
linux/arch/powerpc/perf/core-book3s.c:563:				cpuhw->bhrb_entries[u_index].from = addr;
linux/arch/powerpc/perf/power6-pmu.c:28:#define PM_SUBUNIT_SH	8	/* Subunit event comes from (NEST_SEL enc.) */
linux/arch/powerpc/sysdev/xive/common.c:524: * will be substracted from "count" later when that CPU observes
linux/arch/powerpc/sysdev/xive/spapr.c:706: * get max priority from "/ibm,plat-res-int-priorities"
linux/arch/powerpc/lib/copypage_power7.S:34:	dcbt	0,r4,0b01000  	/* addr from */
linux/arch/powerpc/lib/copypage_power7.S:35:	dcbt	0,r7,0b01010   /* length and depth from */
linux/arch/powerpc/lib/copyuser_power7.S:305:	dcbt	0,r6,0b01000   /* addr from */
linux/arch/powerpc/lib/copyuser_power7.S:306:	dcbt	0,r7,0b01010   /* length and depth from */
linux/arch/powerpc/boot/wii.c:118:	/* retrieve MEM2 boundary from 'mini' */
linux/arch/powerpc/boot/ns16550.c:5: * Original copied from <file:arch/ppc/boot/common/ns16550.c>
linux/arch/powerpc/boot/io.h:10: * Copied from <file:arch/powerpc/include/asm/io.h> (which has no copyright)
linux/arch/powerpc/boot/util.S:3: * Copied from <file:arch/powerpc/kernel/misc_32.S>
linux/arch/powerpc/boot/serial.c:7: * Code in serial_edit_cmdline() copied from <file:arch/ppc/boot/simple/misc.c>
linux/arch/powerpc/mm/ioremap_64.c:34:	pr_warn("ioremap() called early from %pS. Use early_ioremap() instead\n", caller);
linux/arch/powerpc/mm/ioremap_32.c:71:	pr_warn("ioremap() called early from %pS. Use early_ioremap() instead\n", caller);
linux/arch/powerpc/mm/book3s64/iommu_api.c:370:			 * starting from @hpa might be smaller than 1<<pageshift
linux/arch/powerpc/mm/book3s64/hash_tlb.c:13: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/pgtable_64.c:12: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/init-common.c:10: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/mmu_decl.h:13: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/book3s32/mmu_context.c:16: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/book3s32/mmu.c:16: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/book3s32/tlb.c:16: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/mem.c:11: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/init_32.c:11: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/pgtable.c:13: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/init_64.c:10: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/fault.c:6: *  Derived from "arch/i386/mm/fault.c"
linux/arch/powerpc/mm/nohash/e500.c:19: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/nohash/tlb.c:21: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/nohash/40x.c:14: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/nohash/44x.c:17: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/mm/pgtable_32.c:13: *  Derived from "arch/i386/mm/init.c"
linux/arch/powerpc/kexec/relocate_32.S:171:	/* Invalidate the entry we were executing from */
linux/arch/powerpc/kexec/relocate_32.S:242:	/* Find the entry we are running from */
linux/arch/riscv/include/asm/ptrace.h:133: * regs_get_register returns the value of a register whose offset from @regs.
linux/arch/riscv/include/asm/current.h:23: * This only works because "struct thread_info" is at offset 0 from "struct
linux/arch/riscv/include/asm/kexec.h:12:/* Maximum physical address we can use pages from */
linux/arch/riscv/kernel/setup.c:66: * kexec-tools can retrieve them from /proc/iomem. While there
linux/arch/riscv/mm/init.c:688:	void *from = (void *)(&__data_loc);
linux/arch/riscv/net/bpf_jit.h:126:	int to = ctx->epilogue_offset, from = ctx->ninsns;
linux/arch/riscv/net/bpf_jit.h:219:	from = (insn > 0) ? ctx->offset[insn - 1] : 0;
linux/arch/microblaze/boot/dts/Makefile:12:# Generate system.dtb from $(DTB).dtb
linux/arch/microblaze/mm/mmu_context.c:18: *  Derived from "arch/i386/mm/init.c"
linux/arch/microblaze/mm/pgtable.c:20: *  Derived from "arch/i386/mm/init.c"
linux/arch/microblaze/mm/fault.c:6: *  Derived from "arch/ppc/mm/fault.c"
linux/arch/microblaze/mm/fault.c:9: *  Derived from "arch/i386/mm/fault.c"
linux/arch/s390/include/asm/signal.h:5: *  Derived from "include/asm-i386/signal.h"
linux/arch/s390/include/asm/io.h:7: *  Derived from "include/asm-i386/io.h"
linux/arch/s390/include/asm/mmu_context.h:5: *  Derived from "include/asm-i386/mmu_context.h"
linux/arch/s390/include/asm/elf.h:5: *  Derived from "include/asm-i386/elf.h"
linux/arch/s390/include/asm/hardirq.h:8: *  Derived from "include/asm-i386/hardirq.h"
linux/arch/s390/include/asm/timex.h:6: *  Derived from "include/asm-i386/timex.h"
linux/arch/s390/include/asm/user.h:5: *  Derived from "include/asm-i386/usr.h"
linux/arch/s390/include/asm/user.h:34:   backtrace.  We need to write the data from (esp) to
linux/arch/s390/include/asm/cache.h:6: *  Derived from "include/asm-i386/cache.h"
linux/arch/s390/include/asm/processor.h:8: *  Derived from "include/asm-i386/processor.h"
linux/arch/s390/include/asm/idals.h:238:		from = (void __user *) from + IDA_BLOCK_SIZE;
linux/arch/s390/include/asm/unistd.h:5: *  Derived from "include/asm-i386/unistd.h"
linux/arch/s390/include/asm/uaccess.h:8: *  Derived from "include/asm-i386/uaccess.h"
linux/arch/s390/include/asm/uaccess.h:574: *	 determine if the exchange occurs. The old value read from *@ptr is
linux/arch/s390/include/asm/current.h:7: *  Derived from "include/asm-i386/current.h"
linux/arch/s390/include/asm/delay.h:7: *  Derived from "include/asm-i386/delay.h"
linux/arch/s390/include/asm/pgalloc.h:8: *  Derived from "include/asm-i386/pgalloc.h"
linux/arch/s390/include/asm/kexec.h:23:/* Maximum physical address we can use pages from */
linux/arch/s390/include/asm/spinlock.h:7: *  Derived from "include/asm-i386/spinlock.h"
linux/arch/s390/include/asm/stacktrace.h:59: * %r15 upon function invocation. It may differ from %r15 later if function
linux/arch/s390/include/asm/pgtable.h:9: *  Derived from "include/asm-i386/pgtable.h"
linux/arch/s390/include/uapi/asm/signal.h:5: *  Derived from "include/asm-i386/signal.h"
linux/arch/s390/include/uapi/asm/statfs.h:5: *  Derived from "include/asm-i386/statfs.h"
linux/arch/s390/include/uapi/asm/stat.h:5: *  Derived from "include/asm-i386/stat.h"
linux/arch/s390/include/uapi/asm/unistd.h:5: *  Derived from "include/asm-i386/unistd.h"
linux/arch/s390/include/uapi/asm/ucontext.h:5: *  Derived from "include/asm-i386/ucontext.h"
linux/arch/s390/include/uapi/asm/types.h:5: *  Derived from "include/asm-i386/types.h"
linux/arch/s390/include/uapi/asm/hwctrset.h:43:	__u64 no_cpus;			/* Total # of CPUs data taken from */
linux/arch/s390/kernel/perf_cpum_cf.c:1057:	cpumask_t mask;			/* CPU mask to read from */
linux/arch/s390/kernel/irq.c:274:	return from < NR_IRQS_BASE ? NR_IRQS_BASE : from;
linux/arch/s390/kernel/time.c:11: *  Derived from "arch/i386/kernel/time.c"
linux/arch/s390/kernel/traps.c:8: *  Derived from "arch/i386/kernel/traps.c"
linux/arch/s390/kernel/syscall.c:8: *  Derived from "arch/i386/kernel/sys_i386.c"
linux/arch/s390/kernel/debug.c:906:	from = get_active_entry(src);
linux/arch/s390/kernel/debug.c:918:		from = get_active_entry(src);
linux/arch/s390/kernel/debug.c:919:	} while (from != last);
linux/arch/s390/kernel/setup.c:8: *  Derived from "arch/i386/kernel/setup.c"
linux/arch/s390/kernel/crash_dump.c:163: * Copy one page from "oldmem"
linux/arch/s390/kernel/crash_dump.c:195:		from += size_old;
linux/arch/s390/kernel/crash_dump.c:220:		from += size_hsa;
linux/arch/s390/kvm/guestdbg.c:609:		 * If the AS changed from / to home, we had RP, SAC or SACF
linux/arch/s390/kvm/trace-s390.h:299:		    __entry->from = from;
linux/arch/s390/kvm/trace-s390.h:303:	    TP_printk("for isc %x, modifying interruption mode from %s to %s",
linux/arch/s390/kvm/trace-s390.h:305:		      (__entry->from == KVM_S390_AIS_MODE_ALL) ?
linux/arch/s390/kvm/trace-s390.h:307:		      (__entry->from == KVM_S390_AIS_MODE_SINGLE) ?
linux/arch/s390/kvm/gaccess.h:221: * Copy @len bytes from @data (kernel space) to @ga (guest address).
linux/arch/s390/kvm/gaccess.h:295: * Copy @len bytes from @ga (guest address) to @data (kernel space).
linux/arch/s390/kvm/gaccess.h:316: * Copy @len bytes from @ga (guest address) to @data (kernel space).
linux/arch/s390/kvm/gaccess.h:361: * Copy @len bytes from @data (kernel space) to @gpa (guest absolute address).
linux/arch/s390/kvm/gaccess.h:384: * Copy @len bytes from @gpa (guest absolute address) to @data (kernel space).
linux/arch/s390/kvm/gaccess.h:407: * Copy @len bytes from @data (kernel space) to @gra (guest real address).
linux/arch/s390/kvm/gaccess.h:430: * Copy @len bytes from @gra (guest real address) to @data (kernel space).
linux/arch/s390/kvm/trace.h:306:	    VCPU_TP_PRINTK("%s: loading cr %x-%x from %016llx",
linux/arch/s390/crypto/sha1_s390.c:16: * Derived from "crypto/sha1_generic.c"
linux/arch/s390/crypto/aes_s390.c:14: * Derived from "crypto/aes_generic.c"
linux/arch/s390/pci/pci_mmio.c:60:	 * copy 0 < @len <= 8 bytes from @src into the right most bytes of
linux/arch/s390/lib/uaccess.c:52:		"2:	la	%[rem],4095(%[from])\n"	/* rem = from + 4095 */
linux/arch/s390/lib/uaccess.c:53:		"	nr	%[rem],%[val]\n"	/* rem = (from + 4095) & -4096 */
linux/arch/s390/boot/vmlinux.lds.S:79:	 * struct vmlinux_info. It comes from .vmlinux.info section of
linux/arch/s390/mm/init.c:7: *  Derived from "arch/i386/mm/init.c"
linux/arch/s390/mm/fault.c:8: *  Derived from "arch/i386/mm/fault.c"
linux/arch/s390/mm/gmap.c:432:	if ((from | to | len) & (PMD_SIZE - 1))
linux/arch/s390/mm/gmap.c:434:	if (len == 0 || from + len < from || to + len < to ||
linux/arch/s390/mm/gmap.c:435:	    from + len - 1 > TASK_SIZE_MAX || to + len - 1 > gmap->asce_end)
linux/arch/s390/mm/gmap.c:446:				      (void *) from + off))
linux/arch/s390/net/bpf_jit_comp.c:404: * Save registers from "rs" (register start) to "re" (register end) on stack
linux/arch/s390/net/bpf_jit_comp.c:419: * Restore registers from "rs" (register start) to "re" (register end) on stack
linux/arch/openrisc/kernel/signal.c:46:	 * Restore the regs from &sc->regs.
linux/arch/openrisc/kernel/head.S:290: *       corruption) and set them up from 'current_set'
linux/arch/hexagon/mm/init.c:205:	printk(KERN_INFO "clearing segtable from %p to %p\n", segtable,
linux/arch/nios2/kernel/traps.c:76:	printk("%sStack from %08lx:", loglvl, (unsigned long)stack);
linux/arch/nios2/kernel/insnemu.S:412:	movi r16, 1	/* used to create "rori B,A,1" from "ror B,A,r16" */
linux/arch/nios2/kernel/head.S:135:	ldw	r8, 0(r1)		/* load a word from [r1] */
linux/arch/nios2/boot/compressed/head.S:46:1:	ldw	r8, 0(r1)		/* load a word from [r1] */
linux/arch/mips/math-emu/dsemul.c:128:	pr_debug("free emuframe %d from %d\n", idx, current->pid);
linux/arch/mips/math-emu/dsemul.c:281:	/* Record the PC of the branch, PC to continue from & frame index */
linux/arch/mips/include/asm/mips-cm.h:311:/* GCR_Cx_RESET_BASE - Configure where powered up cores will fetch from */
linux/arch/mips/include/asm/mc146818-time.h:70:		       "set_rtc_mmss: can't update from %d to %d\n",
linux/arch/mips/include/asm/octeon/cvmx-cmd-queue.h:134:	/* FPA pool buffers come from */
linux/arch/mips/include/asm/octeon/cvmx-packet.h:53:		/* The pool that the buffer came from / goes to */
linux/arch/mips/include/asm/mach-au1x00/au1000.h:236:/* allow interrupt to wake cpu from 'wait' */
linux/arch/mips/include/asm/kexec.h:12:/* Maximum physical address we can use pages from */
linux/arch/mips/include/asm/page.h:141: * definitions come from <asm-generic/pgtable-nopud.h>.
linux/arch/mips/include/asm/sn/klconfig.h:37:// XXX Stolen from <sys/SN/router.h>:
linux/arch/mips/include/asm/local.h:137: * Atomically subtracts @i from @l and returns
linux/arch/mips/bcm47xx/leds.c:212:	BCM47XX_GPIO_LED_TRIGGER(0, "green", "status", 1, "timer"), /* Originally blinking when device is ready, separated from "power" LED */
linux/arch/mips/bcm47xx/leds.c:218:	BCM47XX_GPIO_LED_TRIGGER(0, "green", "status", 1, "timer"), /* Originally blinking when device is ready, separated from "power" LED */
linux/arch/mips/dec/time.c:109:		       "set_rtc_mmss: can't update from %d to %d\n",
linux/arch/mips/kernel/vmlinux.lds.S:131:	 * references from .rodata
linux/arch/mips/ralink/ill_acc.c:36:	dev_err(dev, "illegal %s access from %s - addr:0x%08x offset:%d len:%d\n",
linux/arch/mips/loongson2ef/lemote-2f/machtype.c:20:	 * If no "machtype=" passed, get machine type from "PMON_VER=".
linux/arch/mips/lib/csum_partial.S:355:		.if ((\from == USEROP) && (type == LD_INSN)) || \
linux/arch/mips/lib/memcpy.S:124:		.if ((\from == USEROP) && (type == LD_INSN)) || \
linux/arch/mips/lib/memcpy.S:212:		.if ((\from == USEROP) && (type == SRC_PREFETCH)) ||	\
linux/arch/mips/lib/memcpy.S:269:	 * from : Source operand. USEROP or KERNELOP
linux/arch/mips/jazz/jazzdma.c:156:		printk("vdma_alloc: Allocated %d pages starting from %08lx\n",
linux/arch/mips/jazz/jazzdma.c:203:		printk("vdma_free: freed %ld pages starting from %08lx\n",
linux/arch/mips/sibyte/common/bus_watcher.c:52:	printk("Request %02x from %d, answered by %d with Dcode %d\n",
linux/arch/mips/sibyte/common/bus_watcher.c:114:	seq_printf(m, "Request %02x from %d, answered by %d with Dcode %d\n",
linux/arch/mips/cavium-octeon/octeon-irq.c:2328:		pr_err("ERROR: Couldn't read cavium,max-bits from %pOFn\n",
linux/arch/mips/cavium-octeon/setup.c:1088:		panic("Unable to allocate memory from "
linux/arch/mips/mm/cerr-sb1.c:149:		printk("Request %02x from %d, answered by %d with Dcode %d\n",
linux/arch/mips/pic32/pic32mzda/config.c:82:	pr_debug("%s: called from %s:%lu\n", __func__, func, line);
linux/arch/xtensa/include/asm/vectors.h:5: * Memory Addresses from "Virtual == Physical" to their prevvious V2 MMU
linux/arch/xtensa/include/uapi/asm/ioctls.h:11: * Derived from "include/asm-i386/ioctls.h"
linux/arch/xtensa/platforms/iss/simdisk.c:197:			pr_info("SIMDISK: %s detached from %s\n",
linux/arch/xtensa/lib/usercopy.S:75:.Ldstaligned:	# return here from .Ldstunaligned when dst is aligned
linux/arch/xtensa/lib/memcopy.S:121:.Ldstaligned:	# return here from .Ldst?mod? once dst is aligned
linux/arch/xtensa/lib/memcopy.S:395:.Lbackdstaligned:	# return here from .Lbackdst?mod? once dst is aligned
linux/arch/xtensa/lib/memset.S:47:.L0:	# return here from .Ldstunaligned when dst is aligned
linux/arch/sh/include/asm/kexec.h:19:/* Maximum physical address we can use pages from */
linux/arch/sh/boards/mach-sh03/rtc.c:114:		       "set_rtc_mmss: can't update from %d to %d\n",
linux/arch/sh/kernel/dwarf.c:122: *	Read 'n' bytes from @src, where 'n' is the size of an address on
linux/arch/sh/kernel/dwarf.c:125: *	from @src and writing to @dst, because they can be arbitrarily
linux/arch/sh/kernel/io.c:24:	     (((u32)to & 0x1f) == 0) && (((u32)from & 0x3) == 0)) {
linux/arch/sh/kernel/io.c:62:			from += 4;
linux/arch/sh/kernel/io.c:77: * Copy data from "real" memory space to IO memory space.
linux/arch/sh/kernel/io.c:85:			from += 4;
linux/arch/sh/kernel/cpu/sh4/sq.c:54: * Flushes the store queue cache from @start to @start + @len in a
linux/arch/sh/kernel/machvec.c:50:		mv_end = from + strlen(from);
linux/arch/sh/kernel/machvec.c:58:	from = mv_end;
linux/arch/sh/kernel/machvec.c:102:		 * vector (usually the only one) from .machvec.init.
linux/arch/sh/lib/copy_page.S:22: * r8 --- from + PAGE_SIZE
